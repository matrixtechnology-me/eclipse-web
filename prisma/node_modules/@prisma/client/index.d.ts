
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Membership
 * 
 */
export type Membership = $Result.DefaultSelection<Prisma.$MembershipPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationTarget
 * 
 */
export type NotificationTarget = $Result.DefaultSelection<Prisma.$NotificationTargetPayload>
/**
 * Model Pos
 * 
 */
export type Pos = $Result.DefaultSelection<Prisma.$PosPayload>
/**
 * Model PosEvent
 * 
 */
export type PosEvent = $Result.DefaultSelection<Prisma.$PosEventPayload>
/**
 * Model PosEventEntry
 * 
 */
export type PosEventEntry = $Result.DefaultSelection<Prisma.$PosEventEntryPayload>
/**
 * Model PosEventOutput
 * 
 */
export type PosEventOutput = $Result.DefaultSelection<Prisma.$PosEventOutputPayload>
/**
 * Model PosEventSale
 * 
 */
export type PosEventSale = $Result.DefaultSelection<Prisma.$PosEventSalePayload>
/**
 * Model PosEventSaleMovement
 * 
 */
export type PosEventSaleMovement = $Result.DefaultSelection<Prisma.$PosEventSaleMovementPayload>
/**
 * Model PosEventSaleMovementPayment
 * 
 */
export type PosEventSaleMovementPayment = $Result.DefaultSelection<Prisma.$PosEventSaleMovementPaymentPayload>
/**
 * Model PosEventSaleMovementChange
 * 
 */
export type PosEventSaleMovementChange = $Result.DefaultSelection<Prisma.$PosEventSaleMovementChangePayload>
/**
 * Model PosEventSaleProduct
 * 
 */
export type PosEventSaleProduct = $Result.DefaultSelection<Prisma.$PosEventSaleProductPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductSpecification
 * 
 */
export type ProductSpecification = $Result.DefaultSelection<Prisma.$ProductSpecificationPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model SaleMovement
 * 
 */
export type SaleMovement = $Result.DefaultSelection<Prisma.$SaleMovementPayload>
/**
 * Model SaleMovementPayment
 * 
 */
export type SaleMovementPayment = $Result.DefaultSelection<Prisma.$SaleMovementPaymentPayload>
/**
 * Model SaleMovementChange
 * 
 */
export type SaleMovementChange = $Result.DefaultSelection<Prisma.$SaleMovementChangePayload>
/**
 * Model SaleProduct
 * 
 */
export type SaleProduct = $Result.DefaultSelection<Prisma.$SaleProductPayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model StockEvent
 * 
 */
export type StockEvent = $Result.DefaultSelection<Prisma.$StockEventPayload>
/**
 * Model StockEventEntry
 * 
 */
export type StockEventEntry = $Result.DefaultSelection<Prisma.$StockEventEntryPayload>
/**
 * Model StockEventOutput
 * 
 */
export type StockEventOutput = $Result.DefaultSelection<Prisma.$StockEventOutputPayload>
/**
 * Model StockLot
 * 
 */
export type StockLot = $Result.DefaultSelection<Prisma.$StockLotPayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model TenantMembership
 * 
 */
export type TenantMembership = $Result.DefaultSelection<Prisma.$TenantMembershipPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserTenantSettings
 * 
 */
export type UserTenantSettings = $Result.DefaultSelection<Prisma.$UserTenantSettingsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DocumentType: {
  Cpf: 'Cpf',
  Cnpj: 'Cnpj'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const EDiscountVariant: {
  Percentage: 'Percentage',
  Amount: 'Amount'
};

export type EDiscountVariant = (typeof EDiscountVariant)[keyof typeof EDiscountVariant]


export const EInstallmentStatus: {
  FULLY_PAID: 'FULLY_PAID',
  PENDING: 'PENDING',
  NON_PAID: 'NON_PAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID'
};

export type EInstallmentStatus = (typeof EInstallmentStatus)[keyof typeof EInstallmentStatus]


export const EMembershipRole: {
  Owner: 'Owner'
};

export type EMembershipRole = (typeof EMembershipRole)[keyof typeof EMembershipRole]


export const EPeriod: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type EPeriod = (typeof EPeriod)[keyof typeof EPeriod]


export const EPosEventStatus: {
  Processed: 'Processed',
  Canceled: 'Canceled'
};

export type EPosEventStatus = (typeof EPosEventStatus)[keyof typeof EPosEventStatus]


export const EPosEventType: {
  Sale: 'Sale',
  Entry: 'Entry',
  Output: 'Output',
  Payment: 'Payment',
  Return: 'Return',
  Exchange: 'Exchange'
};

export type EPosEventType = (typeof EPosEventType)[keyof typeof EPosEventType]


export const EPosStatus: {
  Opened: 'Opened',
  Closed: 'Closed',
  UnderReview: 'UnderReview'
};

export type EPosStatus = (typeof EPosStatus)[keyof typeof EPosStatus]


export const EPaymentMethod: {
  Cash: 'Cash',
  Pix: 'Pix',
  CreditCard: 'CreditCard',
  DebitCard: 'DebitCard'
};

export type EPaymentMethod = (typeof EPaymentMethod)[keyof typeof EPaymentMethod]


export const ESaleMovementType: {
  Payment: 'Payment',
  Change: 'Change',
  Refund: 'Refund',
  Withdrawal: 'Withdrawal'
};

export type ESaleMovementType = (typeof ESaleMovementType)[keyof typeof ESaleMovementType]


export const ESaleStatus: {
  Processed: 'Processed',
  Canceled: 'Canceled'
};

export type ESaleStatus = (typeof ESaleStatus)[keyof typeof ESaleStatus]


export const EStockEventType: {
  Entry: 'Entry',
  Output: 'Output'
};

export type EStockEventType = (typeof EStockEventType)[keyof typeof EStockEventType]


export const EStockStrategy: {
  Fifo: 'Fifo',
  Lifo: 'Lifo'
};

export type EStockStrategy = (typeof EStockStrategy)[keyof typeof EStockStrategy]


export const ENotificationType: {
  Info: 'Info',
  Success: 'Success',
  Warning: 'Warning',
  Error: 'Error',
  System: 'System',
  Message: 'Message',
  Reminder: 'Reminder',
  Alert: 'Alert'
};

export type ENotificationType = (typeof ENotificationType)[keyof typeof ENotificationType]


export const ENotificationTarget: {
  User: 'User',
  Tenant: 'Tenant'
};

export type ENotificationTarget = (typeof ENotificationTarget)[keyof typeof ENotificationTarget]


export const ENotificationTargetStatus: {
  Read: 'Read',
  Unread: 'Unread'
};

export type ENotificationTargetStatus = (typeof ENotificationTargetStatus)[keyof typeof ENotificationTargetStatus]

}

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type EDiscountVariant = $Enums.EDiscountVariant

export const EDiscountVariant: typeof $Enums.EDiscountVariant

export type EInstallmentStatus = $Enums.EInstallmentStatus

export const EInstallmentStatus: typeof $Enums.EInstallmentStatus

export type EMembershipRole = $Enums.EMembershipRole

export const EMembershipRole: typeof $Enums.EMembershipRole

export type EPeriod = $Enums.EPeriod

export const EPeriod: typeof $Enums.EPeriod

export type EPosEventStatus = $Enums.EPosEventStatus

export const EPosEventStatus: typeof $Enums.EPosEventStatus

export type EPosEventType = $Enums.EPosEventType

export const EPosEventType: typeof $Enums.EPosEventType

export type EPosStatus = $Enums.EPosStatus

export const EPosStatus: typeof $Enums.EPosStatus

export type EPaymentMethod = $Enums.EPaymentMethod

export const EPaymentMethod: typeof $Enums.EPaymentMethod

export type ESaleMovementType = $Enums.ESaleMovementType

export const ESaleMovementType: typeof $Enums.ESaleMovementType

export type ESaleStatus = $Enums.ESaleStatus

export const ESaleStatus: typeof $Enums.ESaleStatus

export type EStockEventType = $Enums.EStockEventType

export const EStockEventType: typeof $Enums.EStockEventType

export type EStockStrategy = $Enums.EStockStrategy

export const EStockStrategy: typeof $Enums.EStockStrategy

export type ENotificationType = $Enums.ENotificationType

export const ENotificationType: typeof $Enums.ENotificationType

export type ENotificationTarget = $Enums.ENotificationTarget

export const ENotificationTarget: typeof $Enums.ENotificationTarget

export type ENotificationTargetStatus = $Enums.ENotificationTargetStatus

export const ENotificationTargetStatus: typeof $Enums.ENotificationTargetStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Addresses
 * const addresses = await prisma.address.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membership`: Exposes CRUD operations for the **Membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memberships
    * const memberships = await prisma.membership.findMany()
    * ```
    */
  get membership(): Prisma.MembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationTarget`: Exposes CRUD operations for the **NotificationTarget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationTargets
    * const notificationTargets = await prisma.notificationTarget.findMany()
    * ```
    */
  get notificationTarget(): Prisma.NotificationTargetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pos`: Exposes CRUD operations for the **Pos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pos
    * const pos = await prisma.pos.findMany()
    * ```
    */
  get pos(): Prisma.PosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posEvent`: Exposes CRUD operations for the **PosEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosEvents
    * const posEvents = await prisma.posEvent.findMany()
    * ```
    */
  get posEvent(): Prisma.PosEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posEventEntry`: Exposes CRUD operations for the **PosEventEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosEventEntries
    * const posEventEntries = await prisma.posEventEntry.findMany()
    * ```
    */
  get posEventEntry(): Prisma.PosEventEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posEventOutput`: Exposes CRUD operations for the **PosEventOutput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosEventOutputs
    * const posEventOutputs = await prisma.posEventOutput.findMany()
    * ```
    */
  get posEventOutput(): Prisma.PosEventOutputDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posEventSale`: Exposes CRUD operations for the **PosEventSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosEventSales
    * const posEventSales = await prisma.posEventSale.findMany()
    * ```
    */
  get posEventSale(): Prisma.PosEventSaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posEventSaleMovement`: Exposes CRUD operations for the **PosEventSaleMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosEventSaleMovements
    * const posEventSaleMovements = await prisma.posEventSaleMovement.findMany()
    * ```
    */
  get posEventSaleMovement(): Prisma.PosEventSaleMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posEventSaleMovementPayment`: Exposes CRUD operations for the **PosEventSaleMovementPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosEventSaleMovementPayments
    * const posEventSaleMovementPayments = await prisma.posEventSaleMovementPayment.findMany()
    * ```
    */
  get posEventSaleMovementPayment(): Prisma.PosEventSaleMovementPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posEventSaleMovementChange`: Exposes CRUD operations for the **PosEventSaleMovementChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosEventSaleMovementChanges
    * const posEventSaleMovementChanges = await prisma.posEventSaleMovementChange.findMany()
    * ```
    */
  get posEventSaleMovementChange(): Prisma.PosEventSaleMovementChangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posEventSaleProduct`: Exposes CRUD operations for the **PosEventSaleProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PosEventSaleProducts
    * const posEventSaleProducts = await prisma.posEventSaleProduct.findMany()
    * ```
    */
  get posEventSaleProduct(): Prisma.PosEventSaleProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productSpecification`: Exposes CRUD operations for the **ProductSpecification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductSpecifications
    * const productSpecifications = await prisma.productSpecification.findMany()
    * ```
    */
  get productSpecification(): Prisma.ProductSpecificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleMovement`: Exposes CRUD operations for the **SaleMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleMovements
    * const saleMovements = await prisma.saleMovement.findMany()
    * ```
    */
  get saleMovement(): Prisma.SaleMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleMovementPayment`: Exposes CRUD operations for the **SaleMovementPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleMovementPayments
    * const saleMovementPayments = await prisma.saleMovementPayment.findMany()
    * ```
    */
  get saleMovementPayment(): Prisma.SaleMovementPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleMovementChange`: Exposes CRUD operations for the **SaleMovementChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleMovementChanges
    * const saleMovementChanges = await prisma.saleMovementChange.findMany()
    * ```
    */
  get saleMovementChange(): Prisma.SaleMovementChangeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleProduct`: Exposes CRUD operations for the **SaleProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleProducts
    * const saleProducts = await prisma.saleProduct.findMany()
    * ```
    */
  get saleProduct(): Prisma.SaleProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockEvent`: Exposes CRUD operations for the **StockEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockEvents
    * const stockEvents = await prisma.stockEvent.findMany()
    * ```
    */
  get stockEvent(): Prisma.StockEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockEventEntry`: Exposes CRUD operations for the **StockEventEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockEventEntries
    * const stockEventEntries = await prisma.stockEventEntry.findMany()
    * ```
    */
  get stockEventEntry(): Prisma.StockEventEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockEventOutput`: Exposes CRUD operations for the **StockEventOutput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockEventOutputs
    * const stockEventOutputs = await prisma.stockEventOutput.findMany()
    * ```
    */
  get stockEventOutput(): Prisma.StockEventOutputDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockLot`: Exposes CRUD operations for the **StockLot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockLots
    * const stockLots = await prisma.stockLot.findMany()
    * ```
    */
  get stockLot(): Prisma.StockLotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tenantMembership`: Exposes CRUD operations for the **TenantMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TenantMemberships
    * const tenantMemberships = await prisma.tenantMembership.findMany()
    * ```
    */
  get tenantMembership(): Prisma.TenantMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTenantSettings`: Exposes CRUD operations for the **UserTenantSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTenantSettings
    * const userTenantSettings = await prisma.userTenantSettings.findMany()
    * ```
    */
  get userTenantSettings(): Prisma.UserTenantSettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Address: 'Address',
    Customer: 'Customer',
    Document: 'Document',
    Membership: 'Membership',
    Notification: 'Notification',
    NotificationTarget: 'NotificationTarget',
    Pos: 'Pos',
    PosEvent: 'PosEvent',
    PosEventEntry: 'PosEventEntry',
    PosEventOutput: 'PosEventOutput',
    PosEventSale: 'PosEventSale',
    PosEventSaleMovement: 'PosEventSaleMovement',
    PosEventSaleMovementPayment: 'PosEventSaleMovementPayment',
    PosEventSaleMovementChange: 'PosEventSaleMovementChange',
    PosEventSaleProduct: 'PosEventSaleProduct',
    Product: 'Product',
    ProductSpecification: 'ProductSpecification',
    Sale: 'Sale',
    SaleMovement: 'SaleMovement',
    SaleMovementPayment: 'SaleMovementPayment',
    SaleMovementChange: 'SaleMovementChange',
    SaleProduct: 'SaleProduct',
    Stock: 'Stock',
    StockEvent: 'StockEvent',
    StockEventEntry: 'StockEventEntry',
    StockEventOutput: 'StockEventOutput',
    StockLot: 'StockLot',
    Tenant: 'Tenant',
    TenantMembership: 'TenantMembership',
    User: 'User',
    UserTenantSettings: 'UserTenantSettings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "address" | "customer" | "document" | "membership" | "notification" | "notificationTarget" | "pos" | "posEvent" | "posEventEntry" | "posEventOutput" | "posEventSale" | "posEventSaleMovement" | "posEventSaleMovementPayment" | "posEventSaleMovementChange" | "posEventSaleProduct" | "product" | "productSpecification" | "sale" | "saleMovement" | "saleMovementPayment" | "saleMovementChange" | "saleProduct" | "stock" | "stockEvent" | "stockEventEntry" | "stockEventOutput" | "stockLot" | "tenant" | "tenantMembership" | "user" | "userTenantSettings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Membership: {
        payload: Prisma.$MembershipPayload<ExtArgs>
        fields: Prisma.MembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findFirst: {
            args: Prisma.MembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          findMany: {
            args: Prisma.MembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          create: {
            args: Prisma.MembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          createMany: {
            args: Prisma.MembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          delete: {
            args: Prisma.MembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          update: {
            args: Prisma.MembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          deleteMany: {
            args: Prisma.MembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>[]
          }
          upsert: {
            args: Prisma.MembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembershipPayload>
          }
          aggregate: {
            args: Prisma.MembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembership>
          }
          groupBy: {
            args: Prisma.MembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembershipCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationTarget: {
        payload: Prisma.$NotificationTargetPayload<ExtArgs>
        fields: Prisma.NotificationTargetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationTargetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationTargetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>
          }
          findFirst: {
            args: Prisma.NotificationTargetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationTargetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>
          }
          findMany: {
            args: Prisma.NotificationTargetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>[]
          }
          create: {
            args: Prisma.NotificationTargetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>
          }
          createMany: {
            args: Prisma.NotificationTargetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationTargetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>[]
          }
          delete: {
            args: Prisma.NotificationTargetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>
          }
          update: {
            args: Prisma.NotificationTargetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>
          }
          deleteMany: {
            args: Prisma.NotificationTargetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationTargetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationTargetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>[]
          }
          upsert: {
            args: Prisma.NotificationTargetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTargetPayload>
          }
          aggregate: {
            args: Prisma.NotificationTargetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationTarget>
          }
          groupBy: {
            args: Prisma.NotificationTargetGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationTargetGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationTargetCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationTargetCountAggregateOutputType> | number
          }
        }
      }
      Pos: {
        payload: Prisma.$PosPayload<ExtArgs>
        fields: Prisma.PosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>
          }
          findFirst: {
            args: Prisma.PosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>
          }
          findMany: {
            args: Prisma.PosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>[]
          }
          create: {
            args: Prisma.PosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>
          }
          createMany: {
            args: Prisma.PosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>[]
          }
          delete: {
            args: Prisma.PosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>
          }
          update: {
            args: Prisma.PosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>
          }
          deleteMany: {
            args: Prisma.PosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>[]
          }
          upsert: {
            args: Prisma.PosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosPayload>
          }
          aggregate: {
            args: Prisma.PosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePos>
          }
          groupBy: {
            args: Prisma.PosGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosCountArgs<ExtArgs>
            result: $Utils.Optional<PosCountAggregateOutputType> | number
          }
        }
      }
      PosEvent: {
        payload: Prisma.$PosEventPayload<ExtArgs>
        fields: Prisma.PosEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>
          }
          findFirst: {
            args: Prisma.PosEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>
          }
          findMany: {
            args: Prisma.PosEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>[]
          }
          create: {
            args: Prisma.PosEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>
          }
          createMany: {
            args: Prisma.PosEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>[]
          }
          delete: {
            args: Prisma.PosEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>
          }
          update: {
            args: Prisma.PosEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>
          }
          deleteMany: {
            args: Prisma.PosEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>[]
          }
          upsert: {
            args: Prisma.PosEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventPayload>
          }
          aggregate: {
            args: Prisma.PosEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosEvent>
          }
          groupBy: {
            args: Prisma.PosEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosEventCountArgs<ExtArgs>
            result: $Utils.Optional<PosEventCountAggregateOutputType> | number
          }
        }
      }
      PosEventEntry: {
        payload: Prisma.$PosEventEntryPayload<ExtArgs>
        fields: Prisma.PosEventEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosEventEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosEventEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>
          }
          findFirst: {
            args: Prisma.PosEventEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosEventEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>
          }
          findMany: {
            args: Prisma.PosEventEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>[]
          }
          create: {
            args: Prisma.PosEventEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>
          }
          createMany: {
            args: Prisma.PosEventEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosEventEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>[]
          }
          delete: {
            args: Prisma.PosEventEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>
          }
          update: {
            args: Prisma.PosEventEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>
          }
          deleteMany: {
            args: Prisma.PosEventEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosEventEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosEventEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>[]
          }
          upsert: {
            args: Prisma.PosEventEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventEntryPayload>
          }
          aggregate: {
            args: Prisma.PosEventEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosEventEntry>
          }
          groupBy: {
            args: Prisma.PosEventEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosEventEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosEventEntryCountArgs<ExtArgs>
            result: $Utils.Optional<PosEventEntryCountAggregateOutputType> | number
          }
        }
      }
      PosEventOutput: {
        payload: Prisma.$PosEventOutputPayload<ExtArgs>
        fields: Prisma.PosEventOutputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosEventOutputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosEventOutputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>
          }
          findFirst: {
            args: Prisma.PosEventOutputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosEventOutputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>
          }
          findMany: {
            args: Prisma.PosEventOutputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>[]
          }
          create: {
            args: Prisma.PosEventOutputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>
          }
          createMany: {
            args: Prisma.PosEventOutputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosEventOutputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>[]
          }
          delete: {
            args: Prisma.PosEventOutputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>
          }
          update: {
            args: Prisma.PosEventOutputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>
          }
          deleteMany: {
            args: Prisma.PosEventOutputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosEventOutputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosEventOutputUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>[]
          }
          upsert: {
            args: Prisma.PosEventOutputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventOutputPayload>
          }
          aggregate: {
            args: Prisma.PosEventOutputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosEventOutput>
          }
          groupBy: {
            args: Prisma.PosEventOutputGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosEventOutputGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosEventOutputCountArgs<ExtArgs>
            result: $Utils.Optional<PosEventOutputCountAggregateOutputType> | number
          }
        }
      }
      PosEventSale: {
        payload: Prisma.$PosEventSalePayload<ExtArgs>
        fields: Prisma.PosEventSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosEventSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosEventSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>
          }
          findFirst: {
            args: Prisma.PosEventSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosEventSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>
          }
          findMany: {
            args: Prisma.PosEventSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>[]
          }
          create: {
            args: Prisma.PosEventSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>
          }
          createMany: {
            args: Prisma.PosEventSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosEventSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>[]
          }
          delete: {
            args: Prisma.PosEventSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>
          }
          update: {
            args: Prisma.PosEventSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>
          }
          deleteMany: {
            args: Prisma.PosEventSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosEventSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosEventSaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>[]
          }
          upsert: {
            args: Prisma.PosEventSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSalePayload>
          }
          aggregate: {
            args: Prisma.PosEventSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosEventSale>
          }
          groupBy: {
            args: Prisma.PosEventSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosEventSaleCountArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleCountAggregateOutputType> | number
          }
        }
      }
      PosEventSaleMovement: {
        payload: Prisma.$PosEventSaleMovementPayload<ExtArgs>
        fields: Prisma.PosEventSaleMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosEventSaleMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosEventSaleMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>
          }
          findFirst: {
            args: Prisma.PosEventSaleMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosEventSaleMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>
          }
          findMany: {
            args: Prisma.PosEventSaleMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>[]
          }
          create: {
            args: Prisma.PosEventSaleMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>
          }
          createMany: {
            args: Prisma.PosEventSaleMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosEventSaleMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>[]
          }
          delete: {
            args: Prisma.PosEventSaleMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>
          }
          update: {
            args: Prisma.PosEventSaleMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>
          }
          deleteMany: {
            args: Prisma.PosEventSaleMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosEventSaleMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosEventSaleMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>[]
          }
          upsert: {
            args: Prisma.PosEventSaleMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPayload>
          }
          aggregate: {
            args: Prisma.PosEventSaleMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosEventSaleMovement>
          }
          groupBy: {
            args: Prisma.PosEventSaleMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosEventSaleMovementCountArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleMovementCountAggregateOutputType> | number
          }
        }
      }
      PosEventSaleMovementPayment: {
        payload: Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>
        fields: Prisma.PosEventSaleMovementPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosEventSaleMovementPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosEventSaleMovementPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>
          }
          findFirst: {
            args: Prisma.PosEventSaleMovementPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosEventSaleMovementPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>
          }
          findMany: {
            args: Prisma.PosEventSaleMovementPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>[]
          }
          create: {
            args: Prisma.PosEventSaleMovementPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>
          }
          createMany: {
            args: Prisma.PosEventSaleMovementPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosEventSaleMovementPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>[]
          }
          delete: {
            args: Prisma.PosEventSaleMovementPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>
          }
          update: {
            args: Prisma.PosEventSaleMovementPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>
          }
          deleteMany: {
            args: Prisma.PosEventSaleMovementPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosEventSaleMovementPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosEventSaleMovementPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>[]
          }
          upsert: {
            args: Prisma.PosEventSaleMovementPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementPaymentPayload>
          }
          aggregate: {
            args: Prisma.PosEventSaleMovementPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosEventSaleMovementPayment>
          }
          groupBy: {
            args: Prisma.PosEventSaleMovementPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleMovementPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosEventSaleMovementPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleMovementPaymentCountAggregateOutputType> | number
          }
        }
      }
      PosEventSaleMovementChange: {
        payload: Prisma.$PosEventSaleMovementChangePayload<ExtArgs>
        fields: Prisma.PosEventSaleMovementChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosEventSaleMovementChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosEventSaleMovementChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>
          }
          findFirst: {
            args: Prisma.PosEventSaleMovementChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosEventSaleMovementChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>
          }
          findMany: {
            args: Prisma.PosEventSaleMovementChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>[]
          }
          create: {
            args: Prisma.PosEventSaleMovementChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>
          }
          createMany: {
            args: Prisma.PosEventSaleMovementChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosEventSaleMovementChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>[]
          }
          delete: {
            args: Prisma.PosEventSaleMovementChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>
          }
          update: {
            args: Prisma.PosEventSaleMovementChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>
          }
          deleteMany: {
            args: Prisma.PosEventSaleMovementChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosEventSaleMovementChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosEventSaleMovementChangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>[]
          }
          upsert: {
            args: Prisma.PosEventSaleMovementChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleMovementChangePayload>
          }
          aggregate: {
            args: Prisma.PosEventSaleMovementChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosEventSaleMovementChange>
          }
          groupBy: {
            args: Prisma.PosEventSaleMovementChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleMovementChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosEventSaleMovementChangeCountArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleMovementChangeCountAggregateOutputType> | number
          }
        }
      }
      PosEventSaleProduct: {
        payload: Prisma.$PosEventSaleProductPayload<ExtArgs>
        fields: Prisma.PosEventSaleProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PosEventSaleProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PosEventSaleProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>
          }
          findFirst: {
            args: Prisma.PosEventSaleProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PosEventSaleProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>
          }
          findMany: {
            args: Prisma.PosEventSaleProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>[]
          }
          create: {
            args: Prisma.PosEventSaleProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>
          }
          createMany: {
            args: Prisma.PosEventSaleProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PosEventSaleProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>[]
          }
          delete: {
            args: Prisma.PosEventSaleProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>
          }
          update: {
            args: Prisma.PosEventSaleProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>
          }
          deleteMany: {
            args: Prisma.PosEventSaleProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PosEventSaleProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PosEventSaleProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>[]
          }
          upsert: {
            args: Prisma.PosEventSaleProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PosEventSaleProductPayload>
          }
          aggregate: {
            args: Prisma.PosEventSaleProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosEventSaleProduct>
          }
          groupBy: {
            args: Prisma.PosEventSaleProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.PosEventSaleProductCountArgs<ExtArgs>
            result: $Utils.Optional<PosEventSaleProductCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductSpecification: {
        payload: Prisma.$ProductSpecificationPayload<ExtArgs>
        fields: Prisma.ProductSpecificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductSpecificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductSpecificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
          }
          findFirst: {
            args: Prisma.ProductSpecificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductSpecificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
          }
          findMany: {
            args: Prisma.ProductSpecificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>[]
          }
          create: {
            args: Prisma.ProductSpecificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
          }
          createMany: {
            args: Prisma.ProductSpecificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductSpecificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>[]
          }
          delete: {
            args: Prisma.ProductSpecificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
          }
          update: {
            args: Prisma.ProductSpecificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
          }
          deleteMany: {
            args: Prisma.ProductSpecificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductSpecificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductSpecificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>[]
          }
          upsert: {
            args: Prisma.ProductSpecificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductSpecificationPayload>
          }
          aggregate: {
            args: Prisma.ProductSpecificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductSpecification>
          }
          groupBy: {
            args: Prisma.ProductSpecificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductSpecificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductSpecificationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductSpecificationCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      SaleMovement: {
        payload: Prisma.$SaleMovementPayload<ExtArgs>
        fields: Prisma.SaleMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>
          }
          findFirst: {
            args: Prisma.SaleMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>
          }
          findMany: {
            args: Prisma.SaleMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>[]
          }
          create: {
            args: Prisma.SaleMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>
          }
          createMany: {
            args: Prisma.SaleMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleMovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>[]
          }
          delete: {
            args: Prisma.SaleMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>
          }
          update: {
            args: Prisma.SaleMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>
          }
          deleteMany: {
            args: Prisma.SaleMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleMovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>[]
          }
          upsert: {
            args: Prisma.SaleMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPayload>
          }
          aggregate: {
            args: Prisma.SaleMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleMovement>
          }
          groupBy: {
            args: Prisma.SaleMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleMovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleMovementCountArgs<ExtArgs>
            result: $Utils.Optional<SaleMovementCountAggregateOutputType> | number
          }
        }
      }
      SaleMovementPayment: {
        payload: Prisma.$SaleMovementPaymentPayload<ExtArgs>
        fields: Prisma.SaleMovementPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleMovementPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleMovementPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>
          }
          findFirst: {
            args: Prisma.SaleMovementPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleMovementPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>
          }
          findMany: {
            args: Prisma.SaleMovementPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>[]
          }
          create: {
            args: Prisma.SaleMovementPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>
          }
          createMany: {
            args: Prisma.SaleMovementPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleMovementPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>[]
          }
          delete: {
            args: Prisma.SaleMovementPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>
          }
          update: {
            args: Prisma.SaleMovementPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SaleMovementPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleMovementPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleMovementPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>[]
          }
          upsert: {
            args: Prisma.SaleMovementPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementPaymentPayload>
          }
          aggregate: {
            args: Prisma.SaleMovementPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleMovementPayment>
          }
          groupBy: {
            args: Prisma.SaleMovementPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleMovementPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleMovementPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SaleMovementPaymentCountAggregateOutputType> | number
          }
        }
      }
      SaleMovementChange: {
        payload: Prisma.$SaleMovementChangePayload<ExtArgs>
        fields: Prisma.SaleMovementChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleMovementChangeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleMovementChangeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>
          }
          findFirst: {
            args: Prisma.SaleMovementChangeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleMovementChangeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>
          }
          findMany: {
            args: Prisma.SaleMovementChangeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>[]
          }
          create: {
            args: Prisma.SaleMovementChangeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>
          }
          createMany: {
            args: Prisma.SaleMovementChangeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleMovementChangeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>[]
          }
          delete: {
            args: Prisma.SaleMovementChangeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>
          }
          update: {
            args: Prisma.SaleMovementChangeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>
          }
          deleteMany: {
            args: Prisma.SaleMovementChangeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleMovementChangeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleMovementChangeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>[]
          }
          upsert: {
            args: Prisma.SaleMovementChangeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleMovementChangePayload>
          }
          aggregate: {
            args: Prisma.SaleMovementChangeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleMovementChange>
          }
          groupBy: {
            args: Prisma.SaleMovementChangeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleMovementChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleMovementChangeCountArgs<ExtArgs>
            result: $Utils.Optional<SaleMovementChangeCountAggregateOutputType> | number
          }
        }
      }
      SaleProduct: {
        payload: Prisma.$SaleProductPayload<ExtArgs>
        fields: Prisma.SaleProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          findFirst: {
            args: Prisma.SaleProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          findMany: {
            args: Prisma.SaleProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>[]
          }
          create: {
            args: Prisma.SaleProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          createMany: {
            args: Prisma.SaleProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>[]
          }
          delete: {
            args: Prisma.SaleProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          update: {
            args: Prisma.SaleProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          deleteMany: {
            args: Prisma.SaleProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>[]
          }
          upsert: {
            args: Prisma.SaleProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleProductPayload>
          }
          aggregate: {
            args: Prisma.SaleProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleProduct>
          }
          groupBy: {
            args: Prisma.SaleProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleProductCountArgs<ExtArgs>
            result: $Utils.Optional<SaleProductCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      StockEvent: {
        payload: Prisma.$StockEventPayload<ExtArgs>
        fields: Prisma.StockEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>
          }
          findFirst: {
            args: Prisma.StockEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>
          }
          findMany: {
            args: Prisma.StockEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>[]
          }
          create: {
            args: Prisma.StockEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>
          }
          createMany: {
            args: Prisma.StockEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>[]
          }
          delete: {
            args: Prisma.StockEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>
          }
          update: {
            args: Prisma.StockEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>
          }
          deleteMany: {
            args: Prisma.StockEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>[]
          }
          upsert: {
            args: Prisma.StockEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventPayload>
          }
          aggregate: {
            args: Prisma.StockEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockEvent>
          }
          groupBy: {
            args: Prisma.StockEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockEventCountArgs<ExtArgs>
            result: $Utils.Optional<StockEventCountAggregateOutputType> | number
          }
        }
      }
      StockEventEntry: {
        payload: Prisma.$StockEventEntryPayload<ExtArgs>
        fields: Prisma.StockEventEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockEventEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockEventEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>
          }
          findFirst: {
            args: Prisma.StockEventEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockEventEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>
          }
          findMany: {
            args: Prisma.StockEventEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>[]
          }
          create: {
            args: Prisma.StockEventEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>
          }
          createMany: {
            args: Prisma.StockEventEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockEventEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>[]
          }
          delete: {
            args: Prisma.StockEventEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>
          }
          update: {
            args: Prisma.StockEventEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>
          }
          deleteMany: {
            args: Prisma.StockEventEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockEventEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockEventEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>[]
          }
          upsert: {
            args: Prisma.StockEventEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventEntryPayload>
          }
          aggregate: {
            args: Prisma.StockEventEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockEventEntry>
          }
          groupBy: {
            args: Prisma.StockEventEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockEventEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockEventEntryCountArgs<ExtArgs>
            result: $Utils.Optional<StockEventEntryCountAggregateOutputType> | number
          }
        }
      }
      StockEventOutput: {
        payload: Prisma.$StockEventOutputPayload<ExtArgs>
        fields: Prisma.StockEventOutputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockEventOutputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockEventOutputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>
          }
          findFirst: {
            args: Prisma.StockEventOutputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockEventOutputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>
          }
          findMany: {
            args: Prisma.StockEventOutputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>[]
          }
          create: {
            args: Prisma.StockEventOutputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>
          }
          createMany: {
            args: Prisma.StockEventOutputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockEventOutputCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>[]
          }
          delete: {
            args: Prisma.StockEventOutputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>
          }
          update: {
            args: Prisma.StockEventOutputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>
          }
          deleteMany: {
            args: Prisma.StockEventOutputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockEventOutputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockEventOutputUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>[]
          }
          upsert: {
            args: Prisma.StockEventOutputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockEventOutputPayload>
          }
          aggregate: {
            args: Prisma.StockEventOutputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockEventOutput>
          }
          groupBy: {
            args: Prisma.StockEventOutputGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockEventOutputGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockEventOutputCountArgs<ExtArgs>
            result: $Utils.Optional<StockEventOutputCountAggregateOutputType> | number
          }
        }
      }
      StockLot: {
        payload: Prisma.$StockLotPayload<ExtArgs>
        fields: Prisma.StockLotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockLotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockLotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>
          }
          findFirst: {
            args: Prisma.StockLotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockLotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>
          }
          findMany: {
            args: Prisma.StockLotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>[]
          }
          create: {
            args: Prisma.StockLotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>
          }
          createMany: {
            args: Prisma.StockLotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockLotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>[]
          }
          delete: {
            args: Prisma.StockLotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>
          }
          update: {
            args: Prisma.StockLotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>
          }
          deleteMany: {
            args: Prisma.StockLotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockLotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockLotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>[]
          }
          upsert: {
            args: Prisma.StockLotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockLotPayload>
          }
          aggregate: {
            args: Prisma.StockLotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockLot>
          }
          groupBy: {
            args: Prisma.StockLotGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockLotGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockLotCountArgs<ExtArgs>
            result: $Utils.Optional<StockLotCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      TenantMembership: {
        payload: Prisma.$TenantMembershipPayload<ExtArgs>
        fields: Prisma.TenantMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
          }
          findFirst: {
            args: Prisma.TenantMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
          }
          findMany: {
            args: Prisma.TenantMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>[]
          }
          create: {
            args: Prisma.TenantMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
          }
          createMany: {
            args: Prisma.TenantMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>[]
          }
          delete: {
            args: Prisma.TenantMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
          }
          update: {
            args: Prisma.TenantMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
          }
          deleteMany: {
            args: Prisma.TenantMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>[]
          }
          upsert: {
            args: Prisma.TenantMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantMembershipPayload>
          }
          aggregate: {
            args: Prisma.TenantMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenantMembership>
          }
          groupBy: {
            args: Prisma.TenantMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<TenantMembershipCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserTenantSettings: {
        payload: Prisma.$UserTenantSettingsPayload<ExtArgs>
        fields: Prisma.UserTenantSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTenantSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTenantSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserTenantSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTenantSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>
          }
          findMany: {
            args: Prisma.UserTenantSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>[]
          }
          create: {
            args: Prisma.UserTenantSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>
          }
          createMany: {
            args: Prisma.UserTenantSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTenantSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserTenantSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>
          }
          update: {
            args: Prisma.UserTenantSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserTenantSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTenantSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTenantSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserTenantSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTenantSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserTenantSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTenantSettings>
          }
          groupBy: {
            args: Prisma.UserTenantSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTenantSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTenantSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserTenantSettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    address?: AddressOmit
    customer?: CustomerOmit
    document?: DocumentOmit
    membership?: MembershipOmit
    notification?: NotificationOmit
    notificationTarget?: NotificationTargetOmit
    pos?: PosOmit
    posEvent?: PosEventOmit
    posEventEntry?: PosEventEntryOmit
    posEventOutput?: PosEventOutputOmit
    posEventSale?: PosEventSaleOmit
    posEventSaleMovement?: PosEventSaleMovementOmit
    posEventSaleMovementPayment?: PosEventSaleMovementPaymentOmit
    posEventSaleMovementChange?: PosEventSaleMovementChangeOmit
    posEventSaleProduct?: PosEventSaleProductOmit
    product?: ProductOmit
    productSpecification?: ProductSpecificationOmit
    sale?: SaleOmit
    saleMovement?: SaleMovementOmit
    saleMovementPayment?: SaleMovementPaymentOmit
    saleMovementChange?: SaleMovementChangeOmit
    saleProduct?: SaleProductOmit
    stock?: StockOmit
    stockEvent?: StockEventOmit
    stockEventEntry?: StockEventEntryOmit
    stockEventOutput?: StockEventOutputOmit
    stockLot?: StockLotOmit
    tenant?: TenantOmit
    tenantMembership?: TenantMembershipOmit
    user?: UserOmit
    userTenantSettings?: UserTenantSettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    sales: number
    posEventSales: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | CustomerCountOutputTypeCountSalesArgs
    posEventSales?: boolean | CustomerCountOutputTypeCountPosEventSalesArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPosEventSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleWhereInput
  }


  /**
   * Count Type MembershipCountOutputType
   */

  export type MembershipCountOutputType = {
    tenant_memberships: number
  }

  export type MembershipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant_memberships?: boolean | MembershipCountOutputTypeCountTenant_membershipsArgs
  }

  // Custom InputTypes
  /**
   * MembershipCountOutputType without action
   */
  export type MembershipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipCountOutputType
     */
    select?: MembershipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MembershipCountOutputType without action
   */
  export type MembershipCountOutputTypeCountTenant_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantMembershipWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    targets: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targets?: boolean | NotificationCountOutputTypeCountTargetsArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTargetWhereInput
  }


  /**
   * Count Type PosEventSaleCountOutputType
   */

  export type PosEventSaleCountOutputType = {
    products: number
    movements: number
  }

  export type PosEventSaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | PosEventSaleCountOutputTypeCountProductsArgs
    movements?: boolean | PosEventSaleCountOutputTypeCountMovementsArgs
  }

  // Custom InputTypes
  /**
   * PosEventSaleCountOutputType without action
   */
  export type PosEventSaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleCountOutputType
     */
    select?: PosEventSaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PosEventSaleCountOutputType without action
   */
  export type PosEventSaleCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleProductWhereInput
  }

  /**
   * PosEventSaleCountOutputType without action
   */
  export type PosEventSaleCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleMovementWhereInput
  }


  /**
   * Count Type PosEventSaleMovementCountOutputType
   */

  export type PosEventSaleMovementCountOutputType = {
    payments: number
    changes: number
  }

  export type PosEventSaleMovementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PosEventSaleMovementCountOutputTypeCountPaymentsArgs
    changes?: boolean | PosEventSaleMovementCountOutputTypeCountChangesArgs
  }

  // Custom InputTypes
  /**
   * PosEventSaleMovementCountOutputType without action
   */
  export type PosEventSaleMovementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementCountOutputType
     */
    select?: PosEventSaleMovementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PosEventSaleMovementCountOutputType without action
   */
  export type PosEventSaleMovementCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleMovementPaymentWhereInput
  }

  /**
   * PosEventSaleMovementCountOutputType without action
   */
  export type PosEventSaleMovementCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleMovementChangeWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    saleProducts: number
    specifications: number
    PosEventSaleProduct: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleProducts?: boolean | ProductCountOutputTypeCountSaleProductsArgs
    specifications?: boolean | ProductCountOutputTypeCountSpecificationsArgs
    PosEventSaleProduct?: boolean | ProductCountOutputTypeCountPosEventSaleProductArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSaleProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSpecificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSpecificationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPosEventSaleProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleProductWhereInput
  }


  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    products: number
    movements: number
    PosEventSale: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SaleCountOutputTypeCountProductsArgs
    movements?: boolean | SaleCountOutputTypeCountMovementsArgs
    PosEventSale?: boolean | SaleCountOutputTypeCountPosEventSaleArgs
  }

  // Custom InputTypes
  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleMovementWhereInput
  }

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountPosEventSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleWhereInput
  }


  /**
   * Count Type SaleMovementCountOutputType
   */

  export type SaleMovementCountOutputType = {
    payments: number
    changes: number
  }

  export type SaleMovementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SaleMovementCountOutputTypeCountPaymentsArgs
    changes?: boolean | SaleMovementCountOutputTypeCountChangesArgs
  }

  // Custom InputTypes
  /**
   * SaleMovementCountOutputType without action
   */
  export type SaleMovementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementCountOutputType
     */
    select?: SaleMovementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleMovementCountOutputType without action
   */
  export type SaleMovementCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleMovementPaymentWhereInput
  }

  /**
   * SaleMovementCountOutputType without action
   */
  export type SaleMovementCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleMovementChangeWhereInput
  }


  /**
   * Count Type StockCountOutputType
   */

  export type StockCountOutputType = {
    lots: number
    StockEvent: number
  }

  export type StockCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lots?: boolean | StockCountOutputTypeCountLotsArgs
    StockEvent?: boolean | StockCountOutputTypeCountStockEventArgs
  }

  // Custom InputTypes
  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockCountOutputType
     */
    select?: StockCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLotWhereInput
  }

  /**
   * StockCountOutputType without action
   */
  export type StockCountOutputTypeCountStockEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockEventWhereInput
  }


  /**
   * Count Type StockLotCountOutputType
   */

  export type StockLotCountOutputType = {
    stockEvents: number
    saleProduct: number
  }

  export type StockLotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockEvents?: boolean | StockLotCountOutputTypeCountStockEventsArgs
    saleProduct?: boolean | StockLotCountOutputTypeCountSaleProductArgs
  }

  // Custom InputTypes
  /**
   * StockLotCountOutputType without action
   */
  export type StockLotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLotCountOutputType
     */
    select?: StockLotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockLotCountOutputType without action
   */
  export type StockLotCountOutputTypeCountStockEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockEventWhereInput
  }

  /**
   * StockLotCountOutputType without action
   */
  export type StockLotCountOutputTypeCountSaleProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
  }


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    memberships: number
    customers: number
    products: number
    sales: number
    stocks: number
    stockLots: number
    StockEvent: number
    NotificationTarget: number
    UserTenantSettings: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | TenantCountOutputTypeCountMembershipsArgs
    customers?: boolean | TenantCountOutputTypeCountCustomersArgs
    products?: boolean | TenantCountOutputTypeCountProductsArgs
    sales?: boolean | TenantCountOutputTypeCountSalesArgs
    stocks?: boolean | TenantCountOutputTypeCountStocksArgs
    stockLots?: boolean | TenantCountOutputTypeCountStockLotsArgs
    StockEvent?: boolean | TenantCountOutputTypeCountStockEventArgs
    NotificationTarget?: boolean | TenantCountOutputTypeCountNotificationTargetArgs
    UserTenantSettings?: boolean | TenantCountOutputTypeCountUserTenantSettingsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantMembershipWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStockLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLotWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStockEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockEventWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTargetWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUserTenantSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTenantSettingsWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tenantSettings: number
    NotificationTarget: number
    memberships: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenantSettings?: boolean | UserCountOutputTypeCountTenantSettingsArgs
    NotificationTarget?: boolean | UserCountOutputTypeCountNotificationTargetArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTenantSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTenantSettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTargetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    street: string | null
    houseNumber: string | null
    neighborhood: string | null
    zipCode: string | null
    city: string | null
    state: string | null
    complement: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    street: string | null
    houseNumber: string | null
    neighborhood: string | null
    zipCode: string | null
    city: string | null
    state: string | null
    complement: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    street: number
    houseNumber: number
    neighborhood: number
    zipCode: number
    city: number
    state: number
    complement: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    street?: true
    houseNumber?: true
    neighborhood?: true
    zipCode?: true
    city?: true
    state?: true
    complement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street?: true
    houseNumber?: true
    neighborhood?: true
    zipCode?: true
    city?: true
    state?: true
    complement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street?: true
    houseNumber?: true
    neighborhood?: true
    zipCode?: true
    city?: true
    state?: true
    complement?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    street: string
    houseNumber: string
    neighborhood: string
    zipCode: string
    city: string
    state: string
    complement: string
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    houseNumber?: boolean
    neighborhood?: boolean
    zipCode?: boolean
    city?: boolean
    state?: boolean
    complement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    houseNumber?: boolean
    neighborhood?: boolean
    zipCode?: boolean
    city?: boolean
    state?: boolean
    complement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    houseNumber?: boolean
    neighborhood?: boolean
    zipCode?: boolean
    city?: boolean
    state?: boolean
    complement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    street?: boolean
    houseNumber?: boolean
    neighborhood?: boolean
    zipCode?: boolean
    city?: boolean
    state?: boolean
    complement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "street" | "houseNumber" | "neighborhood" | "zipCode" | "city" | "state" | "complement" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      street: string
      houseNumber: string
      neighborhood: string
      zipCode: string
      city: string
      state: string
      complement: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly street: FieldRef<"Address", 'String'>
    readonly houseNumber: FieldRef<"Address", 'String'>
    readonly neighborhood: FieldRef<"Address", 'String'>
    readonly zipCode: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly complement: FieldRef<"Address", 'String'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    phoneNumber: string | null
    active: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phoneNumber: string | null
    active: boolean | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phoneNumber: number
    active: number
    tenantId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    active?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    active?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    active?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    phoneNumber: string | null
    active: boolean | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    active?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    posEventSales?: boolean | Customer$posEventSalesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    active?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    active?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    active?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phoneNumber" | "active" | "tenantId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    sales?: boolean | Customer$salesArgs<ExtArgs>
    posEventSales?: boolean | Customer$posEventSalesArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      sales: Prisma.$SalePayload<ExtArgs>[]
      posEventSales: Prisma.$PosEventSalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phoneNumber: string | null
      active: boolean | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sales<T extends Customer$salesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posEventSales<T extends Customer$posEventSalesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$posEventSalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phoneNumber: FieldRef<"Customer", 'String'>
    readonly active: FieldRef<"Customer", 'Boolean'>
    readonly tenantId: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly deletedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.sales
   */
  export type Customer$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Customer.posEventSales
   */
  export type Customer$posEventSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    where?: PosEventSaleWhereInput
    orderBy?: PosEventSaleOrderByWithRelationInput | PosEventSaleOrderByWithRelationInput[]
    cursor?: PosEventSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosEventSaleScalarFieldEnum | PosEventSaleScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    number: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    type: number
    number: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    type?: true
    number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    type?: true
    number?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    type?: true
    number?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    type: $Enums.DocumentType
    number: string
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    type?: boolean
    number?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "number" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.DocumentType
      number: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly number: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
  }


  /**
   * Model Membership
   */

  export type AggregateMembership = {
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  export type MembershipMinAggregateOutputType = {
    id: string | null
    role: $Enums.EMembershipRole | null
    active: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipMaxAggregateOutputType = {
    id: string | null
    role: $Enums.EMembershipRole | null
    active: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MembershipCountAggregateOutputType = {
    id: number
    role: number
    permissions: number
    active: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MembershipMinAggregateInputType = {
    id?: true
    role?: true
    active?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipMaxAggregateInputType = {
    id?: true
    role?: true
    active?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MembershipCountAggregateInputType = {
    id?: true
    role?: true
    permissions?: true
    active?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Membership to aggregate.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Memberships
    **/
    _count?: true | MembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipMaxAggregateInputType
  }

  export type GetMembershipAggregateType<T extends MembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembership[P]>
      : GetScalarType<T[P], AggregateMembership[P]>
  }




  export type MembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithAggregationInput | MembershipOrderByWithAggregationInput[]
    by: MembershipScalarFieldEnum[] | MembershipScalarFieldEnum
    having?: MembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipCountAggregateInputType | true
    _min?: MembershipMinAggregateInputType
    _max?: MembershipMaxAggregateInputType
  }

  export type MembershipGroupByOutputType = {
    id: string
    role: $Enums.EMembershipRole
    permissions: string[]
    active: boolean | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: MembershipCountAggregateOutputType | null
    _min: MembershipMinAggregateOutputType | null
    _max: MembershipMaxAggregateOutputType | null
  }

  type GetMembershipGroupByPayload<T extends MembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipGroupByOutputType[P]>
        }
      >
    >


  export type MembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissions?: boolean
    active?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant_memberships?: boolean | Membership$tenant_membershipsArgs<ExtArgs>
    _count?: boolean | MembershipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissions?: boolean
    active?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    permissions?: boolean
    active?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membership"]>

  export type MembershipSelectScalar = {
    id?: boolean
    role?: boolean
    permissions?: boolean
    active?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "permissions" | "active" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["membership"]>
  export type MembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant_memberships?: boolean | Membership$tenant_membershipsArgs<ExtArgs>
    _count?: boolean | MembershipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Membership"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenant_memberships: Prisma.$TenantMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.EMembershipRole
      permissions: string[]
      active: boolean | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["membership"]>
    composites: {}
  }

  type MembershipGetPayload<S extends boolean | null | undefined | MembershipDefaultArgs> = $Result.GetResult<Prisma.$MembershipPayload, S>

  type MembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipCountAggregateInputType | true
    }

  export interface MembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Membership'], meta: { name: 'Membership' } }
    /**
     * Find zero or one Membership that matches the filter.
     * @param {MembershipFindUniqueArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembershipFindUniqueArgs>(args: SelectSubset<T, MembershipFindUniqueArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Membership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MembershipFindUniqueOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, MembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembershipFindFirstArgs>(args?: SelectSubset<T, MembershipFindFirstArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Membership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindFirstOrThrowArgs} args - Arguments to find a Membership
     * @example
     * // Get one Membership
     * const membership = await prisma.membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, MembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memberships
     * const memberships = await prisma.membership.findMany()
     * 
     * // Get first 10 Memberships
     * const memberships = await prisma.membership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipWithIdOnly = await prisma.membership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembershipFindManyArgs>(args?: SelectSubset<T, MembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Membership.
     * @param {MembershipCreateArgs} args - Arguments to create a Membership.
     * @example
     * // Create one Membership
     * const Membership = await prisma.membership.create({
     *   data: {
     *     // ... data to create a Membership
     *   }
     * })
     * 
     */
    create<T extends MembershipCreateArgs>(args: SelectSubset<T, MembershipCreateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Memberships.
     * @param {MembershipCreateManyArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembershipCreateManyArgs>(args?: SelectSubset<T, MembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Memberships and returns the data saved in the database.
     * @param {MembershipCreateManyAndReturnArgs} args - Arguments to create many Memberships.
     * @example
     * // Create many Memberships
     * const membership = await prisma.membership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, MembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Membership.
     * @param {MembershipDeleteArgs} args - Arguments to delete one Membership.
     * @example
     * // Delete one Membership
     * const Membership = await prisma.membership.delete({
     *   where: {
     *     // ... filter to delete one Membership
     *   }
     * })
     * 
     */
    delete<T extends MembershipDeleteArgs>(args: SelectSubset<T, MembershipDeleteArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Membership.
     * @param {MembershipUpdateArgs} args - Arguments to update one Membership.
     * @example
     * // Update one Membership
     * const membership = await prisma.membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembershipUpdateArgs>(args: SelectSubset<T, MembershipUpdateArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Memberships.
     * @param {MembershipDeleteManyArgs} args - Arguments to filter Memberships to delete.
     * @example
     * // Delete a few Memberships
     * const { count } = await prisma.membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembershipDeleteManyArgs>(args?: SelectSubset<T, MembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembershipUpdateManyArgs>(args: SelectSubset<T, MembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memberships and returns the data updated in the database.
     * @param {MembershipUpdateManyAndReturnArgs} args - Arguments to update many Memberships.
     * @example
     * // Update many Memberships
     * const membership = await prisma.membership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Memberships and only return the `id`
     * const membershipWithIdOnly = await prisma.membership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, MembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Membership.
     * @param {MembershipUpsertArgs} args - Arguments to update or create a Membership.
     * @example
     * // Update or create a Membership
     * const membership = await prisma.membership.upsert({
     *   create: {
     *     // ... data to create a Membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Membership we want to update
     *   }
     * })
     */
    upsert<T extends MembershipUpsertArgs>(args: SelectSubset<T, MembershipUpsertArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipCountArgs} args - Arguments to filter Memberships to count.
     * @example
     * // Count the number of Memberships
     * const count = await prisma.membership.count({
     *   where: {
     *     // ... the filter for the Memberships we want to count
     *   }
     * })
    **/
    count<T extends MembershipCountArgs>(
      args?: Subset<T, MembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipAggregateArgs>(args: Subset<T, MembershipAggregateArgs>): Prisma.PrismaPromise<GetMembershipAggregateType<T>>

    /**
     * Group by Membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembershipGroupByArgs['orderBy'] }
        : { orderBy?: MembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Membership model
   */
  readonly fields: MembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant_memberships<T extends Membership$tenant_membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Membership$tenant_membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Membership model
   */
  interface MembershipFieldRefs {
    readonly id: FieldRef<"Membership", 'String'>
    readonly role: FieldRef<"Membership", 'EMembershipRole'>
    readonly permissions: FieldRef<"Membership", 'String[]'>
    readonly active: FieldRef<"Membership", 'Boolean'>
    readonly userId: FieldRef<"Membership", 'String'>
    readonly createdAt: FieldRef<"Membership", 'DateTime'>
    readonly updatedAt: FieldRef<"Membership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Membership findUnique
   */
  export type MembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findUniqueOrThrow
   */
  export type MembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership findFirst
   */
  export type MembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findFirstOrThrow
   */
  export type MembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Membership to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Memberships.
     */
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership findMany
   */
  export type MembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter, which Memberships to fetch.
     */
    where?: MembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Memberships to fetch.
     */
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Memberships.
     */
    cursor?: MembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Memberships.
     */
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * Membership create
   */
  export type MembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a Membership.
     */
    data: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
  }

  /**
   * Membership createMany
   */
  export type MembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Membership createManyAndReturn
   */
  export type MembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to create many Memberships.
     */
    data: MembershipCreateManyInput | MembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership update
   */
  export type MembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a Membership.
     */
    data: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
    /**
     * Choose, which Membership to update.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership updateMany
   */
  export type MembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
  }

  /**
   * Membership updateManyAndReturn
   */
  export type MembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * The data used to update Memberships.
     */
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyInput>
    /**
     * Filter which Memberships to update
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Membership upsert
   */
  export type MembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the Membership to update in case it exists.
     */
    where: MembershipWhereUniqueInput
    /**
     * In case the Membership found by the `where` argument doesn't exist, create a new Membership with this data.
     */
    create: XOR<MembershipCreateInput, MembershipUncheckedCreateInput>
    /**
     * In case the Membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembershipUpdateInput, MembershipUncheckedUpdateInput>
  }

  /**
   * Membership delete
   */
  export type MembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    /**
     * Filter which Membership to delete.
     */
    where: MembershipWhereUniqueInput
  }

  /**
   * Membership deleteMany
   */
  export type MembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Memberships to delete
     */
    where?: MembershipWhereInput
    /**
     * Limit how many Memberships to delete.
     */
    limit?: number
  }

  /**
   * Membership.tenant_memberships
   */
  export type Membership$tenant_membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    where?: TenantMembershipWhereInput
    orderBy?: TenantMembershipOrderByWithRelationInput | TenantMembershipOrderByWithRelationInput[]
    cursor?: TenantMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantMembershipScalarFieldEnum | TenantMembershipScalarFieldEnum[]
  }

  /**
   * Membership without action
   */
  export type MembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.ENotificationType | null
    subject: string | null
    body: string | null
    href: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ENotificationType | null
    subject: string | null
    body: string | null
    href: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    subject: number
    body: number
    href: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    subject?: true
    body?: true
    href?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    subject?: true
    body?: true
    href?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    subject?: true
    body?: true
    href?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.ENotificationType
    subject: string
    body: string
    href: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    href?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    targets?: boolean | Notification$targetsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    href?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    href?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    href?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "subject" | "body" | "href" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targets?: boolean | Notification$targetsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      targets: Prisma.$NotificationTargetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ENotificationType
      subject: string
      body: string
      href: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    targets<T extends Notification$targetsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$targetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'ENotificationType'>
    readonly subject: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly href: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
    readonly deletedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.targets
   */
  export type Notification$targetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    where?: NotificationTargetWhereInput
    orderBy?: NotificationTargetOrderByWithRelationInput | NotificationTargetOrderByWithRelationInput[]
    cursor?: NotificationTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationTargetScalarFieldEnum | NotificationTargetScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationTarget
   */

  export type AggregateNotificationTarget = {
    _count: NotificationTargetCountAggregateOutputType | null
    _min: NotificationTargetMinAggregateOutputType | null
    _max: NotificationTargetMaxAggregateOutputType | null
  }

  export type NotificationTargetMinAggregateOutputType = {
    id: string | null
    status: $Enums.ENotificationTargetStatus | null
    notificationId: string | null
    userId: string | null
    tenantId: string | null
  }

  export type NotificationTargetMaxAggregateOutputType = {
    id: string | null
    status: $Enums.ENotificationTargetStatus | null
    notificationId: string | null
    userId: string | null
    tenantId: string | null
  }

  export type NotificationTargetCountAggregateOutputType = {
    id: number
    status: number
    notificationId: number
    userId: number
    tenantId: number
    _all: number
  }


  export type NotificationTargetMinAggregateInputType = {
    id?: true
    status?: true
    notificationId?: true
    userId?: true
    tenantId?: true
  }

  export type NotificationTargetMaxAggregateInputType = {
    id?: true
    status?: true
    notificationId?: true
    userId?: true
    tenantId?: true
  }

  export type NotificationTargetCountAggregateInputType = {
    id?: true
    status?: true
    notificationId?: true
    userId?: true
    tenantId?: true
    _all?: true
  }

  export type NotificationTargetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTarget to aggregate.
     */
    where?: NotificationTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTargets to fetch.
     */
    orderBy?: NotificationTargetOrderByWithRelationInput | NotificationTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationTargets
    **/
    _count?: true | NotificationTargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationTargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationTargetMaxAggregateInputType
  }

  export type GetNotificationTargetAggregateType<T extends NotificationTargetAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationTarget[P]>
      : GetScalarType<T[P], AggregateNotificationTarget[P]>
  }




  export type NotificationTargetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTargetWhereInput
    orderBy?: NotificationTargetOrderByWithAggregationInput | NotificationTargetOrderByWithAggregationInput[]
    by: NotificationTargetScalarFieldEnum[] | NotificationTargetScalarFieldEnum
    having?: NotificationTargetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationTargetCountAggregateInputType | true
    _min?: NotificationTargetMinAggregateInputType
    _max?: NotificationTargetMaxAggregateInputType
  }

  export type NotificationTargetGroupByOutputType = {
    id: string
    status: $Enums.ENotificationTargetStatus
    notificationId: string
    userId: string
    tenantId: string
    _count: NotificationTargetCountAggregateOutputType | null
    _min: NotificationTargetMinAggregateOutputType | null
    _max: NotificationTargetMaxAggregateOutputType | null
  }

  type GetNotificationTargetGroupByPayload<T extends NotificationTargetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationTargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationTargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationTargetGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationTargetGroupByOutputType[P]>
        }
      >
    >


  export type NotificationTargetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    notificationId?: boolean
    userId?: boolean
    tenantId?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationTarget"]>

  export type NotificationTargetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    notificationId?: boolean
    userId?: boolean
    tenantId?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationTarget"]>

  export type NotificationTargetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    notificationId?: boolean
    userId?: boolean
    tenantId?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationTarget"]>

  export type NotificationTargetSelectScalar = {
    id?: boolean
    status?: boolean
    notificationId?: boolean
    userId?: boolean
    tenantId?: boolean
  }

  export type NotificationTargetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "notificationId" | "userId" | "tenantId", ExtArgs["result"]["notificationTarget"]>
  export type NotificationTargetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type NotificationTargetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type NotificationTargetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $NotificationTargetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationTarget"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.ENotificationTargetStatus
      notificationId: string
      userId: string
      tenantId: string
    }, ExtArgs["result"]["notificationTarget"]>
    composites: {}
  }

  type NotificationTargetGetPayload<S extends boolean | null | undefined | NotificationTargetDefaultArgs> = $Result.GetResult<Prisma.$NotificationTargetPayload, S>

  type NotificationTargetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationTargetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationTargetCountAggregateInputType | true
    }

  export interface NotificationTargetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationTarget'], meta: { name: 'NotificationTarget' } }
    /**
     * Find zero or one NotificationTarget that matches the filter.
     * @param {NotificationTargetFindUniqueArgs} args - Arguments to find a NotificationTarget
     * @example
     * // Get one NotificationTarget
     * const notificationTarget = await prisma.notificationTarget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationTargetFindUniqueArgs>(args: SelectSubset<T, NotificationTargetFindUniqueArgs<ExtArgs>>): Prisma__NotificationTargetClient<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationTarget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationTargetFindUniqueOrThrowArgs} args - Arguments to find a NotificationTarget
     * @example
     * // Get one NotificationTarget
     * const notificationTarget = await prisma.notificationTarget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationTargetFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationTargetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationTargetClient<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTarget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTargetFindFirstArgs} args - Arguments to find a NotificationTarget
     * @example
     * // Get one NotificationTarget
     * const notificationTarget = await prisma.notificationTarget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationTargetFindFirstArgs>(args?: SelectSubset<T, NotificationTargetFindFirstArgs<ExtArgs>>): Prisma__NotificationTargetClient<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTarget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTargetFindFirstOrThrowArgs} args - Arguments to find a NotificationTarget
     * @example
     * // Get one NotificationTarget
     * const notificationTarget = await prisma.notificationTarget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationTargetFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationTargetFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationTargetClient<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationTargets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTargetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationTargets
     * const notificationTargets = await prisma.notificationTarget.findMany()
     * 
     * // Get first 10 NotificationTargets
     * const notificationTargets = await prisma.notificationTarget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationTargetWithIdOnly = await prisma.notificationTarget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationTargetFindManyArgs>(args?: SelectSubset<T, NotificationTargetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationTarget.
     * @param {NotificationTargetCreateArgs} args - Arguments to create a NotificationTarget.
     * @example
     * // Create one NotificationTarget
     * const NotificationTarget = await prisma.notificationTarget.create({
     *   data: {
     *     // ... data to create a NotificationTarget
     *   }
     * })
     * 
     */
    create<T extends NotificationTargetCreateArgs>(args: SelectSubset<T, NotificationTargetCreateArgs<ExtArgs>>): Prisma__NotificationTargetClient<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationTargets.
     * @param {NotificationTargetCreateManyArgs} args - Arguments to create many NotificationTargets.
     * @example
     * // Create many NotificationTargets
     * const notificationTarget = await prisma.notificationTarget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationTargetCreateManyArgs>(args?: SelectSubset<T, NotificationTargetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationTargets and returns the data saved in the database.
     * @param {NotificationTargetCreateManyAndReturnArgs} args - Arguments to create many NotificationTargets.
     * @example
     * // Create many NotificationTargets
     * const notificationTarget = await prisma.notificationTarget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationTargets and only return the `id`
     * const notificationTargetWithIdOnly = await prisma.notificationTarget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationTargetCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationTargetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationTarget.
     * @param {NotificationTargetDeleteArgs} args - Arguments to delete one NotificationTarget.
     * @example
     * // Delete one NotificationTarget
     * const NotificationTarget = await prisma.notificationTarget.delete({
     *   where: {
     *     // ... filter to delete one NotificationTarget
     *   }
     * })
     * 
     */
    delete<T extends NotificationTargetDeleteArgs>(args: SelectSubset<T, NotificationTargetDeleteArgs<ExtArgs>>): Prisma__NotificationTargetClient<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationTarget.
     * @param {NotificationTargetUpdateArgs} args - Arguments to update one NotificationTarget.
     * @example
     * // Update one NotificationTarget
     * const notificationTarget = await prisma.notificationTarget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationTargetUpdateArgs>(args: SelectSubset<T, NotificationTargetUpdateArgs<ExtArgs>>): Prisma__NotificationTargetClient<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationTargets.
     * @param {NotificationTargetDeleteManyArgs} args - Arguments to filter NotificationTargets to delete.
     * @example
     * // Delete a few NotificationTargets
     * const { count } = await prisma.notificationTarget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationTargetDeleteManyArgs>(args?: SelectSubset<T, NotificationTargetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTargetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationTargets
     * const notificationTarget = await prisma.notificationTarget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationTargetUpdateManyArgs>(args: SelectSubset<T, NotificationTargetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTargets and returns the data updated in the database.
     * @param {NotificationTargetUpdateManyAndReturnArgs} args - Arguments to update many NotificationTargets.
     * @example
     * // Update many NotificationTargets
     * const notificationTarget = await prisma.notificationTarget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationTargets and only return the `id`
     * const notificationTargetWithIdOnly = await prisma.notificationTarget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationTargetUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationTargetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationTarget.
     * @param {NotificationTargetUpsertArgs} args - Arguments to update or create a NotificationTarget.
     * @example
     * // Update or create a NotificationTarget
     * const notificationTarget = await prisma.notificationTarget.upsert({
     *   create: {
     *     // ... data to create a NotificationTarget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationTarget we want to update
     *   }
     * })
     */
    upsert<T extends NotificationTargetUpsertArgs>(args: SelectSubset<T, NotificationTargetUpsertArgs<ExtArgs>>): Prisma__NotificationTargetClient<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTargetCountArgs} args - Arguments to filter NotificationTargets to count.
     * @example
     * // Count the number of NotificationTargets
     * const count = await prisma.notificationTarget.count({
     *   where: {
     *     // ... the filter for the NotificationTargets we want to count
     *   }
     * })
    **/
    count<T extends NotificationTargetCountArgs>(
      args?: Subset<T, NotificationTargetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationTargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationTargetAggregateArgs>(args: Subset<T, NotificationTargetAggregateArgs>): Prisma.PrismaPromise<GetNotificationTargetAggregateType<T>>

    /**
     * Group by NotificationTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTargetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationTargetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationTargetGroupByArgs['orderBy'] }
        : { orderBy?: NotificationTargetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationTargetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationTargetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationTarget model
   */
  readonly fields: NotificationTargetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationTarget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationTargetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationTarget model
   */
  interface NotificationTargetFieldRefs {
    readonly id: FieldRef<"NotificationTarget", 'String'>
    readonly status: FieldRef<"NotificationTarget", 'ENotificationTargetStatus'>
    readonly notificationId: FieldRef<"NotificationTarget", 'String'>
    readonly userId: FieldRef<"NotificationTarget", 'String'>
    readonly tenantId: FieldRef<"NotificationTarget", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationTarget findUnique
   */
  export type NotificationTargetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTarget to fetch.
     */
    where: NotificationTargetWhereUniqueInput
  }

  /**
   * NotificationTarget findUniqueOrThrow
   */
  export type NotificationTargetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTarget to fetch.
     */
    where: NotificationTargetWhereUniqueInput
  }

  /**
   * NotificationTarget findFirst
   */
  export type NotificationTargetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTarget to fetch.
     */
    where?: NotificationTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTargets to fetch.
     */
    orderBy?: NotificationTargetOrderByWithRelationInput | NotificationTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTargets.
     */
    cursor?: NotificationTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTargets.
     */
    distinct?: NotificationTargetScalarFieldEnum | NotificationTargetScalarFieldEnum[]
  }

  /**
   * NotificationTarget findFirstOrThrow
   */
  export type NotificationTargetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTarget to fetch.
     */
    where?: NotificationTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTargets to fetch.
     */
    orderBy?: NotificationTargetOrderByWithRelationInput | NotificationTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTargets.
     */
    cursor?: NotificationTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTargets.
     */
    distinct?: NotificationTargetScalarFieldEnum | NotificationTargetScalarFieldEnum[]
  }

  /**
   * NotificationTarget findMany
   */
  export type NotificationTargetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTargets to fetch.
     */
    where?: NotificationTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTargets to fetch.
     */
    orderBy?: NotificationTargetOrderByWithRelationInput | NotificationTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationTargets.
     */
    cursor?: NotificationTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTargets.
     */
    skip?: number
    distinct?: NotificationTargetScalarFieldEnum | NotificationTargetScalarFieldEnum[]
  }

  /**
   * NotificationTarget create
   */
  export type NotificationTargetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationTarget.
     */
    data: XOR<NotificationTargetCreateInput, NotificationTargetUncheckedCreateInput>
  }

  /**
   * NotificationTarget createMany
   */
  export type NotificationTargetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationTargets.
     */
    data: NotificationTargetCreateManyInput | NotificationTargetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTarget createManyAndReturn
   */
  export type NotificationTargetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationTargets.
     */
    data: NotificationTargetCreateManyInput | NotificationTargetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationTarget update
   */
  export type NotificationTargetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationTarget.
     */
    data: XOR<NotificationTargetUpdateInput, NotificationTargetUncheckedUpdateInput>
    /**
     * Choose, which NotificationTarget to update.
     */
    where: NotificationTargetWhereUniqueInput
  }

  /**
   * NotificationTarget updateMany
   */
  export type NotificationTargetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationTargets.
     */
    data: XOR<NotificationTargetUpdateManyMutationInput, NotificationTargetUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTargets to update
     */
    where?: NotificationTargetWhereInput
    /**
     * Limit how many NotificationTargets to update.
     */
    limit?: number
  }

  /**
   * NotificationTarget updateManyAndReturn
   */
  export type NotificationTargetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * The data used to update NotificationTargets.
     */
    data: XOR<NotificationTargetUpdateManyMutationInput, NotificationTargetUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTargets to update
     */
    where?: NotificationTargetWhereInput
    /**
     * Limit how many NotificationTargets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationTarget upsert
   */
  export type NotificationTargetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationTarget to update in case it exists.
     */
    where: NotificationTargetWhereUniqueInput
    /**
     * In case the NotificationTarget found by the `where` argument doesn't exist, create a new NotificationTarget with this data.
     */
    create: XOR<NotificationTargetCreateInput, NotificationTargetUncheckedCreateInput>
    /**
     * In case the NotificationTarget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationTargetUpdateInput, NotificationTargetUncheckedUpdateInput>
  }

  /**
   * NotificationTarget delete
   */
  export type NotificationTargetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    /**
     * Filter which NotificationTarget to delete.
     */
    where: NotificationTargetWhereUniqueInput
  }

  /**
   * NotificationTarget deleteMany
   */
  export type NotificationTargetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTargets to delete
     */
    where?: NotificationTargetWhereInput
    /**
     * Limit how many NotificationTargets to delete.
     */
    limit?: number
  }

  /**
   * NotificationTarget without action
   */
  export type NotificationTargetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
  }


  /**
   * Model Pos
   */

  export type AggregatePos = {
    _count: PosCountAggregateOutputType | null
    _min: PosMinAggregateOutputType | null
    _max: PosMaxAggregateOutputType | null
  }

  export type PosMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.EPosStatus | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PosMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: $Enums.EPosStatus | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PosCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    tenantId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PosMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PosMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PosCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pos to aggregate.
     */
    where?: PosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pos to fetch.
     */
    orderBy?: PosOrderByWithRelationInput | PosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pos
    **/
    _count?: true | PosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosMaxAggregateInputType
  }

  export type GetPosAggregateType<T extends PosAggregateArgs> = {
        [P in keyof T & keyof AggregatePos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePos[P]>
      : GetScalarType<T[P], AggregatePos[P]>
  }




  export type PosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosWhereInput
    orderBy?: PosOrderByWithAggregationInput | PosOrderByWithAggregationInput[]
    by: PosScalarFieldEnum[] | PosScalarFieldEnum
    having?: PosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosCountAggregateInputType | true
    _min?: PosMinAggregateInputType
    _max?: PosMaxAggregateInputType
  }

  export type PosGroupByOutputType = {
    id: string
    name: string
    description: string
    status: $Enums.EPosStatus
    tenantId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PosCountAggregateOutputType | null
    _min: PosMinAggregateOutputType | null
    _max: PosMaxAggregateOutputType | null
  }

  type GetPosGroupByPayload<T extends PosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosGroupByOutputType[P]>
            : GetScalarType<T[P], PosGroupByOutputType[P]>
        }
      >
    >


  export type PosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["pos"]>

  export type PosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["pos"]>

  export type PosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["pos"]>

  export type PosSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "tenantId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["pos"]>

  export type $PosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      status: $Enums.EPosStatus
      tenantId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["pos"]>
    composites: {}
  }

  type PosGetPayload<S extends boolean | null | undefined | PosDefaultArgs> = $Result.GetResult<Prisma.$PosPayload, S>

  type PosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosCountAggregateInputType | true
    }

  export interface PosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pos'], meta: { name: 'Pos' } }
    /**
     * Find zero or one Pos that matches the filter.
     * @param {PosFindUniqueArgs} args - Arguments to find a Pos
     * @example
     * // Get one Pos
     * const pos = await prisma.pos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosFindUniqueArgs>(args: SelectSubset<T, PosFindUniqueArgs<ExtArgs>>): Prisma__PosClient<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosFindUniqueOrThrowArgs} args - Arguments to find a Pos
     * @example
     * // Get one Pos
     * const pos = await prisma.pos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosFindUniqueOrThrowArgs>(args: SelectSubset<T, PosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosClient<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosFindFirstArgs} args - Arguments to find a Pos
     * @example
     * // Get one Pos
     * const pos = await prisma.pos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosFindFirstArgs>(args?: SelectSubset<T, PosFindFirstArgs<ExtArgs>>): Prisma__PosClient<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosFindFirstOrThrowArgs} args - Arguments to find a Pos
     * @example
     * // Get one Pos
     * const pos = await prisma.pos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosFindFirstOrThrowArgs>(args?: SelectSubset<T, PosFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosClient<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pos
     * const pos = await prisma.pos.findMany()
     * 
     * // Get first 10 Pos
     * const pos = await prisma.pos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posWithIdOnly = await prisma.pos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosFindManyArgs>(args?: SelectSubset<T, PosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pos.
     * @param {PosCreateArgs} args - Arguments to create a Pos.
     * @example
     * // Create one Pos
     * const Pos = await prisma.pos.create({
     *   data: {
     *     // ... data to create a Pos
     *   }
     * })
     * 
     */
    create<T extends PosCreateArgs>(args: SelectSubset<T, PosCreateArgs<ExtArgs>>): Prisma__PosClient<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pos.
     * @param {PosCreateManyArgs} args - Arguments to create many Pos.
     * @example
     * // Create many Pos
     * const pos = await prisma.pos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosCreateManyArgs>(args?: SelectSubset<T, PosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pos and returns the data saved in the database.
     * @param {PosCreateManyAndReturnArgs} args - Arguments to create many Pos.
     * @example
     * // Create many Pos
     * const pos = await prisma.pos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pos and only return the `id`
     * const posWithIdOnly = await prisma.pos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosCreateManyAndReturnArgs>(args?: SelectSubset<T, PosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pos.
     * @param {PosDeleteArgs} args - Arguments to delete one Pos.
     * @example
     * // Delete one Pos
     * const Pos = await prisma.pos.delete({
     *   where: {
     *     // ... filter to delete one Pos
     *   }
     * })
     * 
     */
    delete<T extends PosDeleteArgs>(args: SelectSubset<T, PosDeleteArgs<ExtArgs>>): Prisma__PosClient<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pos.
     * @param {PosUpdateArgs} args - Arguments to update one Pos.
     * @example
     * // Update one Pos
     * const pos = await prisma.pos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosUpdateArgs>(args: SelectSubset<T, PosUpdateArgs<ExtArgs>>): Prisma__PosClient<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pos.
     * @param {PosDeleteManyArgs} args - Arguments to filter Pos to delete.
     * @example
     * // Delete a few Pos
     * const { count } = await prisma.pos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosDeleteManyArgs>(args?: SelectSubset<T, PosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pos
     * const pos = await prisma.pos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosUpdateManyArgs>(args: SelectSubset<T, PosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pos and returns the data updated in the database.
     * @param {PosUpdateManyAndReturnArgs} args - Arguments to update many Pos.
     * @example
     * // Update many Pos
     * const pos = await prisma.pos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pos and only return the `id`
     * const posWithIdOnly = await prisma.pos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosUpdateManyAndReturnArgs>(args: SelectSubset<T, PosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pos.
     * @param {PosUpsertArgs} args - Arguments to update or create a Pos.
     * @example
     * // Update or create a Pos
     * const pos = await prisma.pos.upsert({
     *   create: {
     *     // ... data to create a Pos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pos we want to update
     *   }
     * })
     */
    upsert<T extends PosUpsertArgs>(args: SelectSubset<T, PosUpsertArgs<ExtArgs>>): Prisma__PosClient<$Result.GetResult<Prisma.$PosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosCountArgs} args - Arguments to filter Pos to count.
     * @example
     * // Count the number of Pos
     * const count = await prisma.pos.count({
     *   where: {
     *     // ... the filter for the Pos we want to count
     *   }
     * })
    **/
    count<T extends PosCountArgs>(
      args?: Subset<T, PosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosAggregateArgs>(args: Subset<T, PosAggregateArgs>): Prisma.PrismaPromise<GetPosAggregateType<T>>

    /**
     * Group by Pos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosGroupByArgs['orderBy'] }
        : { orderBy?: PosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pos model
   */
  readonly fields: PosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pos model
   */
  interface PosFieldRefs {
    readonly id: FieldRef<"Pos", 'String'>
    readonly name: FieldRef<"Pos", 'String'>
    readonly description: FieldRef<"Pos", 'String'>
    readonly status: FieldRef<"Pos", 'EPosStatus'>
    readonly tenantId: FieldRef<"Pos", 'String'>
    readonly createdAt: FieldRef<"Pos", 'DateTime'>
    readonly updatedAt: FieldRef<"Pos", 'DateTime'>
    readonly deletedAt: FieldRef<"Pos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pos findUnique
   */
  export type PosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * Filter, which Pos to fetch.
     */
    where: PosWhereUniqueInput
  }

  /**
   * Pos findUniqueOrThrow
   */
  export type PosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * Filter, which Pos to fetch.
     */
    where: PosWhereUniqueInput
  }

  /**
   * Pos findFirst
   */
  export type PosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * Filter, which Pos to fetch.
     */
    where?: PosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pos to fetch.
     */
    orderBy?: PosOrderByWithRelationInput | PosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pos.
     */
    cursor?: PosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pos.
     */
    distinct?: PosScalarFieldEnum | PosScalarFieldEnum[]
  }

  /**
   * Pos findFirstOrThrow
   */
  export type PosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * Filter, which Pos to fetch.
     */
    where?: PosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pos to fetch.
     */
    orderBy?: PosOrderByWithRelationInput | PosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pos.
     */
    cursor?: PosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pos.
     */
    distinct?: PosScalarFieldEnum | PosScalarFieldEnum[]
  }

  /**
   * Pos findMany
   */
  export type PosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * Filter, which Pos to fetch.
     */
    where?: PosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pos to fetch.
     */
    orderBy?: PosOrderByWithRelationInput | PosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pos.
     */
    cursor?: PosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pos.
     */
    skip?: number
    distinct?: PosScalarFieldEnum | PosScalarFieldEnum[]
  }

  /**
   * Pos create
   */
  export type PosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * The data needed to create a Pos.
     */
    data: XOR<PosCreateInput, PosUncheckedCreateInput>
  }

  /**
   * Pos createMany
   */
  export type PosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pos.
     */
    data: PosCreateManyInput | PosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pos createManyAndReturn
   */
  export type PosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * The data used to create many Pos.
     */
    data: PosCreateManyInput | PosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pos update
   */
  export type PosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * The data needed to update a Pos.
     */
    data: XOR<PosUpdateInput, PosUncheckedUpdateInput>
    /**
     * Choose, which Pos to update.
     */
    where: PosWhereUniqueInput
  }

  /**
   * Pos updateMany
   */
  export type PosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pos.
     */
    data: XOR<PosUpdateManyMutationInput, PosUncheckedUpdateManyInput>
    /**
     * Filter which Pos to update
     */
    where?: PosWhereInput
    /**
     * Limit how many Pos to update.
     */
    limit?: number
  }

  /**
   * Pos updateManyAndReturn
   */
  export type PosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * The data used to update Pos.
     */
    data: XOR<PosUpdateManyMutationInput, PosUncheckedUpdateManyInput>
    /**
     * Filter which Pos to update
     */
    where?: PosWhereInput
    /**
     * Limit how many Pos to update.
     */
    limit?: number
  }

  /**
   * Pos upsert
   */
  export type PosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * The filter to search for the Pos to update in case it exists.
     */
    where: PosWhereUniqueInput
    /**
     * In case the Pos found by the `where` argument doesn't exist, create a new Pos with this data.
     */
    create: XOR<PosCreateInput, PosUncheckedCreateInput>
    /**
     * In case the Pos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosUpdateInput, PosUncheckedUpdateInput>
  }

  /**
   * Pos delete
   */
  export type PosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
    /**
     * Filter which Pos to delete.
     */
    where: PosWhereUniqueInput
  }

  /**
   * Pos deleteMany
   */
  export type PosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pos to delete
     */
    where?: PosWhereInput
    /**
     * Limit how many Pos to delete.
     */
    limit?: number
  }

  /**
   * Pos without action
   */
  export type PosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pos
     */
    select?: PosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pos
     */
    omit?: PosOmit<ExtArgs> | null
  }


  /**
   * Model PosEvent
   */

  export type AggregatePosEvent = {
    _count: PosEventCountAggregateOutputType | null
    _min: PosEventMinAggregateOutputType | null
    _max: PosEventMaxAggregateOutputType | null
  }

  export type PosEventMinAggregateOutputType = {
    id: string | null
    type: $Enums.EPosEventType | null
    status: $Enums.EPosEventStatus | null
    posId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PosEventMaxAggregateOutputType = {
    id: string | null
    type: $Enums.EPosEventType | null
    status: $Enums.EPosEventStatus | null
    posId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PosEventCountAggregateOutputType = {
    id: number
    type: number
    status: number
    posId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PosEventMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    posId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PosEventMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    posId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PosEventCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    posId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PosEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEvent to aggregate.
     */
    where?: PosEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEvents to fetch.
     */
    orderBy?: PosEventOrderByWithRelationInput | PosEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosEvents
    **/
    _count?: true | PosEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosEventMaxAggregateInputType
  }

  export type GetPosEventAggregateType<T extends PosEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePosEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosEvent[P]>
      : GetScalarType<T[P], AggregatePosEvent[P]>
  }




  export type PosEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventWhereInput
    orderBy?: PosEventOrderByWithAggregationInput | PosEventOrderByWithAggregationInput[]
    by: PosEventScalarFieldEnum[] | PosEventScalarFieldEnum
    having?: PosEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosEventCountAggregateInputType | true
    _min?: PosEventMinAggregateInputType
    _max?: PosEventMaxAggregateInputType
  }

  export type PosEventGroupByOutputType = {
    id: string
    type: $Enums.EPosEventType
    status: $Enums.EPosEventStatus
    posId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PosEventCountAggregateOutputType | null
    _min: PosEventMinAggregateOutputType | null
    _max: PosEventMaxAggregateOutputType | null
  }

  type GetPosEventGroupByPayload<T extends PosEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosEventGroupByOutputType[P]>
            : GetScalarType<T[P], PosEventGroupByOutputType[P]>
        }
      >
    >


  export type PosEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    posId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    entry?: boolean | PosEvent$entryArgs<ExtArgs>
    output?: boolean | PosEvent$outputArgs<ExtArgs>
    sale?: boolean | PosEvent$saleArgs<ExtArgs>
  }, ExtArgs["result"]["posEvent"]>

  export type PosEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    posId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["posEvent"]>

  export type PosEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    posId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["posEvent"]>

  export type PosEventSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    posId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PosEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "posId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["posEvent"]>
  export type PosEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | PosEvent$entryArgs<ExtArgs>
    output?: boolean | PosEvent$outputArgs<ExtArgs>
    sale?: boolean | PosEvent$saleArgs<ExtArgs>
  }
  export type PosEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PosEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PosEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosEvent"
    objects: {
      entry: Prisma.$PosEventEntryPayload<ExtArgs> | null
      output: Prisma.$PosEventOutputPayload<ExtArgs> | null
      sale: Prisma.$PosEventSalePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.EPosEventType
      status: $Enums.EPosEventStatus
      posId: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["posEvent"]>
    composites: {}
  }

  type PosEventGetPayload<S extends boolean | null | undefined | PosEventDefaultArgs> = $Result.GetResult<Prisma.$PosEventPayload, S>

  type PosEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosEventCountAggregateInputType | true
    }

  export interface PosEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosEvent'], meta: { name: 'PosEvent' } }
    /**
     * Find zero or one PosEvent that matches the filter.
     * @param {PosEventFindUniqueArgs} args - Arguments to find a PosEvent
     * @example
     * // Get one PosEvent
     * const posEvent = await prisma.posEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosEventFindUniqueArgs>(args: SelectSubset<T, PosEventFindUniqueArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosEventFindUniqueOrThrowArgs} args - Arguments to find a PosEvent
     * @example
     * // Get one PosEvent
     * const posEvent = await prisma.posEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosEventFindUniqueOrThrowArgs>(args: SelectSubset<T, PosEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventFindFirstArgs} args - Arguments to find a PosEvent
     * @example
     * // Get one PosEvent
     * const posEvent = await prisma.posEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosEventFindFirstArgs>(args?: SelectSubset<T, PosEventFindFirstArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventFindFirstOrThrowArgs} args - Arguments to find a PosEvent
     * @example
     * // Get one PosEvent
     * const posEvent = await prisma.posEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosEventFindFirstOrThrowArgs>(args?: SelectSubset<T, PosEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosEvents
     * const posEvents = await prisma.posEvent.findMany()
     * 
     * // Get first 10 PosEvents
     * const posEvents = await prisma.posEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posEventWithIdOnly = await prisma.posEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosEventFindManyArgs>(args?: SelectSubset<T, PosEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosEvent.
     * @param {PosEventCreateArgs} args - Arguments to create a PosEvent.
     * @example
     * // Create one PosEvent
     * const PosEvent = await prisma.posEvent.create({
     *   data: {
     *     // ... data to create a PosEvent
     *   }
     * })
     * 
     */
    create<T extends PosEventCreateArgs>(args: SelectSubset<T, PosEventCreateArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosEvents.
     * @param {PosEventCreateManyArgs} args - Arguments to create many PosEvents.
     * @example
     * // Create many PosEvents
     * const posEvent = await prisma.posEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosEventCreateManyArgs>(args?: SelectSubset<T, PosEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosEvents and returns the data saved in the database.
     * @param {PosEventCreateManyAndReturnArgs} args - Arguments to create many PosEvents.
     * @example
     * // Create many PosEvents
     * const posEvent = await prisma.posEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosEvents and only return the `id`
     * const posEventWithIdOnly = await prisma.posEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosEventCreateManyAndReturnArgs>(args?: SelectSubset<T, PosEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosEvent.
     * @param {PosEventDeleteArgs} args - Arguments to delete one PosEvent.
     * @example
     * // Delete one PosEvent
     * const PosEvent = await prisma.posEvent.delete({
     *   where: {
     *     // ... filter to delete one PosEvent
     *   }
     * })
     * 
     */
    delete<T extends PosEventDeleteArgs>(args: SelectSubset<T, PosEventDeleteArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosEvent.
     * @param {PosEventUpdateArgs} args - Arguments to update one PosEvent.
     * @example
     * // Update one PosEvent
     * const posEvent = await prisma.posEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosEventUpdateArgs>(args: SelectSubset<T, PosEventUpdateArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosEvents.
     * @param {PosEventDeleteManyArgs} args - Arguments to filter PosEvents to delete.
     * @example
     * // Delete a few PosEvents
     * const { count } = await prisma.posEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosEventDeleteManyArgs>(args?: SelectSubset<T, PosEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosEvents
     * const posEvent = await prisma.posEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosEventUpdateManyArgs>(args: SelectSubset<T, PosEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEvents and returns the data updated in the database.
     * @param {PosEventUpdateManyAndReturnArgs} args - Arguments to update many PosEvents.
     * @example
     * // Update many PosEvents
     * const posEvent = await prisma.posEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosEvents and only return the `id`
     * const posEventWithIdOnly = await prisma.posEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosEventUpdateManyAndReturnArgs>(args: SelectSubset<T, PosEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosEvent.
     * @param {PosEventUpsertArgs} args - Arguments to update or create a PosEvent.
     * @example
     * // Update or create a PosEvent
     * const posEvent = await prisma.posEvent.upsert({
     *   create: {
     *     // ... data to create a PosEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosEvent we want to update
     *   }
     * })
     */
    upsert<T extends PosEventUpsertArgs>(args: SelectSubset<T, PosEventUpsertArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventCountArgs} args - Arguments to filter PosEvents to count.
     * @example
     * // Count the number of PosEvents
     * const count = await prisma.posEvent.count({
     *   where: {
     *     // ... the filter for the PosEvents we want to count
     *   }
     * })
    **/
    count<T extends PosEventCountArgs>(
      args?: Subset<T, PosEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosEventAggregateArgs>(args: Subset<T, PosEventAggregateArgs>): Prisma.PrismaPromise<GetPosEventAggregateType<T>>

    /**
     * Group by PosEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosEventGroupByArgs['orderBy'] }
        : { orderBy?: PosEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosEvent model
   */
  readonly fields: PosEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entry<T extends PosEvent$entryArgs<ExtArgs> = {}>(args?: Subset<T, PosEvent$entryArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    output<T extends PosEvent$outputArgs<ExtArgs> = {}>(args?: Subset<T, PosEvent$outputArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sale<T extends PosEvent$saleArgs<ExtArgs> = {}>(args?: Subset<T, PosEvent$saleArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosEvent model
   */
  interface PosEventFieldRefs {
    readonly id: FieldRef<"PosEvent", 'String'>
    readonly type: FieldRef<"PosEvent", 'EPosEventType'>
    readonly status: FieldRef<"PosEvent", 'EPosEventStatus'>
    readonly posId: FieldRef<"PosEvent", 'String'>
    readonly createdAt: FieldRef<"PosEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"PosEvent", 'DateTime'>
    readonly deletedAt: FieldRef<"PosEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PosEvent findUnique
   */
  export type PosEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * Filter, which PosEvent to fetch.
     */
    where: PosEventWhereUniqueInput
  }

  /**
   * PosEvent findUniqueOrThrow
   */
  export type PosEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * Filter, which PosEvent to fetch.
     */
    where: PosEventWhereUniqueInput
  }

  /**
   * PosEvent findFirst
   */
  export type PosEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * Filter, which PosEvent to fetch.
     */
    where?: PosEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEvents to fetch.
     */
    orderBy?: PosEventOrderByWithRelationInput | PosEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEvents.
     */
    cursor?: PosEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEvents.
     */
    distinct?: PosEventScalarFieldEnum | PosEventScalarFieldEnum[]
  }

  /**
   * PosEvent findFirstOrThrow
   */
  export type PosEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * Filter, which PosEvent to fetch.
     */
    where?: PosEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEvents to fetch.
     */
    orderBy?: PosEventOrderByWithRelationInput | PosEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEvents.
     */
    cursor?: PosEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEvents.
     */
    distinct?: PosEventScalarFieldEnum | PosEventScalarFieldEnum[]
  }

  /**
   * PosEvent findMany
   */
  export type PosEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * Filter, which PosEvents to fetch.
     */
    where?: PosEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEvents to fetch.
     */
    orderBy?: PosEventOrderByWithRelationInput | PosEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosEvents.
     */
    cursor?: PosEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEvents.
     */
    skip?: number
    distinct?: PosEventScalarFieldEnum | PosEventScalarFieldEnum[]
  }

  /**
   * PosEvent create
   */
  export type PosEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * The data needed to create a PosEvent.
     */
    data: XOR<PosEventCreateInput, PosEventUncheckedCreateInput>
  }

  /**
   * PosEvent createMany
   */
  export type PosEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosEvents.
     */
    data: PosEventCreateManyInput | PosEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEvent createManyAndReturn
   */
  export type PosEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * The data used to create many PosEvents.
     */
    data: PosEventCreateManyInput | PosEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEvent update
   */
  export type PosEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * The data needed to update a PosEvent.
     */
    data: XOR<PosEventUpdateInput, PosEventUncheckedUpdateInput>
    /**
     * Choose, which PosEvent to update.
     */
    where: PosEventWhereUniqueInput
  }

  /**
   * PosEvent updateMany
   */
  export type PosEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosEvents.
     */
    data: XOR<PosEventUpdateManyMutationInput, PosEventUncheckedUpdateManyInput>
    /**
     * Filter which PosEvents to update
     */
    where?: PosEventWhereInput
    /**
     * Limit how many PosEvents to update.
     */
    limit?: number
  }

  /**
   * PosEvent updateManyAndReturn
   */
  export type PosEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * The data used to update PosEvents.
     */
    data: XOR<PosEventUpdateManyMutationInput, PosEventUncheckedUpdateManyInput>
    /**
     * Filter which PosEvents to update
     */
    where?: PosEventWhereInput
    /**
     * Limit how many PosEvents to update.
     */
    limit?: number
  }

  /**
   * PosEvent upsert
   */
  export type PosEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * The filter to search for the PosEvent to update in case it exists.
     */
    where: PosEventWhereUniqueInput
    /**
     * In case the PosEvent found by the `where` argument doesn't exist, create a new PosEvent with this data.
     */
    create: XOR<PosEventCreateInput, PosEventUncheckedCreateInput>
    /**
     * In case the PosEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosEventUpdateInput, PosEventUncheckedUpdateInput>
  }

  /**
   * PosEvent delete
   */
  export type PosEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
    /**
     * Filter which PosEvent to delete.
     */
    where: PosEventWhereUniqueInput
  }

  /**
   * PosEvent deleteMany
   */
  export type PosEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEvents to delete
     */
    where?: PosEventWhereInput
    /**
     * Limit how many PosEvents to delete.
     */
    limit?: number
  }

  /**
   * PosEvent.entry
   */
  export type PosEvent$entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    where?: PosEventEntryWhereInput
  }

  /**
   * PosEvent.output
   */
  export type PosEvent$outputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    where?: PosEventOutputWhereInput
  }

  /**
   * PosEvent.sale
   */
  export type PosEvent$saleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    where?: PosEventSaleWhereInput
  }

  /**
   * PosEvent without action
   */
  export type PosEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEvent
     */
    select?: PosEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEvent
     */
    omit?: PosEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventInclude<ExtArgs> | null
  }


  /**
   * Model PosEventEntry
   */

  export type AggregatePosEventEntry = {
    _count: PosEventEntryCountAggregateOutputType | null
    _avg: PosEventEntryAvgAggregateOutputType | null
    _sum: PosEventEntrySumAggregateOutputType | null
    _min: PosEventEntryMinAggregateOutputType | null
    _max: PosEventEntryMaxAggregateOutputType | null
  }

  export type PosEventEntryAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PosEventEntrySumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PosEventEntryMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    description: string | null
  }

  export type PosEventEntryMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    description: string | null
  }

  export type PosEventEntryCountAggregateOutputType = {
    id: number
    amount: number
    description: number
    _all: number
  }


  export type PosEventEntryAvgAggregateInputType = {
    amount?: true
  }

  export type PosEventEntrySumAggregateInputType = {
    amount?: true
  }

  export type PosEventEntryMinAggregateInputType = {
    id?: true
    amount?: true
    description?: true
  }

  export type PosEventEntryMaxAggregateInputType = {
    id?: true
    amount?: true
    description?: true
  }

  export type PosEventEntryCountAggregateInputType = {
    id?: true
    amount?: true
    description?: true
    _all?: true
  }

  export type PosEventEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventEntry to aggregate.
     */
    where?: PosEventEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventEntries to fetch.
     */
    orderBy?: PosEventEntryOrderByWithRelationInput | PosEventEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosEventEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosEventEntries
    **/
    _count?: true | PosEventEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PosEventEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PosEventEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosEventEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosEventEntryMaxAggregateInputType
  }

  export type GetPosEventEntryAggregateType<T extends PosEventEntryAggregateArgs> = {
        [P in keyof T & keyof AggregatePosEventEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosEventEntry[P]>
      : GetScalarType<T[P], AggregatePosEventEntry[P]>
  }




  export type PosEventEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventEntryWhereInput
    orderBy?: PosEventEntryOrderByWithAggregationInput | PosEventEntryOrderByWithAggregationInput[]
    by: PosEventEntryScalarFieldEnum[] | PosEventEntryScalarFieldEnum
    having?: PosEventEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosEventEntryCountAggregateInputType | true
    _avg?: PosEventEntryAvgAggregateInputType
    _sum?: PosEventEntrySumAggregateInputType
    _min?: PosEventEntryMinAggregateInputType
    _max?: PosEventEntryMaxAggregateInputType
  }

  export type PosEventEntryGroupByOutputType = {
    id: string
    amount: Decimal
    description: string
    _count: PosEventEntryCountAggregateOutputType | null
    _avg: PosEventEntryAvgAggregateOutputType | null
    _sum: PosEventEntrySumAggregateOutputType | null
    _min: PosEventEntryMinAggregateOutputType | null
    _max: PosEventEntryMaxAggregateOutputType | null
  }

  type GetPosEventEntryGroupByPayload<T extends PosEventEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosEventEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosEventEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosEventEntryGroupByOutputType[P]>
            : GetScalarType<T[P], PosEventEntryGroupByOutputType[P]>
        }
      >
    >


  export type PosEventEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    description?: boolean
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventEntry"]>

  export type PosEventEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    description?: boolean
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventEntry"]>

  export type PosEventEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    description?: boolean
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventEntry"]>

  export type PosEventEntrySelectScalar = {
    id?: boolean
    amount?: boolean
    description?: boolean
  }

  export type PosEventEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "description", ExtArgs["result"]["posEventEntry"]>
  export type PosEventEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }
  export type PosEventEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }
  export type PosEventEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }

  export type $PosEventEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosEventEntry"
    objects: {
      posEvent: Prisma.$PosEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: Prisma.Decimal
      description: string
    }, ExtArgs["result"]["posEventEntry"]>
    composites: {}
  }

  type PosEventEntryGetPayload<S extends boolean | null | undefined | PosEventEntryDefaultArgs> = $Result.GetResult<Prisma.$PosEventEntryPayload, S>

  type PosEventEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosEventEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosEventEntryCountAggregateInputType | true
    }

  export interface PosEventEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosEventEntry'], meta: { name: 'PosEventEntry' } }
    /**
     * Find zero or one PosEventEntry that matches the filter.
     * @param {PosEventEntryFindUniqueArgs} args - Arguments to find a PosEventEntry
     * @example
     * // Get one PosEventEntry
     * const posEventEntry = await prisma.posEventEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosEventEntryFindUniqueArgs>(args: SelectSubset<T, PosEventEntryFindUniqueArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosEventEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosEventEntryFindUniqueOrThrowArgs} args - Arguments to find a PosEventEntry
     * @example
     * // Get one PosEventEntry
     * const posEventEntry = await prisma.posEventEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosEventEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, PosEventEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventEntryFindFirstArgs} args - Arguments to find a PosEventEntry
     * @example
     * // Get one PosEventEntry
     * const posEventEntry = await prisma.posEventEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosEventEntryFindFirstArgs>(args?: SelectSubset<T, PosEventEntryFindFirstArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventEntryFindFirstOrThrowArgs} args - Arguments to find a PosEventEntry
     * @example
     * // Get one PosEventEntry
     * const posEventEntry = await prisma.posEventEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosEventEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, PosEventEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosEventEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosEventEntries
     * const posEventEntries = await prisma.posEventEntry.findMany()
     * 
     * // Get first 10 PosEventEntries
     * const posEventEntries = await prisma.posEventEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posEventEntryWithIdOnly = await prisma.posEventEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosEventEntryFindManyArgs>(args?: SelectSubset<T, PosEventEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosEventEntry.
     * @param {PosEventEntryCreateArgs} args - Arguments to create a PosEventEntry.
     * @example
     * // Create one PosEventEntry
     * const PosEventEntry = await prisma.posEventEntry.create({
     *   data: {
     *     // ... data to create a PosEventEntry
     *   }
     * })
     * 
     */
    create<T extends PosEventEntryCreateArgs>(args: SelectSubset<T, PosEventEntryCreateArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosEventEntries.
     * @param {PosEventEntryCreateManyArgs} args - Arguments to create many PosEventEntries.
     * @example
     * // Create many PosEventEntries
     * const posEventEntry = await prisma.posEventEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosEventEntryCreateManyArgs>(args?: SelectSubset<T, PosEventEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosEventEntries and returns the data saved in the database.
     * @param {PosEventEntryCreateManyAndReturnArgs} args - Arguments to create many PosEventEntries.
     * @example
     * // Create many PosEventEntries
     * const posEventEntry = await prisma.posEventEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosEventEntries and only return the `id`
     * const posEventEntryWithIdOnly = await prisma.posEventEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosEventEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, PosEventEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosEventEntry.
     * @param {PosEventEntryDeleteArgs} args - Arguments to delete one PosEventEntry.
     * @example
     * // Delete one PosEventEntry
     * const PosEventEntry = await prisma.posEventEntry.delete({
     *   where: {
     *     // ... filter to delete one PosEventEntry
     *   }
     * })
     * 
     */
    delete<T extends PosEventEntryDeleteArgs>(args: SelectSubset<T, PosEventEntryDeleteArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosEventEntry.
     * @param {PosEventEntryUpdateArgs} args - Arguments to update one PosEventEntry.
     * @example
     * // Update one PosEventEntry
     * const posEventEntry = await prisma.posEventEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosEventEntryUpdateArgs>(args: SelectSubset<T, PosEventEntryUpdateArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosEventEntries.
     * @param {PosEventEntryDeleteManyArgs} args - Arguments to filter PosEventEntries to delete.
     * @example
     * // Delete a few PosEventEntries
     * const { count } = await prisma.posEventEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosEventEntryDeleteManyArgs>(args?: SelectSubset<T, PosEventEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosEventEntries
     * const posEventEntry = await prisma.posEventEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosEventEntryUpdateManyArgs>(args: SelectSubset<T, PosEventEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventEntries and returns the data updated in the database.
     * @param {PosEventEntryUpdateManyAndReturnArgs} args - Arguments to update many PosEventEntries.
     * @example
     * // Update many PosEventEntries
     * const posEventEntry = await prisma.posEventEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosEventEntries and only return the `id`
     * const posEventEntryWithIdOnly = await prisma.posEventEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosEventEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, PosEventEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosEventEntry.
     * @param {PosEventEntryUpsertArgs} args - Arguments to update or create a PosEventEntry.
     * @example
     * // Update or create a PosEventEntry
     * const posEventEntry = await prisma.posEventEntry.upsert({
     *   create: {
     *     // ... data to create a PosEventEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosEventEntry we want to update
     *   }
     * })
     */
    upsert<T extends PosEventEntryUpsertArgs>(args: SelectSubset<T, PosEventEntryUpsertArgs<ExtArgs>>): Prisma__PosEventEntryClient<$Result.GetResult<Prisma.$PosEventEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosEventEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventEntryCountArgs} args - Arguments to filter PosEventEntries to count.
     * @example
     * // Count the number of PosEventEntries
     * const count = await prisma.posEventEntry.count({
     *   where: {
     *     // ... the filter for the PosEventEntries we want to count
     *   }
     * })
    **/
    count<T extends PosEventEntryCountArgs>(
      args?: Subset<T, PosEventEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosEventEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosEventEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosEventEntryAggregateArgs>(args: Subset<T, PosEventEntryAggregateArgs>): Prisma.PrismaPromise<GetPosEventEntryAggregateType<T>>

    /**
     * Group by PosEventEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosEventEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosEventEntryGroupByArgs['orderBy'] }
        : { orderBy?: PosEventEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosEventEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosEventEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosEventEntry model
   */
  readonly fields: PosEventEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosEventEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosEventEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posEvent<T extends PosEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PosEventDefaultArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosEventEntry model
   */
  interface PosEventEntryFieldRefs {
    readonly id: FieldRef<"PosEventEntry", 'String'>
    readonly amount: FieldRef<"PosEventEntry", 'Decimal'>
    readonly description: FieldRef<"PosEventEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PosEventEntry findUnique
   */
  export type PosEventEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which PosEventEntry to fetch.
     */
    where: PosEventEntryWhereUniqueInput
  }

  /**
   * PosEventEntry findUniqueOrThrow
   */
  export type PosEventEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which PosEventEntry to fetch.
     */
    where: PosEventEntryWhereUniqueInput
  }

  /**
   * PosEventEntry findFirst
   */
  export type PosEventEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which PosEventEntry to fetch.
     */
    where?: PosEventEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventEntries to fetch.
     */
    orderBy?: PosEventEntryOrderByWithRelationInput | PosEventEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventEntries.
     */
    cursor?: PosEventEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventEntries.
     */
    distinct?: PosEventEntryScalarFieldEnum | PosEventEntryScalarFieldEnum[]
  }

  /**
   * PosEventEntry findFirstOrThrow
   */
  export type PosEventEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which PosEventEntry to fetch.
     */
    where?: PosEventEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventEntries to fetch.
     */
    orderBy?: PosEventEntryOrderByWithRelationInput | PosEventEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventEntries.
     */
    cursor?: PosEventEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventEntries.
     */
    distinct?: PosEventEntryScalarFieldEnum | PosEventEntryScalarFieldEnum[]
  }

  /**
   * PosEventEntry findMany
   */
  export type PosEventEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which PosEventEntries to fetch.
     */
    where?: PosEventEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventEntries to fetch.
     */
    orderBy?: PosEventEntryOrderByWithRelationInput | PosEventEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosEventEntries.
     */
    cursor?: PosEventEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventEntries.
     */
    skip?: number
    distinct?: PosEventEntryScalarFieldEnum | PosEventEntryScalarFieldEnum[]
  }

  /**
   * PosEventEntry create
   */
  export type PosEventEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a PosEventEntry.
     */
    data: XOR<PosEventEntryCreateInput, PosEventEntryUncheckedCreateInput>
  }

  /**
   * PosEventEntry createMany
   */
  export type PosEventEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosEventEntries.
     */
    data: PosEventEntryCreateManyInput | PosEventEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEventEntry createManyAndReturn
   */
  export type PosEventEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * The data used to create many PosEventEntries.
     */
    data: PosEventEntryCreateManyInput | PosEventEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventEntry update
   */
  export type PosEventEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a PosEventEntry.
     */
    data: XOR<PosEventEntryUpdateInput, PosEventEntryUncheckedUpdateInput>
    /**
     * Choose, which PosEventEntry to update.
     */
    where: PosEventEntryWhereUniqueInput
  }

  /**
   * PosEventEntry updateMany
   */
  export type PosEventEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosEventEntries.
     */
    data: XOR<PosEventEntryUpdateManyMutationInput, PosEventEntryUncheckedUpdateManyInput>
    /**
     * Filter which PosEventEntries to update
     */
    where?: PosEventEntryWhereInput
    /**
     * Limit how many PosEventEntries to update.
     */
    limit?: number
  }

  /**
   * PosEventEntry updateManyAndReturn
   */
  export type PosEventEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * The data used to update PosEventEntries.
     */
    data: XOR<PosEventEntryUpdateManyMutationInput, PosEventEntryUncheckedUpdateManyInput>
    /**
     * Filter which PosEventEntries to update
     */
    where?: PosEventEntryWhereInput
    /**
     * Limit how many PosEventEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventEntry upsert
   */
  export type PosEventEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the PosEventEntry to update in case it exists.
     */
    where: PosEventEntryWhereUniqueInput
    /**
     * In case the PosEventEntry found by the `where` argument doesn't exist, create a new PosEventEntry with this data.
     */
    create: XOR<PosEventEntryCreateInput, PosEventEntryUncheckedCreateInput>
    /**
     * In case the PosEventEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosEventEntryUpdateInput, PosEventEntryUncheckedUpdateInput>
  }

  /**
   * PosEventEntry delete
   */
  export type PosEventEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
    /**
     * Filter which PosEventEntry to delete.
     */
    where: PosEventEntryWhereUniqueInput
  }

  /**
   * PosEventEntry deleteMany
   */
  export type PosEventEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventEntries to delete
     */
    where?: PosEventEntryWhereInput
    /**
     * Limit how many PosEventEntries to delete.
     */
    limit?: number
  }

  /**
   * PosEventEntry without action
   */
  export type PosEventEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventEntry
     */
    select?: PosEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventEntry
     */
    omit?: PosEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventEntryInclude<ExtArgs> | null
  }


  /**
   * Model PosEventOutput
   */

  export type AggregatePosEventOutput = {
    _count: PosEventOutputCountAggregateOutputType | null
    _avg: PosEventOutputAvgAggregateOutputType | null
    _sum: PosEventOutputSumAggregateOutputType | null
    _min: PosEventOutputMinAggregateOutputType | null
    _max: PosEventOutputMaxAggregateOutputType | null
  }

  export type PosEventOutputAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PosEventOutputSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PosEventOutputMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    description: string | null
  }

  export type PosEventOutputMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    description: string | null
  }

  export type PosEventOutputCountAggregateOutputType = {
    id: number
    amount: number
    description: number
    _all: number
  }


  export type PosEventOutputAvgAggregateInputType = {
    amount?: true
  }

  export type PosEventOutputSumAggregateInputType = {
    amount?: true
  }

  export type PosEventOutputMinAggregateInputType = {
    id?: true
    amount?: true
    description?: true
  }

  export type PosEventOutputMaxAggregateInputType = {
    id?: true
    amount?: true
    description?: true
  }

  export type PosEventOutputCountAggregateInputType = {
    id?: true
    amount?: true
    description?: true
    _all?: true
  }

  export type PosEventOutputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventOutput to aggregate.
     */
    where?: PosEventOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventOutputs to fetch.
     */
    orderBy?: PosEventOutputOrderByWithRelationInput | PosEventOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosEventOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosEventOutputs
    **/
    _count?: true | PosEventOutputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PosEventOutputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PosEventOutputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosEventOutputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosEventOutputMaxAggregateInputType
  }

  export type GetPosEventOutputAggregateType<T extends PosEventOutputAggregateArgs> = {
        [P in keyof T & keyof AggregatePosEventOutput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosEventOutput[P]>
      : GetScalarType<T[P], AggregatePosEventOutput[P]>
  }




  export type PosEventOutputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventOutputWhereInput
    orderBy?: PosEventOutputOrderByWithAggregationInput | PosEventOutputOrderByWithAggregationInput[]
    by: PosEventOutputScalarFieldEnum[] | PosEventOutputScalarFieldEnum
    having?: PosEventOutputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosEventOutputCountAggregateInputType | true
    _avg?: PosEventOutputAvgAggregateInputType
    _sum?: PosEventOutputSumAggregateInputType
    _min?: PosEventOutputMinAggregateInputType
    _max?: PosEventOutputMaxAggregateInputType
  }

  export type PosEventOutputGroupByOutputType = {
    id: string
    amount: Decimal
    description: string
    _count: PosEventOutputCountAggregateOutputType | null
    _avg: PosEventOutputAvgAggregateOutputType | null
    _sum: PosEventOutputSumAggregateOutputType | null
    _min: PosEventOutputMinAggregateOutputType | null
    _max: PosEventOutputMaxAggregateOutputType | null
  }

  type GetPosEventOutputGroupByPayload<T extends PosEventOutputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosEventOutputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosEventOutputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosEventOutputGroupByOutputType[P]>
            : GetScalarType<T[P], PosEventOutputGroupByOutputType[P]>
        }
      >
    >


  export type PosEventOutputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    description?: boolean
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventOutput"]>

  export type PosEventOutputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    description?: boolean
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventOutput"]>

  export type PosEventOutputSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    description?: boolean
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventOutput"]>

  export type PosEventOutputSelectScalar = {
    id?: boolean
    amount?: boolean
    description?: boolean
  }

  export type PosEventOutputOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "description", ExtArgs["result"]["posEventOutput"]>
  export type PosEventOutputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }
  export type PosEventOutputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }
  export type PosEventOutputIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }

  export type $PosEventOutputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosEventOutput"
    objects: {
      posEvent: Prisma.$PosEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: Prisma.Decimal
      description: string
    }, ExtArgs["result"]["posEventOutput"]>
    composites: {}
  }

  type PosEventOutputGetPayload<S extends boolean | null | undefined | PosEventOutputDefaultArgs> = $Result.GetResult<Prisma.$PosEventOutputPayload, S>

  type PosEventOutputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosEventOutputFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosEventOutputCountAggregateInputType | true
    }

  export interface PosEventOutputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosEventOutput'], meta: { name: 'PosEventOutput' } }
    /**
     * Find zero or one PosEventOutput that matches the filter.
     * @param {PosEventOutputFindUniqueArgs} args - Arguments to find a PosEventOutput
     * @example
     * // Get one PosEventOutput
     * const posEventOutput = await prisma.posEventOutput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosEventOutputFindUniqueArgs>(args: SelectSubset<T, PosEventOutputFindUniqueArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosEventOutput that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosEventOutputFindUniqueOrThrowArgs} args - Arguments to find a PosEventOutput
     * @example
     * // Get one PosEventOutput
     * const posEventOutput = await prisma.posEventOutput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosEventOutputFindUniqueOrThrowArgs>(args: SelectSubset<T, PosEventOutputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventOutput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventOutputFindFirstArgs} args - Arguments to find a PosEventOutput
     * @example
     * // Get one PosEventOutput
     * const posEventOutput = await prisma.posEventOutput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosEventOutputFindFirstArgs>(args?: SelectSubset<T, PosEventOutputFindFirstArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventOutput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventOutputFindFirstOrThrowArgs} args - Arguments to find a PosEventOutput
     * @example
     * // Get one PosEventOutput
     * const posEventOutput = await prisma.posEventOutput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosEventOutputFindFirstOrThrowArgs>(args?: SelectSubset<T, PosEventOutputFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosEventOutputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventOutputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosEventOutputs
     * const posEventOutputs = await prisma.posEventOutput.findMany()
     * 
     * // Get first 10 PosEventOutputs
     * const posEventOutputs = await prisma.posEventOutput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posEventOutputWithIdOnly = await prisma.posEventOutput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosEventOutputFindManyArgs>(args?: SelectSubset<T, PosEventOutputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosEventOutput.
     * @param {PosEventOutputCreateArgs} args - Arguments to create a PosEventOutput.
     * @example
     * // Create one PosEventOutput
     * const PosEventOutput = await prisma.posEventOutput.create({
     *   data: {
     *     // ... data to create a PosEventOutput
     *   }
     * })
     * 
     */
    create<T extends PosEventOutputCreateArgs>(args: SelectSubset<T, PosEventOutputCreateArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosEventOutputs.
     * @param {PosEventOutputCreateManyArgs} args - Arguments to create many PosEventOutputs.
     * @example
     * // Create many PosEventOutputs
     * const posEventOutput = await prisma.posEventOutput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosEventOutputCreateManyArgs>(args?: SelectSubset<T, PosEventOutputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosEventOutputs and returns the data saved in the database.
     * @param {PosEventOutputCreateManyAndReturnArgs} args - Arguments to create many PosEventOutputs.
     * @example
     * // Create many PosEventOutputs
     * const posEventOutput = await prisma.posEventOutput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosEventOutputs and only return the `id`
     * const posEventOutputWithIdOnly = await prisma.posEventOutput.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosEventOutputCreateManyAndReturnArgs>(args?: SelectSubset<T, PosEventOutputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosEventOutput.
     * @param {PosEventOutputDeleteArgs} args - Arguments to delete one PosEventOutput.
     * @example
     * // Delete one PosEventOutput
     * const PosEventOutput = await prisma.posEventOutput.delete({
     *   where: {
     *     // ... filter to delete one PosEventOutput
     *   }
     * })
     * 
     */
    delete<T extends PosEventOutputDeleteArgs>(args: SelectSubset<T, PosEventOutputDeleteArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosEventOutput.
     * @param {PosEventOutputUpdateArgs} args - Arguments to update one PosEventOutput.
     * @example
     * // Update one PosEventOutput
     * const posEventOutput = await prisma.posEventOutput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosEventOutputUpdateArgs>(args: SelectSubset<T, PosEventOutputUpdateArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosEventOutputs.
     * @param {PosEventOutputDeleteManyArgs} args - Arguments to filter PosEventOutputs to delete.
     * @example
     * // Delete a few PosEventOutputs
     * const { count } = await prisma.posEventOutput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosEventOutputDeleteManyArgs>(args?: SelectSubset<T, PosEventOutputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventOutputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosEventOutputs
     * const posEventOutput = await prisma.posEventOutput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosEventOutputUpdateManyArgs>(args: SelectSubset<T, PosEventOutputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventOutputs and returns the data updated in the database.
     * @param {PosEventOutputUpdateManyAndReturnArgs} args - Arguments to update many PosEventOutputs.
     * @example
     * // Update many PosEventOutputs
     * const posEventOutput = await prisma.posEventOutput.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosEventOutputs and only return the `id`
     * const posEventOutputWithIdOnly = await prisma.posEventOutput.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosEventOutputUpdateManyAndReturnArgs>(args: SelectSubset<T, PosEventOutputUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosEventOutput.
     * @param {PosEventOutputUpsertArgs} args - Arguments to update or create a PosEventOutput.
     * @example
     * // Update or create a PosEventOutput
     * const posEventOutput = await prisma.posEventOutput.upsert({
     *   create: {
     *     // ... data to create a PosEventOutput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosEventOutput we want to update
     *   }
     * })
     */
    upsert<T extends PosEventOutputUpsertArgs>(args: SelectSubset<T, PosEventOutputUpsertArgs<ExtArgs>>): Prisma__PosEventOutputClient<$Result.GetResult<Prisma.$PosEventOutputPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosEventOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventOutputCountArgs} args - Arguments to filter PosEventOutputs to count.
     * @example
     * // Count the number of PosEventOutputs
     * const count = await prisma.posEventOutput.count({
     *   where: {
     *     // ... the filter for the PosEventOutputs we want to count
     *   }
     * })
    **/
    count<T extends PosEventOutputCountArgs>(
      args?: Subset<T, PosEventOutputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosEventOutputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosEventOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventOutputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosEventOutputAggregateArgs>(args: Subset<T, PosEventOutputAggregateArgs>): Prisma.PrismaPromise<GetPosEventOutputAggregateType<T>>

    /**
     * Group by PosEventOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventOutputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosEventOutputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosEventOutputGroupByArgs['orderBy'] }
        : { orderBy?: PosEventOutputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosEventOutputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosEventOutputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosEventOutput model
   */
  readonly fields: PosEventOutputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosEventOutput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosEventOutputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posEvent<T extends PosEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PosEventDefaultArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosEventOutput model
   */
  interface PosEventOutputFieldRefs {
    readonly id: FieldRef<"PosEventOutput", 'String'>
    readonly amount: FieldRef<"PosEventOutput", 'Decimal'>
    readonly description: FieldRef<"PosEventOutput", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PosEventOutput findUnique
   */
  export type PosEventOutputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which PosEventOutput to fetch.
     */
    where: PosEventOutputWhereUniqueInput
  }

  /**
   * PosEventOutput findUniqueOrThrow
   */
  export type PosEventOutputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which PosEventOutput to fetch.
     */
    where: PosEventOutputWhereUniqueInput
  }

  /**
   * PosEventOutput findFirst
   */
  export type PosEventOutputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which PosEventOutput to fetch.
     */
    where?: PosEventOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventOutputs to fetch.
     */
    orderBy?: PosEventOutputOrderByWithRelationInput | PosEventOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventOutputs.
     */
    cursor?: PosEventOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventOutputs.
     */
    distinct?: PosEventOutputScalarFieldEnum | PosEventOutputScalarFieldEnum[]
  }

  /**
   * PosEventOutput findFirstOrThrow
   */
  export type PosEventOutputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which PosEventOutput to fetch.
     */
    where?: PosEventOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventOutputs to fetch.
     */
    orderBy?: PosEventOutputOrderByWithRelationInput | PosEventOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventOutputs.
     */
    cursor?: PosEventOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventOutputs.
     */
    distinct?: PosEventOutputScalarFieldEnum | PosEventOutputScalarFieldEnum[]
  }

  /**
   * PosEventOutput findMany
   */
  export type PosEventOutputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which PosEventOutputs to fetch.
     */
    where?: PosEventOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventOutputs to fetch.
     */
    orderBy?: PosEventOutputOrderByWithRelationInput | PosEventOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosEventOutputs.
     */
    cursor?: PosEventOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventOutputs.
     */
    skip?: number
    distinct?: PosEventOutputScalarFieldEnum | PosEventOutputScalarFieldEnum[]
  }

  /**
   * PosEventOutput create
   */
  export type PosEventOutputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * The data needed to create a PosEventOutput.
     */
    data: XOR<PosEventOutputCreateInput, PosEventOutputUncheckedCreateInput>
  }

  /**
   * PosEventOutput createMany
   */
  export type PosEventOutputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosEventOutputs.
     */
    data: PosEventOutputCreateManyInput | PosEventOutputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEventOutput createManyAndReturn
   */
  export type PosEventOutputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * The data used to create many PosEventOutputs.
     */
    data: PosEventOutputCreateManyInput | PosEventOutputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventOutput update
   */
  export type PosEventOutputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * The data needed to update a PosEventOutput.
     */
    data: XOR<PosEventOutputUpdateInput, PosEventOutputUncheckedUpdateInput>
    /**
     * Choose, which PosEventOutput to update.
     */
    where: PosEventOutputWhereUniqueInput
  }

  /**
   * PosEventOutput updateMany
   */
  export type PosEventOutputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosEventOutputs.
     */
    data: XOR<PosEventOutputUpdateManyMutationInput, PosEventOutputUncheckedUpdateManyInput>
    /**
     * Filter which PosEventOutputs to update
     */
    where?: PosEventOutputWhereInput
    /**
     * Limit how many PosEventOutputs to update.
     */
    limit?: number
  }

  /**
   * PosEventOutput updateManyAndReturn
   */
  export type PosEventOutputUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * The data used to update PosEventOutputs.
     */
    data: XOR<PosEventOutputUpdateManyMutationInput, PosEventOutputUncheckedUpdateManyInput>
    /**
     * Filter which PosEventOutputs to update
     */
    where?: PosEventOutputWhereInput
    /**
     * Limit how many PosEventOutputs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventOutput upsert
   */
  export type PosEventOutputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * The filter to search for the PosEventOutput to update in case it exists.
     */
    where: PosEventOutputWhereUniqueInput
    /**
     * In case the PosEventOutput found by the `where` argument doesn't exist, create a new PosEventOutput with this data.
     */
    create: XOR<PosEventOutputCreateInput, PosEventOutputUncheckedCreateInput>
    /**
     * In case the PosEventOutput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosEventOutputUpdateInput, PosEventOutputUncheckedUpdateInput>
  }

  /**
   * PosEventOutput delete
   */
  export type PosEventOutputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
    /**
     * Filter which PosEventOutput to delete.
     */
    where: PosEventOutputWhereUniqueInput
  }

  /**
   * PosEventOutput deleteMany
   */
  export type PosEventOutputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventOutputs to delete
     */
    where?: PosEventOutputWhereInput
    /**
     * Limit how many PosEventOutputs to delete.
     */
    limit?: number
  }

  /**
   * PosEventOutput without action
   */
  export type PosEventOutputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventOutput
     */
    select?: PosEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventOutput
     */
    omit?: PosEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventOutputInclude<ExtArgs> | null
  }


  /**
   * Model PosEventSale
   */

  export type AggregatePosEventSale = {
    _count: PosEventSaleCountAggregateOutputType | null
    _avg: PosEventSaleAvgAggregateOutputType | null
    _sum: PosEventSaleSumAggregateOutputType | null
    _min: PosEventSaleMinAggregateOutputType | null
    _max: PosEventSaleMaxAggregateOutputType | null
  }

  export type PosEventSaleAvgAggregateOutputType = {
    amount: Decimal | null
    discountValue: number | null
  }

  export type PosEventSaleSumAggregateOutputType = {
    amount: Decimal | null
    discountValue: number | null
  }

  export type PosEventSaleMinAggregateOutputType = {
    id: string | null
    description: string | null
    amount: Decimal | null
    discountVariant: $Enums.EDiscountVariant | null
    discountValue: number | null
    customerId: string | null
    saleId: string | null
  }

  export type PosEventSaleMaxAggregateOutputType = {
    id: string | null
    description: string | null
    amount: Decimal | null
    discountVariant: $Enums.EDiscountVariant | null
    discountValue: number | null
    customerId: string | null
    saleId: string | null
  }

  export type PosEventSaleCountAggregateOutputType = {
    id: number
    description: number
    amount: number
    discountVariant: number
    discountValue: number
    customerId: number
    saleId: number
    _all: number
  }


  export type PosEventSaleAvgAggregateInputType = {
    amount?: true
    discountValue?: true
  }

  export type PosEventSaleSumAggregateInputType = {
    amount?: true
    discountValue?: true
  }

  export type PosEventSaleMinAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    discountVariant?: true
    discountValue?: true
    customerId?: true
    saleId?: true
  }

  export type PosEventSaleMaxAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    discountVariant?: true
    discountValue?: true
    customerId?: true
    saleId?: true
  }

  export type PosEventSaleCountAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    discountVariant?: true
    discountValue?: true
    customerId?: true
    saleId?: true
    _all?: true
  }

  export type PosEventSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSale to aggregate.
     */
    where?: PosEventSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSales to fetch.
     */
    orderBy?: PosEventSaleOrderByWithRelationInput | PosEventSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosEventSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosEventSales
    **/
    _count?: true | PosEventSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PosEventSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PosEventSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosEventSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosEventSaleMaxAggregateInputType
  }

  export type GetPosEventSaleAggregateType<T extends PosEventSaleAggregateArgs> = {
        [P in keyof T & keyof AggregatePosEventSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosEventSale[P]>
      : GetScalarType<T[P], AggregatePosEventSale[P]>
  }




  export type PosEventSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleWhereInput
    orderBy?: PosEventSaleOrderByWithAggregationInput | PosEventSaleOrderByWithAggregationInput[]
    by: PosEventSaleScalarFieldEnum[] | PosEventSaleScalarFieldEnum
    having?: PosEventSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosEventSaleCountAggregateInputType | true
    _avg?: PosEventSaleAvgAggregateInputType
    _sum?: PosEventSaleSumAggregateInputType
    _min?: PosEventSaleMinAggregateInputType
    _max?: PosEventSaleMaxAggregateInputType
  }

  export type PosEventSaleGroupByOutputType = {
    id: string
    description: string
    amount: Decimal
    discountVariant: $Enums.EDiscountVariant
    discountValue: number
    customerId: string
    saleId: string
    _count: PosEventSaleCountAggregateOutputType | null
    _avg: PosEventSaleAvgAggregateOutputType | null
    _sum: PosEventSaleSumAggregateOutputType | null
    _min: PosEventSaleMinAggregateOutputType | null
    _max: PosEventSaleMaxAggregateOutputType | null
  }

  type GetPosEventSaleGroupByPayload<T extends PosEventSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosEventSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosEventSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosEventSaleGroupByOutputType[P]>
            : GetScalarType<T[P], PosEventSaleGroupByOutputType[P]>
        }
      >
    >


  export type PosEventSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    discountVariant?: boolean
    discountValue?: boolean
    customerId?: boolean
    saleId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
    products?: boolean | PosEventSale$productsArgs<ExtArgs>
    movements?: boolean | PosEventSale$movementsArgs<ExtArgs>
    _count?: boolean | PosEventSaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSale"]>

  export type PosEventSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    discountVariant?: boolean
    discountValue?: boolean
    customerId?: boolean
    saleId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSale"]>

  export type PosEventSaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    discountVariant?: boolean
    discountValue?: boolean
    customerId?: boolean
    saleId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSale"]>

  export type PosEventSaleSelectScalar = {
    id?: boolean
    description?: boolean
    amount?: boolean
    discountVariant?: boolean
    discountValue?: boolean
    customerId?: boolean
    saleId?: boolean
  }

  export type PosEventSaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "amount" | "discountVariant" | "discountValue" | "customerId" | "saleId", ExtArgs["result"]["posEventSale"]>
  export type PosEventSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
    products?: boolean | PosEventSale$productsArgs<ExtArgs>
    movements?: boolean | PosEventSale$movementsArgs<ExtArgs>
    _count?: boolean | PosEventSaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PosEventSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }
  export type PosEventSaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    posEvent?: boolean | PosEventDefaultArgs<ExtArgs>
  }

  export type $PosEventSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosEventSale"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      posEvent: Prisma.$PosEventPayload<ExtArgs>
      products: Prisma.$PosEventSaleProductPayload<ExtArgs>[]
      movements: Prisma.$PosEventSaleMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      amount: Prisma.Decimal
      discountVariant: $Enums.EDiscountVariant
      discountValue: number
      customerId: string
      saleId: string
    }, ExtArgs["result"]["posEventSale"]>
    composites: {}
  }

  type PosEventSaleGetPayload<S extends boolean | null | undefined | PosEventSaleDefaultArgs> = $Result.GetResult<Prisma.$PosEventSalePayload, S>

  type PosEventSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosEventSaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosEventSaleCountAggregateInputType | true
    }

  export interface PosEventSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosEventSale'], meta: { name: 'PosEventSale' } }
    /**
     * Find zero or one PosEventSale that matches the filter.
     * @param {PosEventSaleFindUniqueArgs} args - Arguments to find a PosEventSale
     * @example
     * // Get one PosEventSale
     * const posEventSale = await prisma.posEventSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosEventSaleFindUniqueArgs>(args: SelectSubset<T, PosEventSaleFindUniqueArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosEventSale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosEventSaleFindUniqueOrThrowArgs} args - Arguments to find a PosEventSale
     * @example
     * // Get one PosEventSale
     * const posEventSale = await prisma.posEventSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosEventSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, PosEventSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleFindFirstArgs} args - Arguments to find a PosEventSale
     * @example
     * // Get one PosEventSale
     * const posEventSale = await prisma.posEventSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosEventSaleFindFirstArgs>(args?: SelectSubset<T, PosEventSaleFindFirstArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleFindFirstOrThrowArgs} args - Arguments to find a PosEventSale
     * @example
     * // Get one PosEventSale
     * const posEventSale = await prisma.posEventSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosEventSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, PosEventSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosEventSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosEventSales
     * const posEventSales = await prisma.posEventSale.findMany()
     * 
     * // Get first 10 PosEventSales
     * const posEventSales = await prisma.posEventSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posEventSaleWithIdOnly = await prisma.posEventSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosEventSaleFindManyArgs>(args?: SelectSubset<T, PosEventSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosEventSale.
     * @param {PosEventSaleCreateArgs} args - Arguments to create a PosEventSale.
     * @example
     * // Create one PosEventSale
     * const PosEventSale = await prisma.posEventSale.create({
     *   data: {
     *     // ... data to create a PosEventSale
     *   }
     * })
     * 
     */
    create<T extends PosEventSaleCreateArgs>(args: SelectSubset<T, PosEventSaleCreateArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosEventSales.
     * @param {PosEventSaleCreateManyArgs} args - Arguments to create many PosEventSales.
     * @example
     * // Create many PosEventSales
     * const posEventSale = await prisma.posEventSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosEventSaleCreateManyArgs>(args?: SelectSubset<T, PosEventSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosEventSales and returns the data saved in the database.
     * @param {PosEventSaleCreateManyAndReturnArgs} args - Arguments to create many PosEventSales.
     * @example
     * // Create many PosEventSales
     * const posEventSale = await prisma.posEventSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosEventSales and only return the `id`
     * const posEventSaleWithIdOnly = await prisma.posEventSale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosEventSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, PosEventSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosEventSale.
     * @param {PosEventSaleDeleteArgs} args - Arguments to delete one PosEventSale.
     * @example
     * // Delete one PosEventSale
     * const PosEventSale = await prisma.posEventSale.delete({
     *   where: {
     *     // ... filter to delete one PosEventSale
     *   }
     * })
     * 
     */
    delete<T extends PosEventSaleDeleteArgs>(args: SelectSubset<T, PosEventSaleDeleteArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosEventSale.
     * @param {PosEventSaleUpdateArgs} args - Arguments to update one PosEventSale.
     * @example
     * // Update one PosEventSale
     * const posEventSale = await prisma.posEventSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosEventSaleUpdateArgs>(args: SelectSubset<T, PosEventSaleUpdateArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosEventSales.
     * @param {PosEventSaleDeleteManyArgs} args - Arguments to filter PosEventSales to delete.
     * @example
     * // Delete a few PosEventSales
     * const { count } = await prisma.posEventSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosEventSaleDeleteManyArgs>(args?: SelectSubset<T, PosEventSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosEventSales
     * const posEventSale = await prisma.posEventSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosEventSaleUpdateManyArgs>(args: SelectSubset<T, PosEventSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSales and returns the data updated in the database.
     * @param {PosEventSaleUpdateManyAndReturnArgs} args - Arguments to update many PosEventSales.
     * @example
     * // Update many PosEventSales
     * const posEventSale = await prisma.posEventSale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosEventSales and only return the `id`
     * const posEventSaleWithIdOnly = await prisma.posEventSale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosEventSaleUpdateManyAndReturnArgs>(args: SelectSubset<T, PosEventSaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosEventSale.
     * @param {PosEventSaleUpsertArgs} args - Arguments to update or create a PosEventSale.
     * @example
     * // Update or create a PosEventSale
     * const posEventSale = await prisma.posEventSale.upsert({
     *   create: {
     *     // ... data to create a PosEventSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosEventSale we want to update
     *   }
     * })
     */
    upsert<T extends PosEventSaleUpsertArgs>(args: SelectSubset<T, PosEventSaleUpsertArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosEventSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleCountArgs} args - Arguments to filter PosEventSales to count.
     * @example
     * // Count the number of PosEventSales
     * const count = await prisma.posEventSale.count({
     *   where: {
     *     // ... the filter for the PosEventSales we want to count
     *   }
     * })
    **/
    count<T extends PosEventSaleCountArgs>(
      args?: Subset<T, PosEventSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosEventSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosEventSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosEventSaleAggregateArgs>(args: Subset<T, PosEventSaleAggregateArgs>): Prisma.PrismaPromise<GetPosEventSaleAggregateType<T>>

    /**
     * Group by PosEventSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosEventSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosEventSaleGroupByArgs['orderBy'] }
        : { orderBy?: PosEventSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosEventSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosEventSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosEventSale model
   */
  readonly fields: PosEventSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosEventSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosEventSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    posEvent<T extends PosEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PosEventDefaultArgs<ExtArgs>>): Prisma__PosEventClient<$Result.GetResult<Prisma.$PosEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends PosEventSale$productsArgs<ExtArgs> = {}>(args?: Subset<T, PosEventSale$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movements<T extends PosEventSale$movementsArgs<ExtArgs> = {}>(args?: Subset<T, PosEventSale$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosEventSale model
   */
  interface PosEventSaleFieldRefs {
    readonly id: FieldRef<"PosEventSale", 'String'>
    readonly description: FieldRef<"PosEventSale", 'String'>
    readonly amount: FieldRef<"PosEventSale", 'Decimal'>
    readonly discountVariant: FieldRef<"PosEventSale", 'EDiscountVariant'>
    readonly discountValue: FieldRef<"PosEventSale", 'Float'>
    readonly customerId: FieldRef<"PosEventSale", 'String'>
    readonly saleId: FieldRef<"PosEventSale", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PosEventSale findUnique
   */
  export type PosEventSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSale to fetch.
     */
    where: PosEventSaleWhereUniqueInput
  }

  /**
   * PosEventSale findUniqueOrThrow
   */
  export type PosEventSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSale to fetch.
     */
    where: PosEventSaleWhereUniqueInput
  }

  /**
   * PosEventSale findFirst
   */
  export type PosEventSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSale to fetch.
     */
    where?: PosEventSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSales to fetch.
     */
    orderBy?: PosEventSaleOrderByWithRelationInput | PosEventSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSales.
     */
    cursor?: PosEventSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSales.
     */
    distinct?: PosEventSaleScalarFieldEnum | PosEventSaleScalarFieldEnum[]
  }

  /**
   * PosEventSale findFirstOrThrow
   */
  export type PosEventSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSale to fetch.
     */
    where?: PosEventSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSales to fetch.
     */
    orderBy?: PosEventSaleOrderByWithRelationInput | PosEventSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSales.
     */
    cursor?: PosEventSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSales.
     */
    distinct?: PosEventSaleScalarFieldEnum | PosEventSaleScalarFieldEnum[]
  }

  /**
   * PosEventSale findMany
   */
  export type PosEventSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSales to fetch.
     */
    where?: PosEventSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSales to fetch.
     */
    orderBy?: PosEventSaleOrderByWithRelationInput | PosEventSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosEventSales.
     */
    cursor?: PosEventSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSales.
     */
    skip?: number
    distinct?: PosEventSaleScalarFieldEnum | PosEventSaleScalarFieldEnum[]
  }

  /**
   * PosEventSale create
   */
  export type PosEventSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a PosEventSale.
     */
    data: XOR<PosEventSaleCreateInput, PosEventSaleUncheckedCreateInput>
  }

  /**
   * PosEventSale createMany
   */
  export type PosEventSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosEventSales.
     */
    data: PosEventSaleCreateManyInput | PosEventSaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEventSale createManyAndReturn
   */
  export type PosEventSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * The data used to create many PosEventSales.
     */
    data: PosEventSaleCreateManyInput | PosEventSaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSale update
   */
  export type PosEventSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a PosEventSale.
     */
    data: XOR<PosEventSaleUpdateInput, PosEventSaleUncheckedUpdateInput>
    /**
     * Choose, which PosEventSale to update.
     */
    where: PosEventSaleWhereUniqueInput
  }

  /**
   * PosEventSale updateMany
   */
  export type PosEventSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosEventSales.
     */
    data: XOR<PosEventSaleUpdateManyMutationInput, PosEventSaleUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSales to update
     */
    where?: PosEventSaleWhereInput
    /**
     * Limit how many PosEventSales to update.
     */
    limit?: number
  }

  /**
   * PosEventSale updateManyAndReturn
   */
  export type PosEventSaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * The data used to update PosEventSales.
     */
    data: XOR<PosEventSaleUpdateManyMutationInput, PosEventSaleUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSales to update
     */
    where?: PosEventSaleWhereInput
    /**
     * Limit how many PosEventSales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSale upsert
   */
  export type PosEventSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the PosEventSale to update in case it exists.
     */
    where: PosEventSaleWhereUniqueInput
    /**
     * In case the PosEventSale found by the `where` argument doesn't exist, create a new PosEventSale with this data.
     */
    create: XOR<PosEventSaleCreateInput, PosEventSaleUncheckedCreateInput>
    /**
     * In case the PosEventSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosEventSaleUpdateInput, PosEventSaleUncheckedUpdateInput>
  }

  /**
   * PosEventSale delete
   */
  export type PosEventSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    /**
     * Filter which PosEventSale to delete.
     */
    where: PosEventSaleWhereUniqueInput
  }

  /**
   * PosEventSale deleteMany
   */
  export type PosEventSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSales to delete
     */
    where?: PosEventSaleWhereInput
    /**
     * Limit how many PosEventSales to delete.
     */
    limit?: number
  }

  /**
   * PosEventSale.products
   */
  export type PosEventSale$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    where?: PosEventSaleProductWhereInput
    orderBy?: PosEventSaleProductOrderByWithRelationInput | PosEventSaleProductOrderByWithRelationInput[]
    cursor?: PosEventSaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosEventSaleProductScalarFieldEnum | PosEventSaleProductScalarFieldEnum[]
  }

  /**
   * PosEventSale.movements
   */
  export type PosEventSale$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    where?: PosEventSaleMovementWhereInput
    orderBy?: PosEventSaleMovementOrderByWithRelationInput | PosEventSaleMovementOrderByWithRelationInput[]
    cursor?: PosEventSaleMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosEventSaleMovementScalarFieldEnum | PosEventSaleMovementScalarFieldEnum[]
  }

  /**
   * PosEventSale without action
   */
  export type PosEventSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
  }


  /**
   * Model PosEventSaleMovement
   */

  export type AggregatePosEventSaleMovement = {
    _count: PosEventSaleMovementCountAggregateOutputType | null
    _min: PosEventSaleMovementMinAggregateOutputType | null
    _max: PosEventSaleMovementMaxAggregateOutputType | null
  }

  export type PosEventSaleMovementMinAggregateOutputType = {
    id: string | null
    type: $Enums.ESaleMovementType | null
    createdAt: Date | null
    updatedAt: Date | null
    posEventSaleId: string | null
  }

  export type PosEventSaleMovementMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ESaleMovementType | null
    createdAt: Date | null
    updatedAt: Date | null
    posEventSaleId: string | null
  }

  export type PosEventSaleMovementCountAggregateOutputType = {
    id: number
    type: number
    createdAt: number
    updatedAt: number
    posEventSaleId: number
    _all: number
  }


  export type PosEventSaleMovementMinAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    posEventSaleId?: true
  }

  export type PosEventSaleMovementMaxAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    posEventSaleId?: true
  }

  export type PosEventSaleMovementCountAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    posEventSaleId?: true
    _all?: true
  }

  export type PosEventSaleMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSaleMovement to aggregate.
     */
    where?: PosEventSaleMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovements to fetch.
     */
    orderBy?: PosEventSaleMovementOrderByWithRelationInput | PosEventSaleMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosEventSaleMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosEventSaleMovements
    **/
    _count?: true | PosEventSaleMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosEventSaleMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosEventSaleMovementMaxAggregateInputType
  }

  export type GetPosEventSaleMovementAggregateType<T extends PosEventSaleMovementAggregateArgs> = {
        [P in keyof T & keyof AggregatePosEventSaleMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosEventSaleMovement[P]>
      : GetScalarType<T[P], AggregatePosEventSaleMovement[P]>
  }




  export type PosEventSaleMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleMovementWhereInput
    orderBy?: PosEventSaleMovementOrderByWithAggregationInput | PosEventSaleMovementOrderByWithAggregationInput[]
    by: PosEventSaleMovementScalarFieldEnum[] | PosEventSaleMovementScalarFieldEnum
    having?: PosEventSaleMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosEventSaleMovementCountAggregateInputType | true
    _min?: PosEventSaleMovementMinAggregateInputType
    _max?: PosEventSaleMovementMaxAggregateInputType
  }

  export type PosEventSaleMovementGroupByOutputType = {
    id: string
    type: $Enums.ESaleMovementType
    createdAt: Date
    updatedAt: Date
    posEventSaleId: string
    _count: PosEventSaleMovementCountAggregateOutputType | null
    _min: PosEventSaleMovementMinAggregateOutputType | null
    _max: PosEventSaleMovementMaxAggregateOutputType | null
  }

  type GetPosEventSaleMovementGroupByPayload<T extends PosEventSaleMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosEventSaleMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosEventSaleMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosEventSaleMovementGroupByOutputType[P]>
            : GetScalarType<T[P], PosEventSaleMovementGroupByOutputType[P]>
        }
      >
    >


  export type PosEventSaleMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleId?: boolean
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
    payments?: boolean | PosEventSaleMovement$paymentsArgs<ExtArgs>
    changes?: boolean | PosEventSaleMovement$changesArgs<ExtArgs>
    _count?: boolean | PosEventSaleMovementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovement"]>

  export type PosEventSaleMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleId?: boolean
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovement"]>

  export type PosEventSaleMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleId?: boolean
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovement"]>

  export type PosEventSaleMovementSelectScalar = {
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleId?: boolean
  }

  export type PosEventSaleMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "createdAt" | "updatedAt" | "posEventSaleId", ExtArgs["result"]["posEventSaleMovement"]>
  export type PosEventSaleMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
    payments?: boolean | PosEventSaleMovement$paymentsArgs<ExtArgs>
    changes?: boolean | PosEventSaleMovement$changesArgs<ExtArgs>
    _count?: boolean | PosEventSaleMovementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PosEventSaleMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
  }
  export type PosEventSaleMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
  }

  export type $PosEventSaleMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosEventSaleMovement"
    objects: {
      posEventSale: Prisma.$PosEventSalePayload<ExtArgs>
      payments: Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>[]
      changes: Prisma.$PosEventSaleMovementChangePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ESaleMovementType
      createdAt: Date
      updatedAt: Date
      posEventSaleId: string
    }, ExtArgs["result"]["posEventSaleMovement"]>
    composites: {}
  }

  type PosEventSaleMovementGetPayload<S extends boolean | null | undefined | PosEventSaleMovementDefaultArgs> = $Result.GetResult<Prisma.$PosEventSaleMovementPayload, S>

  type PosEventSaleMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosEventSaleMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosEventSaleMovementCountAggregateInputType | true
    }

  export interface PosEventSaleMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosEventSaleMovement'], meta: { name: 'PosEventSaleMovement' } }
    /**
     * Find zero or one PosEventSaleMovement that matches the filter.
     * @param {PosEventSaleMovementFindUniqueArgs} args - Arguments to find a PosEventSaleMovement
     * @example
     * // Get one PosEventSaleMovement
     * const posEventSaleMovement = await prisma.posEventSaleMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosEventSaleMovementFindUniqueArgs>(args: SelectSubset<T, PosEventSaleMovementFindUniqueArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosEventSaleMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosEventSaleMovementFindUniqueOrThrowArgs} args - Arguments to find a PosEventSaleMovement
     * @example
     * // Get one PosEventSaleMovement
     * const posEventSaleMovement = await prisma.posEventSaleMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosEventSaleMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, PosEventSaleMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSaleMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementFindFirstArgs} args - Arguments to find a PosEventSaleMovement
     * @example
     * // Get one PosEventSaleMovement
     * const posEventSaleMovement = await prisma.posEventSaleMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosEventSaleMovementFindFirstArgs>(args?: SelectSubset<T, PosEventSaleMovementFindFirstArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSaleMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementFindFirstOrThrowArgs} args - Arguments to find a PosEventSaleMovement
     * @example
     * // Get one PosEventSaleMovement
     * const posEventSaleMovement = await prisma.posEventSaleMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosEventSaleMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, PosEventSaleMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosEventSaleMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosEventSaleMovements
     * const posEventSaleMovements = await prisma.posEventSaleMovement.findMany()
     * 
     * // Get first 10 PosEventSaleMovements
     * const posEventSaleMovements = await prisma.posEventSaleMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posEventSaleMovementWithIdOnly = await prisma.posEventSaleMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosEventSaleMovementFindManyArgs>(args?: SelectSubset<T, PosEventSaleMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosEventSaleMovement.
     * @param {PosEventSaleMovementCreateArgs} args - Arguments to create a PosEventSaleMovement.
     * @example
     * // Create one PosEventSaleMovement
     * const PosEventSaleMovement = await prisma.posEventSaleMovement.create({
     *   data: {
     *     // ... data to create a PosEventSaleMovement
     *   }
     * })
     * 
     */
    create<T extends PosEventSaleMovementCreateArgs>(args: SelectSubset<T, PosEventSaleMovementCreateArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosEventSaleMovements.
     * @param {PosEventSaleMovementCreateManyArgs} args - Arguments to create many PosEventSaleMovements.
     * @example
     * // Create many PosEventSaleMovements
     * const posEventSaleMovement = await prisma.posEventSaleMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosEventSaleMovementCreateManyArgs>(args?: SelectSubset<T, PosEventSaleMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosEventSaleMovements and returns the data saved in the database.
     * @param {PosEventSaleMovementCreateManyAndReturnArgs} args - Arguments to create many PosEventSaleMovements.
     * @example
     * // Create many PosEventSaleMovements
     * const posEventSaleMovement = await prisma.posEventSaleMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosEventSaleMovements and only return the `id`
     * const posEventSaleMovementWithIdOnly = await prisma.posEventSaleMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosEventSaleMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, PosEventSaleMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosEventSaleMovement.
     * @param {PosEventSaleMovementDeleteArgs} args - Arguments to delete one PosEventSaleMovement.
     * @example
     * // Delete one PosEventSaleMovement
     * const PosEventSaleMovement = await prisma.posEventSaleMovement.delete({
     *   where: {
     *     // ... filter to delete one PosEventSaleMovement
     *   }
     * })
     * 
     */
    delete<T extends PosEventSaleMovementDeleteArgs>(args: SelectSubset<T, PosEventSaleMovementDeleteArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosEventSaleMovement.
     * @param {PosEventSaleMovementUpdateArgs} args - Arguments to update one PosEventSaleMovement.
     * @example
     * // Update one PosEventSaleMovement
     * const posEventSaleMovement = await prisma.posEventSaleMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosEventSaleMovementUpdateArgs>(args: SelectSubset<T, PosEventSaleMovementUpdateArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosEventSaleMovements.
     * @param {PosEventSaleMovementDeleteManyArgs} args - Arguments to filter PosEventSaleMovements to delete.
     * @example
     * // Delete a few PosEventSaleMovements
     * const { count } = await prisma.posEventSaleMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosEventSaleMovementDeleteManyArgs>(args?: SelectSubset<T, PosEventSaleMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSaleMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosEventSaleMovements
     * const posEventSaleMovement = await prisma.posEventSaleMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosEventSaleMovementUpdateManyArgs>(args: SelectSubset<T, PosEventSaleMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSaleMovements and returns the data updated in the database.
     * @param {PosEventSaleMovementUpdateManyAndReturnArgs} args - Arguments to update many PosEventSaleMovements.
     * @example
     * // Update many PosEventSaleMovements
     * const posEventSaleMovement = await prisma.posEventSaleMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosEventSaleMovements and only return the `id`
     * const posEventSaleMovementWithIdOnly = await prisma.posEventSaleMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosEventSaleMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, PosEventSaleMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosEventSaleMovement.
     * @param {PosEventSaleMovementUpsertArgs} args - Arguments to update or create a PosEventSaleMovement.
     * @example
     * // Update or create a PosEventSaleMovement
     * const posEventSaleMovement = await prisma.posEventSaleMovement.upsert({
     *   create: {
     *     // ... data to create a PosEventSaleMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosEventSaleMovement we want to update
     *   }
     * })
     */
    upsert<T extends PosEventSaleMovementUpsertArgs>(args: SelectSubset<T, PosEventSaleMovementUpsertArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosEventSaleMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementCountArgs} args - Arguments to filter PosEventSaleMovements to count.
     * @example
     * // Count the number of PosEventSaleMovements
     * const count = await prisma.posEventSaleMovement.count({
     *   where: {
     *     // ... the filter for the PosEventSaleMovements we want to count
     *   }
     * })
    **/
    count<T extends PosEventSaleMovementCountArgs>(
      args?: Subset<T, PosEventSaleMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosEventSaleMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosEventSaleMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosEventSaleMovementAggregateArgs>(args: Subset<T, PosEventSaleMovementAggregateArgs>): Prisma.PrismaPromise<GetPosEventSaleMovementAggregateType<T>>

    /**
     * Group by PosEventSaleMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosEventSaleMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosEventSaleMovementGroupByArgs['orderBy'] }
        : { orderBy?: PosEventSaleMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosEventSaleMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosEventSaleMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosEventSaleMovement model
   */
  readonly fields: PosEventSaleMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosEventSaleMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosEventSaleMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posEventSale<T extends PosEventSaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PosEventSaleDefaultArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends PosEventSaleMovement$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, PosEventSaleMovement$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changes<T extends PosEventSaleMovement$changesArgs<ExtArgs> = {}>(args?: Subset<T, PosEventSaleMovement$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosEventSaleMovement model
   */
  interface PosEventSaleMovementFieldRefs {
    readonly id: FieldRef<"PosEventSaleMovement", 'String'>
    readonly type: FieldRef<"PosEventSaleMovement", 'ESaleMovementType'>
    readonly createdAt: FieldRef<"PosEventSaleMovement", 'DateTime'>
    readonly updatedAt: FieldRef<"PosEventSaleMovement", 'DateTime'>
    readonly posEventSaleId: FieldRef<"PosEventSaleMovement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PosEventSaleMovement findUnique
   */
  export type PosEventSaleMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovement to fetch.
     */
    where: PosEventSaleMovementWhereUniqueInput
  }

  /**
   * PosEventSaleMovement findUniqueOrThrow
   */
  export type PosEventSaleMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovement to fetch.
     */
    where: PosEventSaleMovementWhereUniqueInput
  }

  /**
   * PosEventSaleMovement findFirst
   */
  export type PosEventSaleMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovement to fetch.
     */
    where?: PosEventSaleMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovements to fetch.
     */
    orderBy?: PosEventSaleMovementOrderByWithRelationInput | PosEventSaleMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSaleMovements.
     */
    cursor?: PosEventSaleMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSaleMovements.
     */
    distinct?: PosEventSaleMovementScalarFieldEnum | PosEventSaleMovementScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovement findFirstOrThrow
   */
  export type PosEventSaleMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovement to fetch.
     */
    where?: PosEventSaleMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovements to fetch.
     */
    orderBy?: PosEventSaleMovementOrderByWithRelationInput | PosEventSaleMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSaleMovements.
     */
    cursor?: PosEventSaleMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSaleMovements.
     */
    distinct?: PosEventSaleMovementScalarFieldEnum | PosEventSaleMovementScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovement findMany
   */
  export type PosEventSaleMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovements to fetch.
     */
    where?: PosEventSaleMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovements to fetch.
     */
    orderBy?: PosEventSaleMovementOrderByWithRelationInput | PosEventSaleMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosEventSaleMovements.
     */
    cursor?: PosEventSaleMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovements.
     */
    skip?: number
    distinct?: PosEventSaleMovementScalarFieldEnum | PosEventSaleMovementScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovement create
   */
  export type PosEventSaleMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a PosEventSaleMovement.
     */
    data: XOR<PosEventSaleMovementCreateInput, PosEventSaleMovementUncheckedCreateInput>
  }

  /**
   * PosEventSaleMovement createMany
   */
  export type PosEventSaleMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosEventSaleMovements.
     */
    data: PosEventSaleMovementCreateManyInput | PosEventSaleMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEventSaleMovement createManyAndReturn
   */
  export type PosEventSaleMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * The data used to create many PosEventSaleMovements.
     */
    data: PosEventSaleMovementCreateManyInput | PosEventSaleMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSaleMovement update
   */
  export type PosEventSaleMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a PosEventSaleMovement.
     */
    data: XOR<PosEventSaleMovementUpdateInput, PosEventSaleMovementUncheckedUpdateInput>
    /**
     * Choose, which PosEventSaleMovement to update.
     */
    where: PosEventSaleMovementWhereUniqueInput
  }

  /**
   * PosEventSaleMovement updateMany
   */
  export type PosEventSaleMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosEventSaleMovements.
     */
    data: XOR<PosEventSaleMovementUpdateManyMutationInput, PosEventSaleMovementUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSaleMovements to update
     */
    where?: PosEventSaleMovementWhereInput
    /**
     * Limit how many PosEventSaleMovements to update.
     */
    limit?: number
  }

  /**
   * PosEventSaleMovement updateManyAndReturn
   */
  export type PosEventSaleMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * The data used to update PosEventSaleMovements.
     */
    data: XOR<PosEventSaleMovementUpdateManyMutationInput, PosEventSaleMovementUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSaleMovements to update
     */
    where?: PosEventSaleMovementWhereInput
    /**
     * Limit how many PosEventSaleMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSaleMovement upsert
   */
  export type PosEventSaleMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the PosEventSaleMovement to update in case it exists.
     */
    where: PosEventSaleMovementWhereUniqueInput
    /**
     * In case the PosEventSaleMovement found by the `where` argument doesn't exist, create a new PosEventSaleMovement with this data.
     */
    create: XOR<PosEventSaleMovementCreateInput, PosEventSaleMovementUncheckedCreateInput>
    /**
     * In case the PosEventSaleMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosEventSaleMovementUpdateInput, PosEventSaleMovementUncheckedUpdateInput>
  }

  /**
   * PosEventSaleMovement delete
   */
  export type PosEventSaleMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
    /**
     * Filter which PosEventSaleMovement to delete.
     */
    where: PosEventSaleMovementWhereUniqueInput
  }

  /**
   * PosEventSaleMovement deleteMany
   */
  export type PosEventSaleMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSaleMovements to delete
     */
    where?: PosEventSaleMovementWhereInput
    /**
     * Limit how many PosEventSaleMovements to delete.
     */
    limit?: number
  }

  /**
   * PosEventSaleMovement.payments
   */
  export type PosEventSaleMovement$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    where?: PosEventSaleMovementPaymentWhereInput
    orderBy?: PosEventSaleMovementPaymentOrderByWithRelationInput | PosEventSaleMovementPaymentOrderByWithRelationInput[]
    cursor?: PosEventSaleMovementPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosEventSaleMovementPaymentScalarFieldEnum | PosEventSaleMovementPaymentScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovement.changes
   */
  export type PosEventSaleMovement$changesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    where?: PosEventSaleMovementChangeWhereInput
    orderBy?: PosEventSaleMovementChangeOrderByWithRelationInput | PosEventSaleMovementChangeOrderByWithRelationInput[]
    cursor?: PosEventSaleMovementChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosEventSaleMovementChangeScalarFieldEnum | PosEventSaleMovementChangeScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovement without action
   */
  export type PosEventSaleMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovement
     */
    select?: PosEventSaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovement
     */
    omit?: PosEventSaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementInclude<ExtArgs> | null
  }


  /**
   * Model PosEventSaleMovementPayment
   */

  export type AggregatePosEventSaleMovementPayment = {
    _count: PosEventSaleMovementPaymentCountAggregateOutputType | null
    _avg: PosEventSaleMovementPaymentAvgAggregateOutputType | null
    _sum: PosEventSaleMovementPaymentSumAggregateOutputType | null
    _min: PosEventSaleMovementPaymentMinAggregateOutputType | null
    _max: PosEventSaleMovementPaymentMaxAggregateOutputType | null
  }

  export type PosEventSaleMovementPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PosEventSaleMovementPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PosEventSaleMovementPaymentMinAggregateOutputType = {
    id: string | null
    method: $Enums.EPaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PosEventSaleMovementPaymentMaxAggregateOutputType = {
    id: string | null
    method: $Enums.EPaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PosEventSaleMovementPaymentCountAggregateOutputType = {
    id: number
    method: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PosEventSaleMovementPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PosEventSaleMovementPaymentSumAggregateInputType = {
    amount?: true
  }

  export type PosEventSaleMovementPaymentMinAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PosEventSaleMovementPaymentMaxAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PosEventSaleMovementPaymentCountAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PosEventSaleMovementPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSaleMovementPayment to aggregate.
     */
    where?: PosEventSaleMovementPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovementPayments to fetch.
     */
    orderBy?: PosEventSaleMovementPaymentOrderByWithRelationInput | PosEventSaleMovementPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosEventSaleMovementPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovementPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovementPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosEventSaleMovementPayments
    **/
    _count?: true | PosEventSaleMovementPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PosEventSaleMovementPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PosEventSaleMovementPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosEventSaleMovementPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosEventSaleMovementPaymentMaxAggregateInputType
  }

  export type GetPosEventSaleMovementPaymentAggregateType<T extends PosEventSaleMovementPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePosEventSaleMovementPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosEventSaleMovementPayment[P]>
      : GetScalarType<T[P], AggregatePosEventSaleMovementPayment[P]>
  }




  export type PosEventSaleMovementPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleMovementPaymentWhereInput
    orderBy?: PosEventSaleMovementPaymentOrderByWithAggregationInput | PosEventSaleMovementPaymentOrderByWithAggregationInput[]
    by: PosEventSaleMovementPaymentScalarFieldEnum[] | PosEventSaleMovementPaymentScalarFieldEnum
    having?: PosEventSaleMovementPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosEventSaleMovementPaymentCountAggregateInputType | true
    _avg?: PosEventSaleMovementPaymentAvgAggregateInputType
    _sum?: PosEventSaleMovementPaymentSumAggregateInputType
    _min?: PosEventSaleMovementPaymentMinAggregateInputType
    _max?: PosEventSaleMovementPaymentMaxAggregateInputType
  }

  export type PosEventSaleMovementPaymentGroupByOutputType = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PosEventSaleMovementPaymentCountAggregateOutputType | null
    _avg: PosEventSaleMovementPaymentAvgAggregateOutputType | null
    _sum: PosEventSaleMovementPaymentSumAggregateOutputType | null
    _min: PosEventSaleMovementPaymentMinAggregateOutputType | null
    _max: PosEventSaleMovementPaymentMaxAggregateOutputType | null
  }

  type GetPosEventSaleMovementPaymentGroupByPayload<T extends PosEventSaleMovementPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosEventSaleMovementPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosEventSaleMovementPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosEventSaleMovementPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PosEventSaleMovementPaymentGroupByOutputType[P]>
        }
      >
    >


  export type PosEventSaleMovementPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovementPayment"]>

  export type PosEventSaleMovementPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovementPayment"]>

  export type PosEventSaleMovementPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovementPayment"]>

  export type PosEventSaleMovementPaymentSelectScalar = {
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PosEventSaleMovementPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "method" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["posEventSaleMovementPayment"]>
  export type PosEventSaleMovementPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }
  export type PosEventSaleMovementPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }
  export type PosEventSaleMovementPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }

  export type $PosEventSaleMovementPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosEventSaleMovementPayment"
    objects: {
      posEventSaleMovement: Prisma.$PosEventSaleMovementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      method: $Enums.EPaymentMethod
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["posEventSaleMovementPayment"]>
    composites: {}
  }

  type PosEventSaleMovementPaymentGetPayload<S extends boolean | null | undefined | PosEventSaleMovementPaymentDefaultArgs> = $Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload, S>

  type PosEventSaleMovementPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosEventSaleMovementPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosEventSaleMovementPaymentCountAggregateInputType | true
    }

  export interface PosEventSaleMovementPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosEventSaleMovementPayment'], meta: { name: 'PosEventSaleMovementPayment' } }
    /**
     * Find zero or one PosEventSaleMovementPayment that matches the filter.
     * @param {PosEventSaleMovementPaymentFindUniqueArgs} args - Arguments to find a PosEventSaleMovementPayment
     * @example
     * // Get one PosEventSaleMovementPayment
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosEventSaleMovementPaymentFindUniqueArgs>(args: SelectSubset<T, PosEventSaleMovementPaymentFindUniqueArgs<ExtArgs>>): Prisma__PosEventSaleMovementPaymentClient<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosEventSaleMovementPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosEventSaleMovementPaymentFindUniqueOrThrowArgs} args - Arguments to find a PosEventSaleMovementPayment
     * @example
     * // Get one PosEventSaleMovementPayment
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosEventSaleMovementPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PosEventSaleMovementPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleMovementPaymentClient<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSaleMovementPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementPaymentFindFirstArgs} args - Arguments to find a PosEventSaleMovementPayment
     * @example
     * // Get one PosEventSaleMovementPayment
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosEventSaleMovementPaymentFindFirstArgs>(args?: SelectSubset<T, PosEventSaleMovementPaymentFindFirstArgs<ExtArgs>>): Prisma__PosEventSaleMovementPaymentClient<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSaleMovementPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementPaymentFindFirstOrThrowArgs} args - Arguments to find a PosEventSaleMovementPayment
     * @example
     * // Get one PosEventSaleMovementPayment
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosEventSaleMovementPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PosEventSaleMovementPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleMovementPaymentClient<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosEventSaleMovementPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosEventSaleMovementPayments
     * const posEventSaleMovementPayments = await prisma.posEventSaleMovementPayment.findMany()
     * 
     * // Get first 10 PosEventSaleMovementPayments
     * const posEventSaleMovementPayments = await prisma.posEventSaleMovementPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posEventSaleMovementPaymentWithIdOnly = await prisma.posEventSaleMovementPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosEventSaleMovementPaymentFindManyArgs>(args?: SelectSubset<T, PosEventSaleMovementPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosEventSaleMovementPayment.
     * @param {PosEventSaleMovementPaymentCreateArgs} args - Arguments to create a PosEventSaleMovementPayment.
     * @example
     * // Create one PosEventSaleMovementPayment
     * const PosEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.create({
     *   data: {
     *     // ... data to create a PosEventSaleMovementPayment
     *   }
     * })
     * 
     */
    create<T extends PosEventSaleMovementPaymentCreateArgs>(args: SelectSubset<T, PosEventSaleMovementPaymentCreateArgs<ExtArgs>>): Prisma__PosEventSaleMovementPaymentClient<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosEventSaleMovementPayments.
     * @param {PosEventSaleMovementPaymentCreateManyArgs} args - Arguments to create many PosEventSaleMovementPayments.
     * @example
     * // Create many PosEventSaleMovementPayments
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosEventSaleMovementPaymentCreateManyArgs>(args?: SelectSubset<T, PosEventSaleMovementPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosEventSaleMovementPayments and returns the data saved in the database.
     * @param {PosEventSaleMovementPaymentCreateManyAndReturnArgs} args - Arguments to create many PosEventSaleMovementPayments.
     * @example
     * // Create many PosEventSaleMovementPayments
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosEventSaleMovementPayments and only return the `id`
     * const posEventSaleMovementPaymentWithIdOnly = await prisma.posEventSaleMovementPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosEventSaleMovementPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PosEventSaleMovementPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosEventSaleMovementPayment.
     * @param {PosEventSaleMovementPaymentDeleteArgs} args - Arguments to delete one PosEventSaleMovementPayment.
     * @example
     * // Delete one PosEventSaleMovementPayment
     * const PosEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.delete({
     *   where: {
     *     // ... filter to delete one PosEventSaleMovementPayment
     *   }
     * })
     * 
     */
    delete<T extends PosEventSaleMovementPaymentDeleteArgs>(args: SelectSubset<T, PosEventSaleMovementPaymentDeleteArgs<ExtArgs>>): Prisma__PosEventSaleMovementPaymentClient<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosEventSaleMovementPayment.
     * @param {PosEventSaleMovementPaymentUpdateArgs} args - Arguments to update one PosEventSaleMovementPayment.
     * @example
     * // Update one PosEventSaleMovementPayment
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosEventSaleMovementPaymentUpdateArgs>(args: SelectSubset<T, PosEventSaleMovementPaymentUpdateArgs<ExtArgs>>): Prisma__PosEventSaleMovementPaymentClient<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosEventSaleMovementPayments.
     * @param {PosEventSaleMovementPaymentDeleteManyArgs} args - Arguments to filter PosEventSaleMovementPayments to delete.
     * @example
     * // Delete a few PosEventSaleMovementPayments
     * const { count } = await prisma.posEventSaleMovementPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosEventSaleMovementPaymentDeleteManyArgs>(args?: SelectSubset<T, PosEventSaleMovementPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSaleMovementPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosEventSaleMovementPayments
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosEventSaleMovementPaymentUpdateManyArgs>(args: SelectSubset<T, PosEventSaleMovementPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSaleMovementPayments and returns the data updated in the database.
     * @param {PosEventSaleMovementPaymentUpdateManyAndReturnArgs} args - Arguments to update many PosEventSaleMovementPayments.
     * @example
     * // Update many PosEventSaleMovementPayments
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosEventSaleMovementPayments and only return the `id`
     * const posEventSaleMovementPaymentWithIdOnly = await prisma.posEventSaleMovementPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosEventSaleMovementPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PosEventSaleMovementPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosEventSaleMovementPayment.
     * @param {PosEventSaleMovementPaymentUpsertArgs} args - Arguments to update or create a PosEventSaleMovementPayment.
     * @example
     * // Update or create a PosEventSaleMovementPayment
     * const posEventSaleMovementPayment = await prisma.posEventSaleMovementPayment.upsert({
     *   create: {
     *     // ... data to create a PosEventSaleMovementPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosEventSaleMovementPayment we want to update
     *   }
     * })
     */
    upsert<T extends PosEventSaleMovementPaymentUpsertArgs>(args: SelectSubset<T, PosEventSaleMovementPaymentUpsertArgs<ExtArgs>>): Prisma__PosEventSaleMovementPaymentClient<$Result.GetResult<Prisma.$PosEventSaleMovementPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosEventSaleMovementPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementPaymentCountArgs} args - Arguments to filter PosEventSaleMovementPayments to count.
     * @example
     * // Count the number of PosEventSaleMovementPayments
     * const count = await prisma.posEventSaleMovementPayment.count({
     *   where: {
     *     // ... the filter for the PosEventSaleMovementPayments we want to count
     *   }
     * })
    **/
    count<T extends PosEventSaleMovementPaymentCountArgs>(
      args?: Subset<T, PosEventSaleMovementPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosEventSaleMovementPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosEventSaleMovementPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosEventSaleMovementPaymentAggregateArgs>(args: Subset<T, PosEventSaleMovementPaymentAggregateArgs>): Prisma.PrismaPromise<GetPosEventSaleMovementPaymentAggregateType<T>>

    /**
     * Group by PosEventSaleMovementPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosEventSaleMovementPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosEventSaleMovementPaymentGroupByArgs['orderBy'] }
        : { orderBy?: PosEventSaleMovementPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosEventSaleMovementPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosEventSaleMovementPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosEventSaleMovementPayment model
   */
  readonly fields: PosEventSaleMovementPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosEventSaleMovementPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosEventSaleMovementPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posEventSaleMovement<T extends PosEventSaleMovementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PosEventSaleMovementDefaultArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosEventSaleMovementPayment model
   */
  interface PosEventSaleMovementPaymentFieldRefs {
    readonly id: FieldRef<"PosEventSaleMovementPayment", 'String'>
    readonly method: FieldRef<"PosEventSaleMovementPayment", 'EPaymentMethod'>
    readonly amount: FieldRef<"PosEventSaleMovementPayment", 'Decimal'>
    readonly createdAt: FieldRef<"PosEventSaleMovementPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"PosEventSaleMovementPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PosEventSaleMovementPayment findUnique
   */
  export type PosEventSaleMovementPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementPayment to fetch.
     */
    where: PosEventSaleMovementPaymentWhereUniqueInput
  }

  /**
   * PosEventSaleMovementPayment findUniqueOrThrow
   */
  export type PosEventSaleMovementPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementPayment to fetch.
     */
    where: PosEventSaleMovementPaymentWhereUniqueInput
  }

  /**
   * PosEventSaleMovementPayment findFirst
   */
  export type PosEventSaleMovementPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementPayment to fetch.
     */
    where?: PosEventSaleMovementPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovementPayments to fetch.
     */
    orderBy?: PosEventSaleMovementPaymentOrderByWithRelationInput | PosEventSaleMovementPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSaleMovementPayments.
     */
    cursor?: PosEventSaleMovementPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovementPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovementPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSaleMovementPayments.
     */
    distinct?: PosEventSaleMovementPaymentScalarFieldEnum | PosEventSaleMovementPaymentScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovementPayment findFirstOrThrow
   */
  export type PosEventSaleMovementPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementPayment to fetch.
     */
    where?: PosEventSaleMovementPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovementPayments to fetch.
     */
    orderBy?: PosEventSaleMovementPaymentOrderByWithRelationInput | PosEventSaleMovementPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSaleMovementPayments.
     */
    cursor?: PosEventSaleMovementPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovementPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovementPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSaleMovementPayments.
     */
    distinct?: PosEventSaleMovementPaymentScalarFieldEnum | PosEventSaleMovementPaymentScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovementPayment findMany
   */
  export type PosEventSaleMovementPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementPayments to fetch.
     */
    where?: PosEventSaleMovementPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovementPayments to fetch.
     */
    orderBy?: PosEventSaleMovementPaymentOrderByWithRelationInput | PosEventSaleMovementPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosEventSaleMovementPayments.
     */
    cursor?: PosEventSaleMovementPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovementPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovementPayments.
     */
    skip?: number
    distinct?: PosEventSaleMovementPaymentScalarFieldEnum | PosEventSaleMovementPaymentScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovementPayment create
   */
  export type PosEventSaleMovementPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a PosEventSaleMovementPayment.
     */
    data: XOR<PosEventSaleMovementPaymentCreateInput, PosEventSaleMovementPaymentUncheckedCreateInput>
  }

  /**
   * PosEventSaleMovementPayment createMany
   */
  export type PosEventSaleMovementPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosEventSaleMovementPayments.
     */
    data: PosEventSaleMovementPaymentCreateManyInput | PosEventSaleMovementPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEventSaleMovementPayment createManyAndReturn
   */
  export type PosEventSaleMovementPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many PosEventSaleMovementPayments.
     */
    data: PosEventSaleMovementPaymentCreateManyInput | PosEventSaleMovementPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSaleMovementPayment update
   */
  export type PosEventSaleMovementPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a PosEventSaleMovementPayment.
     */
    data: XOR<PosEventSaleMovementPaymentUpdateInput, PosEventSaleMovementPaymentUncheckedUpdateInput>
    /**
     * Choose, which PosEventSaleMovementPayment to update.
     */
    where: PosEventSaleMovementPaymentWhereUniqueInput
  }

  /**
   * PosEventSaleMovementPayment updateMany
   */
  export type PosEventSaleMovementPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosEventSaleMovementPayments.
     */
    data: XOR<PosEventSaleMovementPaymentUpdateManyMutationInput, PosEventSaleMovementPaymentUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSaleMovementPayments to update
     */
    where?: PosEventSaleMovementPaymentWhereInput
    /**
     * Limit how many PosEventSaleMovementPayments to update.
     */
    limit?: number
  }

  /**
   * PosEventSaleMovementPayment updateManyAndReturn
   */
  export type PosEventSaleMovementPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * The data used to update PosEventSaleMovementPayments.
     */
    data: XOR<PosEventSaleMovementPaymentUpdateManyMutationInput, PosEventSaleMovementPaymentUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSaleMovementPayments to update
     */
    where?: PosEventSaleMovementPaymentWhereInput
    /**
     * Limit how many PosEventSaleMovementPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSaleMovementPayment upsert
   */
  export type PosEventSaleMovementPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the PosEventSaleMovementPayment to update in case it exists.
     */
    where: PosEventSaleMovementPaymentWhereUniqueInput
    /**
     * In case the PosEventSaleMovementPayment found by the `where` argument doesn't exist, create a new PosEventSaleMovementPayment with this data.
     */
    create: XOR<PosEventSaleMovementPaymentCreateInput, PosEventSaleMovementPaymentUncheckedCreateInput>
    /**
     * In case the PosEventSaleMovementPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosEventSaleMovementPaymentUpdateInput, PosEventSaleMovementPaymentUncheckedUpdateInput>
  }

  /**
   * PosEventSaleMovementPayment delete
   */
  export type PosEventSaleMovementPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter which PosEventSaleMovementPayment to delete.
     */
    where: PosEventSaleMovementPaymentWhereUniqueInput
  }

  /**
   * PosEventSaleMovementPayment deleteMany
   */
  export type PosEventSaleMovementPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSaleMovementPayments to delete
     */
    where?: PosEventSaleMovementPaymentWhereInput
    /**
     * Limit how many PosEventSaleMovementPayments to delete.
     */
    limit?: number
  }

  /**
   * PosEventSaleMovementPayment without action
   */
  export type PosEventSaleMovementPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementPayment
     */
    select?: PosEventSaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementPayment
     */
    omit?: PosEventSaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementPaymentInclude<ExtArgs> | null
  }


  /**
   * Model PosEventSaleMovementChange
   */

  export type AggregatePosEventSaleMovementChange = {
    _count: PosEventSaleMovementChangeCountAggregateOutputType | null
    _avg: PosEventSaleMovementChangeAvgAggregateOutputType | null
    _sum: PosEventSaleMovementChangeSumAggregateOutputType | null
    _min: PosEventSaleMovementChangeMinAggregateOutputType | null
    _max: PosEventSaleMovementChangeMaxAggregateOutputType | null
  }

  export type PosEventSaleMovementChangeAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PosEventSaleMovementChangeSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PosEventSaleMovementChangeMinAggregateOutputType = {
    id: string | null
    method: $Enums.EPaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PosEventSaleMovementChangeMaxAggregateOutputType = {
    id: string | null
    method: $Enums.EPaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PosEventSaleMovementChangeCountAggregateOutputType = {
    id: number
    method: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PosEventSaleMovementChangeAvgAggregateInputType = {
    amount?: true
  }

  export type PosEventSaleMovementChangeSumAggregateInputType = {
    amount?: true
  }

  export type PosEventSaleMovementChangeMinAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PosEventSaleMovementChangeMaxAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PosEventSaleMovementChangeCountAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PosEventSaleMovementChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSaleMovementChange to aggregate.
     */
    where?: PosEventSaleMovementChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovementChanges to fetch.
     */
    orderBy?: PosEventSaleMovementChangeOrderByWithRelationInput | PosEventSaleMovementChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosEventSaleMovementChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovementChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovementChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosEventSaleMovementChanges
    **/
    _count?: true | PosEventSaleMovementChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PosEventSaleMovementChangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PosEventSaleMovementChangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosEventSaleMovementChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosEventSaleMovementChangeMaxAggregateInputType
  }

  export type GetPosEventSaleMovementChangeAggregateType<T extends PosEventSaleMovementChangeAggregateArgs> = {
        [P in keyof T & keyof AggregatePosEventSaleMovementChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosEventSaleMovementChange[P]>
      : GetScalarType<T[P], AggregatePosEventSaleMovementChange[P]>
  }




  export type PosEventSaleMovementChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleMovementChangeWhereInput
    orderBy?: PosEventSaleMovementChangeOrderByWithAggregationInput | PosEventSaleMovementChangeOrderByWithAggregationInput[]
    by: PosEventSaleMovementChangeScalarFieldEnum[] | PosEventSaleMovementChangeScalarFieldEnum
    having?: PosEventSaleMovementChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosEventSaleMovementChangeCountAggregateInputType | true
    _avg?: PosEventSaleMovementChangeAvgAggregateInputType
    _sum?: PosEventSaleMovementChangeSumAggregateInputType
    _min?: PosEventSaleMovementChangeMinAggregateInputType
    _max?: PosEventSaleMovementChangeMaxAggregateInputType
  }

  export type PosEventSaleMovementChangeGroupByOutputType = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: PosEventSaleMovementChangeCountAggregateOutputType | null
    _avg: PosEventSaleMovementChangeAvgAggregateOutputType | null
    _sum: PosEventSaleMovementChangeSumAggregateOutputType | null
    _min: PosEventSaleMovementChangeMinAggregateOutputType | null
    _max: PosEventSaleMovementChangeMaxAggregateOutputType | null
  }

  type GetPosEventSaleMovementChangeGroupByPayload<T extends PosEventSaleMovementChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosEventSaleMovementChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosEventSaleMovementChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosEventSaleMovementChangeGroupByOutputType[P]>
            : GetScalarType<T[P], PosEventSaleMovementChangeGroupByOutputType[P]>
        }
      >
    >


  export type PosEventSaleMovementChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovementChange"]>

  export type PosEventSaleMovementChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovementChange"]>

  export type PosEventSaleMovementChangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleMovementChange"]>

  export type PosEventSaleMovementChangeSelectScalar = {
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PosEventSaleMovementChangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "method" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["posEventSaleMovementChange"]>
  export type PosEventSaleMovementChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }
  export type PosEventSaleMovementChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }
  export type PosEventSaleMovementChangeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSaleMovement?: boolean | PosEventSaleMovementDefaultArgs<ExtArgs>
  }

  export type $PosEventSaleMovementChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosEventSaleMovementChange"
    objects: {
      posEventSaleMovement: Prisma.$PosEventSaleMovementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      method: $Enums.EPaymentMethod
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["posEventSaleMovementChange"]>
    composites: {}
  }

  type PosEventSaleMovementChangeGetPayload<S extends boolean | null | undefined | PosEventSaleMovementChangeDefaultArgs> = $Result.GetResult<Prisma.$PosEventSaleMovementChangePayload, S>

  type PosEventSaleMovementChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosEventSaleMovementChangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosEventSaleMovementChangeCountAggregateInputType | true
    }

  export interface PosEventSaleMovementChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosEventSaleMovementChange'], meta: { name: 'PosEventSaleMovementChange' } }
    /**
     * Find zero or one PosEventSaleMovementChange that matches the filter.
     * @param {PosEventSaleMovementChangeFindUniqueArgs} args - Arguments to find a PosEventSaleMovementChange
     * @example
     * // Get one PosEventSaleMovementChange
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosEventSaleMovementChangeFindUniqueArgs>(args: SelectSubset<T, PosEventSaleMovementChangeFindUniqueArgs<ExtArgs>>): Prisma__PosEventSaleMovementChangeClient<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosEventSaleMovementChange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosEventSaleMovementChangeFindUniqueOrThrowArgs} args - Arguments to find a PosEventSaleMovementChange
     * @example
     * // Get one PosEventSaleMovementChange
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosEventSaleMovementChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, PosEventSaleMovementChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleMovementChangeClient<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSaleMovementChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementChangeFindFirstArgs} args - Arguments to find a PosEventSaleMovementChange
     * @example
     * // Get one PosEventSaleMovementChange
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosEventSaleMovementChangeFindFirstArgs>(args?: SelectSubset<T, PosEventSaleMovementChangeFindFirstArgs<ExtArgs>>): Prisma__PosEventSaleMovementChangeClient<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSaleMovementChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementChangeFindFirstOrThrowArgs} args - Arguments to find a PosEventSaleMovementChange
     * @example
     * // Get one PosEventSaleMovementChange
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosEventSaleMovementChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, PosEventSaleMovementChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleMovementChangeClient<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosEventSaleMovementChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosEventSaleMovementChanges
     * const posEventSaleMovementChanges = await prisma.posEventSaleMovementChange.findMany()
     * 
     * // Get first 10 PosEventSaleMovementChanges
     * const posEventSaleMovementChanges = await prisma.posEventSaleMovementChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posEventSaleMovementChangeWithIdOnly = await prisma.posEventSaleMovementChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosEventSaleMovementChangeFindManyArgs>(args?: SelectSubset<T, PosEventSaleMovementChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosEventSaleMovementChange.
     * @param {PosEventSaleMovementChangeCreateArgs} args - Arguments to create a PosEventSaleMovementChange.
     * @example
     * // Create one PosEventSaleMovementChange
     * const PosEventSaleMovementChange = await prisma.posEventSaleMovementChange.create({
     *   data: {
     *     // ... data to create a PosEventSaleMovementChange
     *   }
     * })
     * 
     */
    create<T extends PosEventSaleMovementChangeCreateArgs>(args: SelectSubset<T, PosEventSaleMovementChangeCreateArgs<ExtArgs>>): Prisma__PosEventSaleMovementChangeClient<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosEventSaleMovementChanges.
     * @param {PosEventSaleMovementChangeCreateManyArgs} args - Arguments to create many PosEventSaleMovementChanges.
     * @example
     * // Create many PosEventSaleMovementChanges
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosEventSaleMovementChangeCreateManyArgs>(args?: SelectSubset<T, PosEventSaleMovementChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosEventSaleMovementChanges and returns the data saved in the database.
     * @param {PosEventSaleMovementChangeCreateManyAndReturnArgs} args - Arguments to create many PosEventSaleMovementChanges.
     * @example
     * // Create many PosEventSaleMovementChanges
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosEventSaleMovementChanges and only return the `id`
     * const posEventSaleMovementChangeWithIdOnly = await prisma.posEventSaleMovementChange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosEventSaleMovementChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, PosEventSaleMovementChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosEventSaleMovementChange.
     * @param {PosEventSaleMovementChangeDeleteArgs} args - Arguments to delete one PosEventSaleMovementChange.
     * @example
     * // Delete one PosEventSaleMovementChange
     * const PosEventSaleMovementChange = await prisma.posEventSaleMovementChange.delete({
     *   where: {
     *     // ... filter to delete one PosEventSaleMovementChange
     *   }
     * })
     * 
     */
    delete<T extends PosEventSaleMovementChangeDeleteArgs>(args: SelectSubset<T, PosEventSaleMovementChangeDeleteArgs<ExtArgs>>): Prisma__PosEventSaleMovementChangeClient<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosEventSaleMovementChange.
     * @param {PosEventSaleMovementChangeUpdateArgs} args - Arguments to update one PosEventSaleMovementChange.
     * @example
     * // Update one PosEventSaleMovementChange
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosEventSaleMovementChangeUpdateArgs>(args: SelectSubset<T, PosEventSaleMovementChangeUpdateArgs<ExtArgs>>): Prisma__PosEventSaleMovementChangeClient<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosEventSaleMovementChanges.
     * @param {PosEventSaleMovementChangeDeleteManyArgs} args - Arguments to filter PosEventSaleMovementChanges to delete.
     * @example
     * // Delete a few PosEventSaleMovementChanges
     * const { count } = await prisma.posEventSaleMovementChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosEventSaleMovementChangeDeleteManyArgs>(args?: SelectSubset<T, PosEventSaleMovementChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSaleMovementChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosEventSaleMovementChanges
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosEventSaleMovementChangeUpdateManyArgs>(args: SelectSubset<T, PosEventSaleMovementChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSaleMovementChanges and returns the data updated in the database.
     * @param {PosEventSaleMovementChangeUpdateManyAndReturnArgs} args - Arguments to update many PosEventSaleMovementChanges.
     * @example
     * // Update many PosEventSaleMovementChanges
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosEventSaleMovementChanges and only return the `id`
     * const posEventSaleMovementChangeWithIdOnly = await prisma.posEventSaleMovementChange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosEventSaleMovementChangeUpdateManyAndReturnArgs>(args: SelectSubset<T, PosEventSaleMovementChangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosEventSaleMovementChange.
     * @param {PosEventSaleMovementChangeUpsertArgs} args - Arguments to update or create a PosEventSaleMovementChange.
     * @example
     * // Update or create a PosEventSaleMovementChange
     * const posEventSaleMovementChange = await prisma.posEventSaleMovementChange.upsert({
     *   create: {
     *     // ... data to create a PosEventSaleMovementChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosEventSaleMovementChange we want to update
     *   }
     * })
     */
    upsert<T extends PosEventSaleMovementChangeUpsertArgs>(args: SelectSubset<T, PosEventSaleMovementChangeUpsertArgs<ExtArgs>>): Prisma__PosEventSaleMovementChangeClient<$Result.GetResult<Prisma.$PosEventSaleMovementChangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosEventSaleMovementChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementChangeCountArgs} args - Arguments to filter PosEventSaleMovementChanges to count.
     * @example
     * // Count the number of PosEventSaleMovementChanges
     * const count = await prisma.posEventSaleMovementChange.count({
     *   where: {
     *     // ... the filter for the PosEventSaleMovementChanges we want to count
     *   }
     * })
    **/
    count<T extends PosEventSaleMovementChangeCountArgs>(
      args?: Subset<T, PosEventSaleMovementChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosEventSaleMovementChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosEventSaleMovementChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosEventSaleMovementChangeAggregateArgs>(args: Subset<T, PosEventSaleMovementChangeAggregateArgs>): Prisma.PrismaPromise<GetPosEventSaleMovementChangeAggregateType<T>>

    /**
     * Group by PosEventSaleMovementChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleMovementChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosEventSaleMovementChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosEventSaleMovementChangeGroupByArgs['orderBy'] }
        : { orderBy?: PosEventSaleMovementChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosEventSaleMovementChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosEventSaleMovementChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosEventSaleMovementChange model
   */
  readonly fields: PosEventSaleMovementChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosEventSaleMovementChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosEventSaleMovementChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posEventSaleMovement<T extends PosEventSaleMovementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PosEventSaleMovementDefaultArgs<ExtArgs>>): Prisma__PosEventSaleMovementClient<$Result.GetResult<Prisma.$PosEventSaleMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosEventSaleMovementChange model
   */
  interface PosEventSaleMovementChangeFieldRefs {
    readonly id: FieldRef<"PosEventSaleMovementChange", 'String'>
    readonly method: FieldRef<"PosEventSaleMovementChange", 'EPaymentMethod'>
    readonly amount: FieldRef<"PosEventSaleMovementChange", 'Decimal'>
    readonly createdAt: FieldRef<"PosEventSaleMovementChange", 'DateTime'>
    readonly updatedAt: FieldRef<"PosEventSaleMovementChange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PosEventSaleMovementChange findUnique
   */
  export type PosEventSaleMovementChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementChange to fetch.
     */
    where: PosEventSaleMovementChangeWhereUniqueInput
  }

  /**
   * PosEventSaleMovementChange findUniqueOrThrow
   */
  export type PosEventSaleMovementChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementChange to fetch.
     */
    where: PosEventSaleMovementChangeWhereUniqueInput
  }

  /**
   * PosEventSaleMovementChange findFirst
   */
  export type PosEventSaleMovementChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementChange to fetch.
     */
    where?: PosEventSaleMovementChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovementChanges to fetch.
     */
    orderBy?: PosEventSaleMovementChangeOrderByWithRelationInput | PosEventSaleMovementChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSaleMovementChanges.
     */
    cursor?: PosEventSaleMovementChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovementChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovementChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSaleMovementChanges.
     */
    distinct?: PosEventSaleMovementChangeScalarFieldEnum | PosEventSaleMovementChangeScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovementChange findFirstOrThrow
   */
  export type PosEventSaleMovementChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementChange to fetch.
     */
    where?: PosEventSaleMovementChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovementChanges to fetch.
     */
    orderBy?: PosEventSaleMovementChangeOrderByWithRelationInput | PosEventSaleMovementChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSaleMovementChanges.
     */
    cursor?: PosEventSaleMovementChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovementChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovementChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSaleMovementChanges.
     */
    distinct?: PosEventSaleMovementChangeScalarFieldEnum | PosEventSaleMovementChangeScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovementChange findMany
   */
  export type PosEventSaleMovementChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleMovementChanges to fetch.
     */
    where?: PosEventSaleMovementChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleMovementChanges to fetch.
     */
    orderBy?: PosEventSaleMovementChangeOrderByWithRelationInput | PosEventSaleMovementChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosEventSaleMovementChanges.
     */
    cursor?: PosEventSaleMovementChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleMovementChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleMovementChanges.
     */
    skip?: number
    distinct?: PosEventSaleMovementChangeScalarFieldEnum | PosEventSaleMovementChangeScalarFieldEnum[]
  }

  /**
   * PosEventSaleMovementChange create
   */
  export type PosEventSaleMovementChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a PosEventSaleMovementChange.
     */
    data: XOR<PosEventSaleMovementChangeCreateInput, PosEventSaleMovementChangeUncheckedCreateInput>
  }

  /**
   * PosEventSaleMovementChange createMany
   */
  export type PosEventSaleMovementChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosEventSaleMovementChanges.
     */
    data: PosEventSaleMovementChangeCreateManyInput | PosEventSaleMovementChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEventSaleMovementChange createManyAndReturn
   */
  export type PosEventSaleMovementChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * The data used to create many PosEventSaleMovementChanges.
     */
    data: PosEventSaleMovementChangeCreateManyInput | PosEventSaleMovementChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSaleMovementChange update
   */
  export type PosEventSaleMovementChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a PosEventSaleMovementChange.
     */
    data: XOR<PosEventSaleMovementChangeUpdateInput, PosEventSaleMovementChangeUncheckedUpdateInput>
    /**
     * Choose, which PosEventSaleMovementChange to update.
     */
    where: PosEventSaleMovementChangeWhereUniqueInput
  }

  /**
   * PosEventSaleMovementChange updateMany
   */
  export type PosEventSaleMovementChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosEventSaleMovementChanges.
     */
    data: XOR<PosEventSaleMovementChangeUpdateManyMutationInput, PosEventSaleMovementChangeUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSaleMovementChanges to update
     */
    where?: PosEventSaleMovementChangeWhereInput
    /**
     * Limit how many PosEventSaleMovementChanges to update.
     */
    limit?: number
  }

  /**
   * PosEventSaleMovementChange updateManyAndReturn
   */
  export type PosEventSaleMovementChangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * The data used to update PosEventSaleMovementChanges.
     */
    data: XOR<PosEventSaleMovementChangeUpdateManyMutationInput, PosEventSaleMovementChangeUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSaleMovementChanges to update
     */
    where?: PosEventSaleMovementChangeWhereInput
    /**
     * Limit how many PosEventSaleMovementChanges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSaleMovementChange upsert
   */
  export type PosEventSaleMovementChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the PosEventSaleMovementChange to update in case it exists.
     */
    where: PosEventSaleMovementChangeWhereUniqueInput
    /**
     * In case the PosEventSaleMovementChange found by the `where` argument doesn't exist, create a new PosEventSaleMovementChange with this data.
     */
    create: XOR<PosEventSaleMovementChangeCreateInput, PosEventSaleMovementChangeUncheckedCreateInput>
    /**
     * In case the PosEventSaleMovementChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosEventSaleMovementChangeUpdateInput, PosEventSaleMovementChangeUncheckedUpdateInput>
  }

  /**
   * PosEventSaleMovementChange delete
   */
  export type PosEventSaleMovementChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter which PosEventSaleMovementChange to delete.
     */
    where: PosEventSaleMovementChangeWhereUniqueInput
  }

  /**
   * PosEventSaleMovementChange deleteMany
   */
  export type PosEventSaleMovementChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSaleMovementChanges to delete
     */
    where?: PosEventSaleMovementChangeWhereInput
    /**
     * Limit how many PosEventSaleMovementChanges to delete.
     */
    limit?: number
  }

  /**
   * PosEventSaleMovementChange without action
   */
  export type PosEventSaleMovementChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleMovementChange
     */
    select?: PosEventSaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleMovementChange
     */
    omit?: PosEventSaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleMovementChangeInclude<ExtArgs> | null
  }


  /**
   * Model PosEventSaleProduct
   */

  export type AggregatePosEventSaleProduct = {
    _count: PosEventSaleProductCountAggregateOutputType | null
    _avg: PosEventSaleProductAvgAggregateOutputType | null
    _sum: PosEventSaleProductSumAggregateOutputType | null
    _min: PosEventSaleProductMinAggregateOutputType | null
    _max: PosEventSaleProductMaxAggregateOutputType | null
  }

  export type PosEventSaleProductAvgAggregateOutputType = {
    costPrice: Decimal | null
    salePrice: Decimal | null
    totalQty: number | null
  }

  export type PosEventSaleProductSumAggregateOutputType = {
    costPrice: Decimal | null
    salePrice: Decimal | null
    totalQty: number | null
  }

  export type PosEventSaleProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    costPrice: Decimal | null
    salePrice: Decimal | null
    totalQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type PosEventSaleProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    costPrice: Decimal | null
    salePrice: Decimal | null
    totalQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
    productId: string | null
  }

  export type PosEventSaleProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    costPrice: number
    salePrice: number
    totalQty: number
    createdAt: number
    updatedAt: number
    productId: number
    _all: number
  }


  export type PosEventSaleProductAvgAggregateInputType = {
    costPrice?: true
    salePrice?: true
    totalQty?: true
  }

  export type PosEventSaleProductSumAggregateInputType = {
    costPrice?: true
    salePrice?: true
    totalQty?: true
  }

  export type PosEventSaleProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    costPrice?: true
    salePrice?: true
    totalQty?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type PosEventSaleProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    costPrice?: true
    salePrice?: true
    totalQty?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
  }

  export type PosEventSaleProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    costPrice?: true
    salePrice?: true
    totalQty?: true
    createdAt?: true
    updatedAt?: true
    productId?: true
    _all?: true
  }

  export type PosEventSaleProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSaleProduct to aggregate.
     */
    where?: PosEventSaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleProducts to fetch.
     */
    orderBy?: PosEventSaleProductOrderByWithRelationInput | PosEventSaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PosEventSaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PosEventSaleProducts
    **/
    _count?: true | PosEventSaleProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PosEventSaleProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PosEventSaleProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PosEventSaleProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PosEventSaleProductMaxAggregateInputType
  }

  export type GetPosEventSaleProductAggregateType<T extends PosEventSaleProductAggregateArgs> = {
        [P in keyof T & keyof AggregatePosEventSaleProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosEventSaleProduct[P]>
      : GetScalarType<T[P], AggregatePosEventSaleProduct[P]>
  }




  export type PosEventSaleProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PosEventSaleProductWhereInput
    orderBy?: PosEventSaleProductOrderByWithAggregationInput | PosEventSaleProductOrderByWithAggregationInput[]
    by: PosEventSaleProductScalarFieldEnum[] | PosEventSaleProductScalarFieldEnum
    having?: PosEventSaleProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PosEventSaleProductCountAggregateInputType | true
    _avg?: PosEventSaleProductAvgAggregateInputType
    _sum?: PosEventSaleProductSumAggregateInputType
    _min?: PosEventSaleProductMinAggregateInputType
    _max?: PosEventSaleProductMaxAggregateInputType
  }

  export type PosEventSaleProductGroupByOutputType = {
    id: string
    name: string
    description: string
    costPrice: Decimal
    salePrice: Decimal
    totalQty: number
    createdAt: Date
    updatedAt: Date
    productId: string
    _count: PosEventSaleProductCountAggregateOutputType | null
    _avg: PosEventSaleProductAvgAggregateOutputType | null
    _sum: PosEventSaleProductSumAggregateOutputType | null
    _min: PosEventSaleProductMinAggregateOutputType | null
    _max: PosEventSaleProductMaxAggregateOutputType | null
  }

  type GetPosEventSaleProductGroupByPayload<T extends PosEventSaleProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PosEventSaleProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PosEventSaleProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PosEventSaleProductGroupByOutputType[P]>
            : GetScalarType<T[P], PosEventSaleProductGroupByOutputType[P]>
        }
      >
    >


  export type PosEventSaleProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    costPrice?: boolean
    salePrice?: boolean
    totalQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleProduct"]>

  export type PosEventSaleProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    costPrice?: boolean
    salePrice?: boolean
    totalQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleProduct"]>

  export type PosEventSaleProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    costPrice?: boolean
    salePrice?: boolean
    totalQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posEventSaleProduct"]>

  export type PosEventSaleProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    costPrice?: boolean
    salePrice?: boolean
    totalQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productId?: boolean
  }

  export type PosEventSaleProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "costPrice" | "salePrice" | "totalQty" | "createdAt" | "updatedAt" | "productId", ExtArgs["result"]["posEventSaleProduct"]>
  export type PosEventSaleProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PosEventSaleProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type PosEventSaleProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posEventSale?: boolean | PosEventSaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PosEventSaleProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PosEventSaleProduct"
    objects: {
      posEventSale: Prisma.$PosEventSalePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      costPrice: Prisma.Decimal
      salePrice: Prisma.Decimal
      totalQty: number
      createdAt: Date
      updatedAt: Date
      productId: string
    }, ExtArgs["result"]["posEventSaleProduct"]>
    composites: {}
  }

  type PosEventSaleProductGetPayload<S extends boolean | null | undefined | PosEventSaleProductDefaultArgs> = $Result.GetResult<Prisma.$PosEventSaleProductPayload, S>

  type PosEventSaleProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PosEventSaleProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PosEventSaleProductCountAggregateInputType | true
    }

  export interface PosEventSaleProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PosEventSaleProduct'], meta: { name: 'PosEventSaleProduct' } }
    /**
     * Find zero or one PosEventSaleProduct that matches the filter.
     * @param {PosEventSaleProductFindUniqueArgs} args - Arguments to find a PosEventSaleProduct
     * @example
     * // Get one PosEventSaleProduct
     * const posEventSaleProduct = await prisma.posEventSaleProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PosEventSaleProductFindUniqueArgs>(args: SelectSubset<T, PosEventSaleProductFindUniqueArgs<ExtArgs>>): Prisma__PosEventSaleProductClient<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PosEventSaleProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PosEventSaleProductFindUniqueOrThrowArgs} args - Arguments to find a PosEventSaleProduct
     * @example
     * // Get one PosEventSaleProduct
     * const posEventSaleProduct = await prisma.posEventSaleProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PosEventSaleProductFindUniqueOrThrowArgs>(args: SelectSubset<T, PosEventSaleProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleProductClient<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSaleProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleProductFindFirstArgs} args - Arguments to find a PosEventSaleProduct
     * @example
     * // Get one PosEventSaleProduct
     * const posEventSaleProduct = await prisma.posEventSaleProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PosEventSaleProductFindFirstArgs>(args?: SelectSubset<T, PosEventSaleProductFindFirstArgs<ExtArgs>>): Prisma__PosEventSaleProductClient<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PosEventSaleProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleProductFindFirstOrThrowArgs} args - Arguments to find a PosEventSaleProduct
     * @example
     * // Get one PosEventSaleProduct
     * const posEventSaleProduct = await prisma.posEventSaleProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PosEventSaleProductFindFirstOrThrowArgs>(args?: SelectSubset<T, PosEventSaleProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__PosEventSaleProductClient<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PosEventSaleProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PosEventSaleProducts
     * const posEventSaleProducts = await prisma.posEventSaleProduct.findMany()
     * 
     * // Get first 10 PosEventSaleProducts
     * const posEventSaleProducts = await prisma.posEventSaleProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const posEventSaleProductWithIdOnly = await prisma.posEventSaleProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PosEventSaleProductFindManyArgs>(args?: SelectSubset<T, PosEventSaleProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PosEventSaleProduct.
     * @param {PosEventSaleProductCreateArgs} args - Arguments to create a PosEventSaleProduct.
     * @example
     * // Create one PosEventSaleProduct
     * const PosEventSaleProduct = await prisma.posEventSaleProduct.create({
     *   data: {
     *     // ... data to create a PosEventSaleProduct
     *   }
     * })
     * 
     */
    create<T extends PosEventSaleProductCreateArgs>(args: SelectSubset<T, PosEventSaleProductCreateArgs<ExtArgs>>): Prisma__PosEventSaleProductClient<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PosEventSaleProducts.
     * @param {PosEventSaleProductCreateManyArgs} args - Arguments to create many PosEventSaleProducts.
     * @example
     * // Create many PosEventSaleProducts
     * const posEventSaleProduct = await prisma.posEventSaleProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PosEventSaleProductCreateManyArgs>(args?: SelectSubset<T, PosEventSaleProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PosEventSaleProducts and returns the data saved in the database.
     * @param {PosEventSaleProductCreateManyAndReturnArgs} args - Arguments to create many PosEventSaleProducts.
     * @example
     * // Create many PosEventSaleProducts
     * const posEventSaleProduct = await prisma.posEventSaleProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PosEventSaleProducts and only return the `id`
     * const posEventSaleProductWithIdOnly = await prisma.posEventSaleProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PosEventSaleProductCreateManyAndReturnArgs>(args?: SelectSubset<T, PosEventSaleProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PosEventSaleProduct.
     * @param {PosEventSaleProductDeleteArgs} args - Arguments to delete one PosEventSaleProduct.
     * @example
     * // Delete one PosEventSaleProduct
     * const PosEventSaleProduct = await prisma.posEventSaleProduct.delete({
     *   where: {
     *     // ... filter to delete one PosEventSaleProduct
     *   }
     * })
     * 
     */
    delete<T extends PosEventSaleProductDeleteArgs>(args: SelectSubset<T, PosEventSaleProductDeleteArgs<ExtArgs>>): Prisma__PosEventSaleProductClient<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PosEventSaleProduct.
     * @param {PosEventSaleProductUpdateArgs} args - Arguments to update one PosEventSaleProduct.
     * @example
     * // Update one PosEventSaleProduct
     * const posEventSaleProduct = await prisma.posEventSaleProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PosEventSaleProductUpdateArgs>(args: SelectSubset<T, PosEventSaleProductUpdateArgs<ExtArgs>>): Prisma__PosEventSaleProductClient<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PosEventSaleProducts.
     * @param {PosEventSaleProductDeleteManyArgs} args - Arguments to filter PosEventSaleProducts to delete.
     * @example
     * // Delete a few PosEventSaleProducts
     * const { count } = await prisma.posEventSaleProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PosEventSaleProductDeleteManyArgs>(args?: SelectSubset<T, PosEventSaleProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSaleProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PosEventSaleProducts
     * const posEventSaleProduct = await prisma.posEventSaleProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PosEventSaleProductUpdateManyArgs>(args: SelectSubset<T, PosEventSaleProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PosEventSaleProducts and returns the data updated in the database.
     * @param {PosEventSaleProductUpdateManyAndReturnArgs} args - Arguments to update many PosEventSaleProducts.
     * @example
     * // Update many PosEventSaleProducts
     * const posEventSaleProduct = await prisma.posEventSaleProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PosEventSaleProducts and only return the `id`
     * const posEventSaleProductWithIdOnly = await prisma.posEventSaleProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PosEventSaleProductUpdateManyAndReturnArgs>(args: SelectSubset<T, PosEventSaleProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PosEventSaleProduct.
     * @param {PosEventSaleProductUpsertArgs} args - Arguments to update or create a PosEventSaleProduct.
     * @example
     * // Update or create a PosEventSaleProduct
     * const posEventSaleProduct = await prisma.posEventSaleProduct.upsert({
     *   create: {
     *     // ... data to create a PosEventSaleProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PosEventSaleProduct we want to update
     *   }
     * })
     */
    upsert<T extends PosEventSaleProductUpsertArgs>(args: SelectSubset<T, PosEventSaleProductUpsertArgs<ExtArgs>>): Prisma__PosEventSaleProductClient<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PosEventSaleProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleProductCountArgs} args - Arguments to filter PosEventSaleProducts to count.
     * @example
     * // Count the number of PosEventSaleProducts
     * const count = await prisma.posEventSaleProduct.count({
     *   where: {
     *     // ... the filter for the PosEventSaleProducts we want to count
     *   }
     * })
    **/
    count<T extends PosEventSaleProductCountArgs>(
      args?: Subset<T, PosEventSaleProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PosEventSaleProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PosEventSaleProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PosEventSaleProductAggregateArgs>(args: Subset<T, PosEventSaleProductAggregateArgs>): Prisma.PrismaPromise<GetPosEventSaleProductAggregateType<T>>

    /**
     * Group by PosEventSaleProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PosEventSaleProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PosEventSaleProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PosEventSaleProductGroupByArgs['orderBy'] }
        : { orderBy?: PosEventSaleProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PosEventSaleProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPosEventSaleProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PosEventSaleProduct model
   */
  readonly fields: PosEventSaleProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PosEventSaleProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PosEventSaleProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posEventSale<T extends PosEventSaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PosEventSaleDefaultArgs<ExtArgs>>): Prisma__PosEventSaleClient<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PosEventSaleProduct model
   */
  interface PosEventSaleProductFieldRefs {
    readonly id: FieldRef<"PosEventSaleProduct", 'String'>
    readonly name: FieldRef<"PosEventSaleProduct", 'String'>
    readonly description: FieldRef<"PosEventSaleProduct", 'String'>
    readonly costPrice: FieldRef<"PosEventSaleProduct", 'Decimal'>
    readonly salePrice: FieldRef<"PosEventSaleProduct", 'Decimal'>
    readonly totalQty: FieldRef<"PosEventSaleProduct", 'Int'>
    readonly createdAt: FieldRef<"PosEventSaleProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"PosEventSaleProduct", 'DateTime'>
    readonly productId: FieldRef<"PosEventSaleProduct", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PosEventSaleProduct findUnique
   */
  export type PosEventSaleProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleProduct to fetch.
     */
    where: PosEventSaleProductWhereUniqueInput
  }

  /**
   * PosEventSaleProduct findUniqueOrThrow
   */
  export type PosEventSaleProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleProduct to fetch.
     */
    where: PosEventSaleProductWhereUniqueInput
  }

  /**
   * PosEventSaleProduct findFirst
   */
  export type PosEventSaleProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleProduct to fetch.
     */
    where?: PosEventSaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleProducts to fetch.
     */
    orderBy?: PosEventSaleProductOrderByWithRelationInput | PosEventSaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSaleProducts.
     */
    cursor?: PosEventSaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSaleProducts.
     */
    distinct?: PosEventSaleProductScalarFieldEnum | PosEventSaleProductScalarFieldEnum[]
  }

  /**
   * PosEventSaleProduct findFirstOrThrow
   */
  export type PosEventSaleProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleProduct to fetch.
     */
    where?: PosEventSaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleProducts to fetch.
     */
    orderBy?: PosEventSaleProductOrderByWithRelationInput | PosEventSaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PosEventSaleProducts.
     */
    cursor?: PosEventSaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PosEventSaleProducts.
     */
    distinct?: PosEventSaleProductScalarFieldEnum | PosEventSaleProductScalarFieldEnum[]
  }

  /**
   * PosEventSaleProduct findMany
   */
  export type PosEventSaleProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * Filter, which PosEventSaleProducts to fetch.
     */
    where?: PosEventSaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PosEventSaleProducts to fetch.
     */
    orderBy?: PosEventSaleProductOrderByWithRelationInput | PosEventSaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PosEventSaleProducts.
     */
    cursor?: PosEventSaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PosEventSaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PosEventSaleProducts.
     */
    skip?: number
    distinct?: PosEventSaleProductScalarFieldEnum | PosEventSaleProductScalarFieldEnum[]
  }

  /**
   * PosEventSaleProduct create
   */
  export type PosEventSaleProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * The data needed to create a PosEventSaleProduct.
     */
    data: XOR<PosEventSaleProductCreateInput, PosEventSaleProductUncheckedCreateInput>
  }

  /**
   * PosEventSaleProduct createMany
   */
  export type PosEventSaleProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PosEventSaleProducts.
     */
    data: PosEventSaleProductCreateManyInput | PosEventSaleProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PosEventSaleProduct createManyAndReturn
   */
  export type PosEventSaleProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * The data used to create many PosEventSaleProducts.
     */
    data: PosEventSaleProductCreateManyInput | PosEventSaleProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSaleProduct update
   */
  export type PosEventSaleProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * The data needed to update a PosEventSaleProduct.
     */
    data: XOR<PosEventSaleProductUpdateInput, PosEventSaleProductUncheckedUpdateInput>
    /**
     * Choose, which PosEventSaleProduct to update.
     */
    where: PosEventSaleProductWhereUniqueInput
  }

  /**
   * PosEventSaleProduct updateMany
   */
  export type PosEventSaleProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PosEventSaleProducts.
     */
    data: XOR<PosEventSaleProductUpdateManyMutationInput, PosEventSaleProductUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSaleProducts to update
     */
    where?: PosEventSaleProductWhereInput
    /**
     * Limit how many PosEventSaleProducts to update.
     */
    limit?: number
  }

  /**
   * PosEventSaleProduct updateManyAndReturn
   */
  export type PosEventSaleProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * The data used to update PosEventSaleProducts.
     */
    data: XOR<PosEventSaleProductUpdateManyMutationInput, PosEventSaleProductUncheckedUpdateManyInput>
    /**
     * Filter which PosEventSaleProducts to update
     */
    where?: PosEventSaleProductWhereInput
    /**
     * Limit how many PosEventSaleProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PosEventSaleProduct upsert
   */
  export type PosEventSaleProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * The filter to search for the PosEventSaleProduct to update in case it exists.
     */
    where: PosEventSaleProductWhereUniqueInput
    /**
     * In case the PosEventSaleProduct found by the `where` argument doesn't exist, create a new PosEventSaleProduct with this data.
     */
    create: XOR<PosEventSaleProductCreateInput, PosEventSaleProductUncheckedCreateInput>
    /**
     * In case the PosEventSaleProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PosEventSaleProductUpdateInput, PosEventSaleProductUncheckedUpdateInput>
  }

  /**
   * PosEventSaleProduct delete
   */
  export type PosEventSaleProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    /**
     * Filter which PosEventSaleProduct to delete.
     */
    where: PosEventSaleProductWhereUniqueInput
  }

  /**
   * PosEventSaleProduct deleteMany
   */
  export type PosEventSaleProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PosEventSaleProducts to delete
     */
    where?: PosEventSaleProductWhereInput
    /**
     * Limit how many PosEventSaleProducts to delete.
     */
    limit?: number
  }

  /**
   * PosEventSaleProduct without action
   */
  export type PosEventSaleProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    salePrice: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    salePrice: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    barCode: string | null
    internalCode: string | null
    active: boolean | null
    skuCode: string | null
    tenantId: string | null
    salePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    barCode: string | null
    internalCode: string | null
    active: boolean | null
    skuCode: string | null
    tenantId: string | null
    salePrice: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    barCode: number
    internalCode: number
    active: number
    skuCode: number
    tenantId: number
    salePrice: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    salePrice?: true
  }

  export type ProductSumAggregateInputType = {
    salePrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barCode?: true
    internalCode?: true
    active?: true
    skuCode?: true
    tenantId?: true
    salePrice?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barCode?: true
    internalCode?: true
    active?: true
    skuCode?: true
    tenantId?: true
    salePrice?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    barCode?: true
    internalCode?: true
    active?: true
    skuCode?: true
    tenantId?: true
    salePrice?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string
    barCode: string
    internalCode: string
    active: boolean
    skuCode: string
    tenantId: string
    salePrice: Decimal
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    barCode?: boolean
    internalCode?: boolean
    active?: boolean
    skuCode?: boolean
    tenantId?: boolean
    salePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    stock?: boolean | Product$stockArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    saleProducts?: boolean | Product$saleProductsArgs<ExtArgs>
    specifications?: boolean | Product$specificationsArgs<ExtArgs>
    PosEventSaleProduct?: boolean | Product$PosEventSaleProductArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    barCode?: boolean
    internalCode?: boolean
    active?: boolean
    skuCode?: boolean
    tenantId?: boolean
    salePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    barCode?: boolean
    internalCode?: boolean
    active?: boolean
    skuCode?: boolean
    tenantId?: boolean
    salePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    barCode?: boolean
    internalCode?: boolean
    active?: boolean
    skuCode?: boolean
    tenantId?: boolean
    salePrice?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "barCode" | "internalCode" | "active" | "skuCode" | "tenantId" | "salePrice" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | Product$stockArgs<ExtArgs>
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
    saleProducts?: boolean | Product$saleProductsArgs<ExtArgs>
    specifications?: boolean | Product$specificationsArgs<ExtArgs>
    PosEventSaleProduct?: boolean | Product$PosEventSaleProductArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs> | null
      Tenant: Prisma.$TenantPayload<ExtArgs>
      saleProducts: Prisma.$SaleProductPayload<ExtArgs>[]
      specifications: Prisma.$ProductSpecificationPayload<ExtArgs>[]
      PosEventSaleProduct: Prisma.$PosEventSaleProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      barCode: string
      internalCode: string
      active: boolean
      skuCode: string
      tenantId: string
      salePrice: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends Product$stockArgs<ExtArgs> = {}>(args?: Subset<T, Product$stockArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    saleProducts<T extends Product$saleProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$saleProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specifications<T extends Product$specificationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$specificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PosEventSaleProduct<T extends Product$PosEventSaleProductArgs<ExtArgs> = {}>(args?: Subset<T, Product$PosEventSaleProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly barCode: FieldRef<"Product", 'String'>
    readonly internalCode: FieldRef<"Product", 'String'>
    readonly active: FieldRef<"Product", 'Boolean'>
    readonly skuCode: FieldRef<"Product", 'String'>
    readonly tenantId: FieldRef<"Product", 'String'>
    readonly salePrice: FieldRef<"Product", 'Decimal'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.stock
   */
  export type Product$stockArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
  }

  /**
   * Product.saleProducts
   */
  export type Product$saleProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    cursor?: SaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * Product.specifications
   */
  export type Product$specificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    where?: ProductSpecificationWhereInput
    orderBy?: ProductSpecificationOrderByWithRelationInput | ProductSpecificationOrderByWithRelationInput[]
    cursor?: ProductSpecificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductSpecificationScalarFieldEnum | ProductSpecificationScalarFieldEnum[]
  }

  /**
   * Product.PosEventSaleProduct
   */
  export type Product$PosEventSaleProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSaleProduct
     */
    select?: PosEventSaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSaleProduct
     */
    omit?: PosEventSaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleProductInclude<ExtArgs> | null
    where?: PosEventSaleProductWhereInput
    orderBy?: PosEventSaleProductOrderByWithRelationInput | PosEventSaleProductOrderByWithRelationInput[]
    cursor?: PosEventSaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosEventSaleProductScalarFieldEnum | PosEventSaleProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductSpecification
   */

  export type AggregateProductSpecification = {
    _count: ProductSpecificationCountAggregateOutputType | null
    _min: ProductSpecificationMinAggregateOutputType | null
    _max: ProductSpecificationMaxAggregateOutputType | null
  }

  export type ProductSpecificationMinAggregateOutputType = {
    id: string | null
    label: string | null
    value: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductSpecificationMaxAggregateOutputType = {
    id: string | null
    label: string | null
    value: string | null
    productId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductSpecificationCountAggregateOutputType = {
    id: number
    label: number
    value: number
    productId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductSpecificationMinAggregateInputType = {
    id?: true
    label?: true
    value?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductSpecificationMaxAggregateInputType = {
    id?: true
    label?: true
    value?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductSpecificationCountAggregateInputType = {
    id?: true
    label?: true
    value?: true
    productId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductSpecificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSpecification to aggregate.
     */
    where?: ProductSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSpecifications to fetch.
     */
    orderBy?: ProductSpecificationOrderByWithRelationInput | ProductSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductSpecifications
    **/
    _count?: true | ProductSpecificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductSpecificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductSpecificationMaxAggregateInputType
  }

  export type GetProductSpecificationAggregateType<T extends ProductSpecificationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductSpecification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductSpecification[P]>
      : GetScalarType<T[P], AggregateProductSpecification[P]>
  }




  export type ProductSpecificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductSpecificationWhereInput
    orderBy?: ProductSpecificationOrderByWithAggregationInput | ProductSpecificationOrderByWithAggregationInput[]
    by: ProductSpecificationScalarFieldEnum[] | ProductSpecificationScalarFieldEnum
    having?: ProductSpecificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductSpecificationCountAggregateInputType | true
    _min?: ProductSpecificationMinAggregateInputType
    _max?: ProductSpecificationMaxAggregateInputType
  }

  export type ProductSpecificationGroupByOutputType = {
    id: string
    label: string
    value: string
    productId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductSpecificationCountAggregateOutputType | null
    _min: ProductSpecificationMinAggregateOutputType | null
    _max: ProductSpecificationMaxAggregateOutputType | null
  }

  type GetProductSpecificationGroupByPayload<T extends ProductSpecificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductSpecificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductSpecificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductSpecificationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductSpecificationGroupByOutputType[P]>
        }
      >
    >


  export type ProductSpecificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    value?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSpecification"]>

  export type ProductSpecificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    value?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSpecification"]>

  export type ProductSpecificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    value?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productSpecification"]>

  export type ProductSpecificationSelectScalar = {
    id?: boolean
    label?: boolean
    value?: boolean
    productId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductSpecificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "value" | "productId" | "createdAt" | "updatedAt", ExtArgs["result"]["productSpecification"]>
  export type ProductSpecificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductSpecificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductSpecificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductSpecificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductSpecification"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      value: string
      productId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productSpecification"]>
    composites: {}
  }

  type ProductSpecificationGetPayload<S extends boolean | null | undefined | ProductSpecificationDefaultArgs> = $Result.GetResult<Prisma.$ProductSpecificationPayload, S>

  type ProductSpecificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductSpecificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductSpecificationCountAggregateInputType | true
    }

  export interface ProductSpecificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductSpecification'], meta: { name: 'ProductSpecification' } }
    /**
     * Find zero or one ProductSpecification that matches the filter.
     * @param {ProductSpecificationFindUniqueArgs} args - Arguments to find a ProductSpecification
     * @example
     * // Get one ProductSpecification
     * const productSpecification = await prisma.productSpecification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductSpecificationFindUniqueArgs>(args: SelectSubset<T, ProductSpecificationFindUniqueArgs<ExtArgs>>): Prisma__ProductSpecificationClient<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductSpecification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductSpecificationFindUniqueOrThrowArgs} args - Arguments to find a ProductSpecification
     * @example
     * // Get one ProductSpecification
     * const productSpecification = await prisma.productSpecification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductSpecificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductSpecificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductSpecificationClient<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSpecification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSpecificationFindFirstArgs} args - Arguments to find a ProductSpecification
     * @example
     * // Get one ProductSpecification
     * const productSpecification = await prisma.productSpecification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductSpecificationFindFirstArgs>(args?: SelectSubset<T, ProductSpecificationFindFirstArgs<ExtArgs>>): Prisma__ProductSpecificationClient<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductSpecification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSpecificationFindFirstOrThrowArgs} args - Arguments to find a ProductSpecification
     * @example
     * // Get one ProductSpecification
     * const productSpecification = await prisma.productSpecification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductSpecificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductSpecificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductSpecificationClient<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductSpecifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSpecificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductSpecifications
     * const productSpecifications = await prisma.productSpecification.findMany()
     * 
     * // Get first 10 ProductSpecifications
     * const productSpecifications = await prisma.productSpecification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productSpecificationWithIdOnly = await prisma.productSpecification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductSpecificationFindManyArgs>(args?: SelectSubset<T, ProductSpecificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductSpecification.
     * @param {ProductSpecificationCreateArgs} args - Arguments to create a ProductSpecification.
     * @example
     * // Create one ProductSpecification
     * const ProductSpecification = await prisma.productSpecification.create({
     *   data: {
     *     // ... data to create a ProductSpecification
     *   }
     * })
     * 
     */
    create<T extends ProductSpecificationCreateArgs>(args: SelectSubset<T, ProductSpecificationCreateArgs<ExtArgs>>): Prisma__ProductSpecificationClient<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductSpecifications.
     * @param {ProductSpecificationCreateManyArgs} args - Arguments to create many ProductSpecifications.
     * @example
     * // Create many ProductSpecifications
     * const productSpecification = await prisma.productSpecification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductSpecificationCreateManyArgs>(args?: SelectSubset<T, ProductSpecificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductSpecifications and returns the data saved in the database.
     * @param {ProductSpecificationCreateManyAndReturnArgs} args - Arguments to create many ProductSpecifications.
     * @example
     * // Create many ProductSpecifications
     * const productSpecification = await prisma.productSpecification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductSpecifications and only return the `id`
     * const productSpecificationWithIdOnly = await prisma.productSpecification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductSpecificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductSpecificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductSpecification.
     * @param {ProductSpecificationDeleteArgs} args - Arguments to delete one ProductSpecification.
     * @example
     * // Delete one ProductSpecification
     * const ProductSpecification = await prisma.productSpecification.delete({
     *   where: {
     *     // ... filter to delete one ProductSpecification
     *   }
     * })
     * 
     */
    delete<T extends ProductSpecificationDeleteArgs>(args: SelectSubset<T, ProductSpecificationDeleteArgs<ExtArgs>>): Prisma__ProductSpecificationClient<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductSpecification.
     * @param {ProductSpecificationUpdateArgs} args - Arguments to update one ProductSpecification.
     * @example
     * // Update one ProductSpecification
     * const productSpecification = await prisma.productSpecification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductSpecificationUpdateArgs>(args: SelectSubset<T, ProductSpecificationUpdateArgs<ExtArgs>>): Prisma__ProductSpecificationClient<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductSpecifications.
     * @param {ProductSpecificationDeleteManyArgs} args - Arguments to filter ProductSpecifications to delete.
     * @example
     * // Delete a few ProductSpecifications
     * const { count } = await prisma.productSpecification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductSpecificationDeleteManyArgs>(args?: SelectSubset<T, ProductSpecificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSpecifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSpecificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductSpecifications
     * const productSpecification = await prisma.productSpecification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductSpecificationUpdateManyArgs>(args: SelectSubset<T, ProductSpecificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductSpecifications and returns the data updated in the database.
     * @param {ProductSpecificationUpdateManyAndReturnArgs} args - Arguments to update many ProductSpecifications.
     * @example
     * // Update many ProductSpecifications
     * const productSpecification = await prisma.productSpecification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductSpecifications and only return the `id`
     * const productSpecificationWithIdOnly = await prisma.productSpecification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductSpecificationUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductSpecificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductSpecification.
     * @param {ProductSpecificationUpsertArgs} args - Arguments to update or create a ProductSpecification.
     * @example
     * // Update or create a ProductSpecification
     * const productSpecification = await prisma.productSpecification.upsert({
     *   create: {
     *     // ... data to create a ProductSpecification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductSpecification we want to update
     *   }
     * })
     */
    upsert<T extends ProductSpecificationUpsertArgs>(args: SelectSubset<T, ProductSpecificationUpsertArgs<ExtArgs>>): Prisma__ProductSpecificationClient<$Result.GetResult<Prisma.$ProductSpecificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductSpecifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSpecificationCountArgs} args - Arguments to filter ProductSpecifications to count.
     * @example
     * // Count the number of ProductSpecifications
     * const count = await prisma.productSpecification.count({
     *   where: {
     *     // ... the filter for the ProductSpecifications we want to count
     *   }
     * })
    **/
    count<T extends ProductSpecificationCountArgs>(
      args?: Subset<T, ProductSpecificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductSpecificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductSpecification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSpecificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductSpecificationAggregateArgs>(args: Subset<T, ProductSpecificationAggregateArgs>): Prisma.PrismaPromise<GetProductSpecificationAggregateType<T>>

    /**
     * Group by ProductSpecification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductSpecificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductSpecificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductSpecificationGroupByArgs['orderBy'] }
        : { orderBy?: ProductSpecificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductSpecificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductSpecificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductSpecification model
   */
  readonly fields: ProductSpecificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductSpecification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductSpecificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductSpecification model
   */
  interface ProductSpecificationFieldRefs {
    readonly id: FieldRef<"ProductSpecification", 'String'>
    readonly label: FieldRef<"ProductSpecification", 'String'>
    readonly value: FieldRef<"ProductSpecification", 'String'>
    readonly productId: FieldRef<"ProductSpecification", 'String'>
    readonly createdAt: FieldRef<"ProductSpecification", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductSpecification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductSpecification findUnique
   */
  export type ProductSpecificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which ProductSpecification to fetch.
     */
    where: ProductSpecificationWhereUniqueInput
  }

  /**
   * ProductSpecification findUniqueOrThrow
   */
  export type ProductSpecificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which ProductSpecification to fetch.
     */
    where: ProductSpecificationWhereUniqueInput
  }

  /**
   * ProductSpecification findFirst
   */
  export type ProductSpecificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which ProductSpecification to fetch.
     */
    where?: ProductSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSpecifications to fetch.
     */
    orderBy?: ProductSpecificationOrderByWithRelationInput | ProductSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSpecifications.
     */
    cursor?: ProductSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSpecifications.
     */
    distinct?: ProductSpecificationScalarFieldEnum | ProductSpecificationScalarFieldEnum[]
  }

  /**
   * ProductSpecification findFirstOrThrow
   */
  export type ProductSpecificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which ProductSpecification to fetch.
     */
    where?: ProductSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSpecifications to fetch.
     */
    orderBy?: ProductSpecificationOrderByWithRelationInput | ProductSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductSpecifications.
     */
    cursor?: ProductSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSpecifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductSpecifications.
     */
    distinct?: ProductSpecificationScalarFieldEnum | ProductSpecificationScalarFieldEnum[]
  }

  /**
   * ProductSpecification findMany
   */
  export type ProductSpecificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * Filter, which ProductSpecifications to fetch.
     */
    where?: ProductSpecificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductSpecifications to fetch.
     */
    orderBy?: ProductSpecificationOrderByWithRelationInput | ProductSpecificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductSpecifications.
     */
    cursor?: ProductSpecificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductSpecifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductSpecifications.
     */
    skip?: number
    distinct?: ProductSpecificationScalarFieldEnum | ProductSpecificationScalarFieldEnum[]
  }

  /**
   * ProductSpecification create
   */
  export type ProductSpecificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductSpecification.
     */
    data: XOR<ProductSpecificationCreateInput, ProductSpecificationUncheckedCreateInput>
  }

  /**
   * ProductSpecification createMany
   */
  export type ProductSpecificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductSpecifications.
     */
    data: ProductSpecificationCreateManyInput | ProductSpecificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductSpecification createManyAndReturn
   */
  export type ProductSpecificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * The data used to create many ProductSpecifications.
     */
    data: ProductSpecificationCreateManyInput | ProductSpecificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSpecification update
   */
  export type ProductSpecificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductSpecification.
     */
    data: XOR<ProductSpecificationUpdateInput, ProductSpecificationUncheckedUpdateInput>
    /**
     * Choose, which ProductSpecification to update.
     */
    where: ProductSpecificationWhereUniqueInput
  }

  /**
   * ProductSpecification updateMany
   */
  export type ProductSpecificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductSpecifications.
     */
    data: XOR<ProductSpecificationUpdateManyMutationInput, ProductSpecificationUncheckedUpdateManyInput>
    /**
     * Filter which ProductSpecifications to update
     */
    where?: ProductSpecificationWhereInput
    /**
     * Limit how many ProductSpecifications to update.
     */
    limit?: number
  }

  /**
   * ProductSpecification updateManyAndReturn
   */
  export type ProductSpecificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * The data used to update ProductSpecifications.
     */
    data: XOR<ProductSpecificationUpdateManyMutationInput, ProductSpecificationUncheckedUpdateManyInput>
    /**
     * Filter which ProductSpecifications to update
     */
    where?: ProductSpecificationWhereInput
    /**
     * Limit how many ProductSpecifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductSpecification upsert
   */
  export type ProductSpecificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductSpecification to update in case it exists.
     */
    where: ProductSpecificationWhereUniqueInput
    /**
     * In case the ProductSpecification found by the `where` argument doesn't exist, create a new ProductSpecification with this data.
     */
    create: XOR<ProductSpecificationCreateInput, ProductSpecificationUncheckedCreateInput>
    /**
     * In case the ProductSpecification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductSpecificationUpdateInput, ProductSpecificationUncheckedUpdateInput>
  }

  /**
   * ProductSpecification delete
   */
  export type ProductSpecificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
    /**
     * Filter which ProductSpecification to delete.
     */
    where: ProductSpecificationWhereUniqueInput
  }

  /**
   * ProductSpecification deleteMany
   */
  export type ProductSpecificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductSpecifications to delete
     */
    where?: ProductSpecificationWhereInput
    /**
     * Limit how many ProductSpecifications to delete.
     */
    limit?: number
  }

  /**
   * ProductSpecification without action
   */
  export type ProductSpecificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductSpecification
     */
    select?: ProductSpecificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductSpecification
     */
    omit?: ProductSpecificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductSpecificationInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    discountValue: number | null
    paidTotal: Decimal | null
    estimatedTotal: Decimal | null
  }

  export type SaleSumAggregateOutputType = {
    discountValue: number | null
    paidTotal: Decimal | null
    estimatedTotal: Decimal | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    status: $Enums.ESaleStatus | null
    internalCode: string | null
    customerId: string | null
    tenantId: string | null
    discountVariant: $Enums.EDiscountVariant | null
    discountValue: number | null
    paidTotal: Decimal | null
    estimatedTotal: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    status: $Enums.ESaleStatus | null
    internalCode: string | null
    customerId: string | null
    tenantId: string | null
    discountVariant: $Enums.EDiscountVariant | null
    discountValue: number | null
    paidTotal: Decimal | null
    estimatedTotal: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    status: number
    internalCode: number
    customerId: number
    tenantId: number
    discountVariant: number
    discountValue: number
    paidTotal: number
    estimatedTotal: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    discountValue?: true
    paidTotal?: true
    estimatedTotal?: true
  }

  export type SaleSumAggregateInputType = {
    discountValue?: true
    paidTotal?: true
    estimatedTotal?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    status?: true
    internalCode?: true
    customerId?: true
    tenantId?: true
    discountVariant?: true
    discountValue?: true
    paidTotal?: true
    estimatedTotal?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    status?: true
    internalCode?: true
    customerId?: true
    tenantId?: true
    discountVariant?: true
    discountValue?: true
    paidTotal?: true
    estimatedTotal?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    status?: true
    internalCode?: true
    customerId?: true
    tenantId?: true
    discountVariant?: true
    discountValue?: true
    paidTotal?: true
    estimatedTotal?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    status: $Enums.ESaleStatus
    internalCode: string
    customerId: string
    tenantId: string
    discountVariant: $Enums.EDiscountVariant
    discountValue: number
    paidTotal: Decimal
    estimatedTotal: Decimal
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    internalCode?: boolean
    customerId?: boolean
    tenantId?: boolean
    discountVariant?: boolean
    discountValue?: boolean
    paidTotal?: boolean
    estimatedTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    products?: boolean | Sale$productsArgs<ExtArgs>
    movements?: boolean | Sale$movementsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    PosEventSale?: boolean | Sale$PosEventSaleArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    internalCode?: boolean
    customerId?: boolean
    tenantId?: boolean
    discountVariant?: boolean
    discountValue?: boolean
    paidTotal?: boolean
    estimatedTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    internalCode?: boolean
    customerId?: boolean
    tenantId?: boolean
    discountVariant?: boolean
    discountValue?: boolean
    paidTotal?: boolean
    estimatedTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    status?: boolean
    internalCode?: boolean
    customerId?: boolean
    tenantId?: boolean
    discountVariant?: boolean
    discountValue?: boolean
    paidTotal?: boolean
    estimatedTotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "internalCode" | "customerId" | "tenantId" | "discountVariant" | "discountValue" | "paidTotal" | "estimatedTotal" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["sale"]>
  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Sale$productsArgs<ExtArgs>
    movements?: boolean | Sale$movementsArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    PosEventSale?: boolean | Sale$PosEventSaleArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type SaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      products: Prisma.$SaleProductPayload<ExtArgs>[]
      movements: Prisma.$SaleMovementPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      PosEventSale: Prisma.$PosEventSalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.ESaleStatus
      internalCode: string
      customerId: string
      tenantId: string
      discountVariant: $Enums.EDiscountVariant
      discountValue: number
      paidTotal: Prisma.Decimal
      estimatedTotal: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {SaleUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Sale$productsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    movements<T extends Sale$movementsArgs<ExtArgs> = {}>(args?: Subset<T, Sale$movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    PosEventSale<T extends Sale$PosEventSaleArgs<ExtArgs> = {}>(args?: Subset<T, Sale$PosEventSaleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PosEventSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly status: FieldRef<"Sale", 'ESaleStatus'>
    readonly internalCode: FieldRef<"Sale", 'String'>
    readonly customerId: FieldRef<"Sale", 'String'>
    readonly tenantId: FieldRef<"Sale", 'String'>
    readonly discountVariant: FieldRef<"Sale", 'EDiscountVariant'>
    readonly discountValue: FieldRef<"Sale", 'Float'>
    readonly paidTotal: FieldRef<"Sale", 'Decimal'>
    readonly estimatedTotal: FieldRef<"Sale", 'Decimal'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
    readonly updatedAt: FieldRef<"Sale", 'DateTime'>
    readonly deletedAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sale updateManyAndReturn
   */
  export type SaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sale.products
   */
  export type Sale$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    cursor?: SaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * Sale.movements
   */
  export type Sale$movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    where?: SaleMovementWhereInput
    orderBy?: SaleMovementOrderByWithRelationInput | SaleMovementOrderByWithRelationInput[]
    cursor?: SaleMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleMovementScalarFieldEnum | SaleMovementScalarFieldEnum[]
  }

  /**
   * Sale.PosEventSale
   */
  export type Sale$PosEventSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PosEventSale
     */
    select?: PosEventSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PosEventSale
     */
    omit?: PosEventSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PosEventSaleInclude<ExtArgs> | null
    where?: PosEventSaleWhereInput
    orderBy?: PosEventSaleOrderByWithRelationInput | PosEventSaleOrderByWithRelationInput[]
    cursor?: PosEventSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PosEventSaleScalarFieldEnum | PosEventSaleScalarFieldEnum[]
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleMovement
   */

  export type AggregateSaleMovement = {
    _count: SaleMovementCountAggregateOutputType | null
    _min: SaleMovementMinAggregateOutputType | null
    _max: SaleMovementMaxAggregateOutputType | null
  }

  export type SaleMovementMinAggregateOutputType = {
    id: string | null
    type: $Enums.ESaleMovementType | null
    createdAt: Date | null
    updatedAt: Date | null
    saleId: string | null
  }

  export type SaleMovementMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ESaleMovementType | null
    createdAt: Date | null
    updatedAt: Date | null
    saleId: string | null
  }

  export type SaleMovementCountAggregateOutputType = {
    id: number
    type: number
    createdAt: number
    updatedAt: number
    saleId: number
    _all: number
  }


  export type SaleMovementMinAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    saleId?: true
  }

  export type SaleMovementMaxAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    saleId?: true
  }

  export type SaleMovementCountAggregateInputType = {
    id?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    saleId?: true
    _all?: true
  }

  export type SaleMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleMovement to aggregate.
     */
    where?: SaleMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovements to fetch.
     */
    orderBy?: SaleMovementOrderByWithRelationInput | SaleMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleMovements
    **/
    _count?: true | SaleMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMovementMaxAggregateInputType
  }

  export type GetSaleMovementAggregateType<T extends SaleMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleMovement[P]>
      : GetScalarType<T[P], AggregateSaleMovement[P]>
  }




  export type SaleMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleMovementWhereInput
    orderBy?: SaleMovementOrderByWithAggregationInput | SaleMovementOrderByWithAggregationInput[]
    by: SaleMovementScalarFieldEnum[] | SaleMovementScalarFieldEnum
    having?: SaleMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleMovementCountAggregateInputType | true
    _min?: SaleMovementMinAggregateInputType
    _max?: SaleMovementMaxAggregateInputType
  }

  export type SaleMovementGroupByOutputType = {
    id: string
    type: $Enums.ESaleMovementType
    createdAt: Date
    updatedAt: Date
    saleId: string
    _count: SaleMovementCountAggregateOutputType | null
    _min: SaleMovementMinAggregateOutputType | null
    _max: SaleMovementMaxAggregateOutputType | null
  }

  type GetSaleMovementGroupByPayload<T extends SaleMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleMovementGroupByOutputType[P]>
            : GetScalarType<T[P], SaleMovementGroupByOutputType[P]>
        }
      >
    >


  export type SaleMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    payments?: boolean | SaleMovement$paymentsArgs<ExtArgs>
    changes?: boolean | SaleMovement$changesArgs<ExtArgs>
    _count?: boolean | SaleMovementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovement"]>

  export type SaleMovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovement"]>

  export type SaleMovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovement"]>

  export type SaleMovementSelectScalar = {
    id?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleId?: boolean
  }

  export type SaleMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "createdAt" | "updatedAt" | "saleId", ExtArgs["result"]["saleMovement"]>
  export type SaleMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    payments?: boolean | SaleMovement$paymentsArgs<ExtArgs>
    changes?: boolean | SaleMovement$changesArgs<ExtArgs>
    _count?: boolean | SaleMovementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleMovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }
  export type SaleMovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
  }

  export type $SaleMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleMovement"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      payments: Prisma.$SaleMovementPaymentPayload<ExtArgs>[]
      changes: Prisma.$SaleMovementChangePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ESaleMovementType
      createdAt: Date
      updatedAt: Date
      saleId: string
    }, ExtArgs["result"]["saleMovement"]>
    composites: {}
  }

  type SaleMovementGetPayload<S extends boolean | null | undefined | SaleMovementDefaultArgs> = $Result.GetResult<Prisma.$SaleMovementPayload, S>

  type SaleMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleMovementCountAggregateInputType | true
    }

  export interface SaleMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleMovement'], meta: { name: 'SaleMovement' } }
    /**
     * Find zero or one SaleMovement that matches the filter.
     * @param {SaleMovementFindUniqueArgs} args - Arguments to find a SaleMovement
     * @example
     * // Get one SaleMovement
     * const saleMovement = await prisma.saleMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleMovementFindUniqueArgs>(args: SelectSubset<T, SaleMovementFindUniqueArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleMovementFindUniqueOrThrowArgs} args - Arguments to find a SaleMovement
     * @example
     * // Get one SaleMovement
     * const saleMovement = await prisma.saleMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementFindFirstArgs} args - Arguments to find a SaleMovement
     * @example
     * // Get one SaleMovement
     * const saleMovement = await prisma.saleMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleMovementFindFirstArgs>(args?: SelectSubset<T, SaleMovementFindFirstArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementFindFirstOrThrowArgs} args - Arguments to find a SaleMovement
     * @example
     * // Get one SaleMovement
     * const saleMovement = await prisma.saleMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleMovements
     * const saleMovements = await prisma.saleMovement.findMany()
     * 
     * // Get first 10 SaleMovements
     * const saleMovements = await prisma.saleMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleMovementWithIdOnly = await prisma.saleMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleMovementFindManyArgs>(args?: SelectSubset<T, SaleMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleMovement.
     * @param {SaleMovementCreateArgs} args - Arguments to create a SaleMovement.
     * @example
     * // Create one SaleMovement
     * const SaleMovement = await prisma.saleMovement.create({
     *   data: {
     *     // ... data to create a SaleMovement
     *   }
     * })
     * 
     */
    create<T extends SaleMovementCreateArgs>(args: SelectSubset<T, SaleMovementCreateArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleMovements.
     * @param {SaleMovementCreateManyArgs} args - Arguments to create many SaleMovements.
     * @example
     * // Create many SaleMovements
     * const saleMovement = await prisma.saleMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleMovementCreateManyArgs>(args?: SelectSubset<T, SaleMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleMovements and returns the data saved in the database.
     * @param {SaleMovementCreateManyAndReturnArgs} args - Arguments to create many SaleMovements.
     * @example
     * // Create many SaleMovements
     * const saleMovement = await prisma.saleMovement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleMovements and only return the `id`
     * const saleMovementWithIdOnly = await prisma.saleMovement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleMovementCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleMovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleMovement.
     * @param {SaleMovementDeleteArgs} args - Arguments to delete one SaleMovement.
     * @example
     * // Delete one SaleMovement
     * const SaleMovement = await prisma.saleMovement.delete({
     *   where: {
     *     // ... filter to delete one SaleMovement
     *   }
     * })
     * 
     */
    delete<T extends SaleMovementDeleteArgs>(args: SelectSubset<T, SaleMovementDeleteArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleMovement.
     * @param {SaleMovementUpdateArgs} args - Arguments to update one SaleMovement.
     * @example
     * // Update one SaleMovement
     * const saleMovement = await prisma.saleMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleMovementUpdateArgs>(args: SelectSubset<T, SaleMovementUpdateArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleMovements.
     * @param {SaleMovementDeleteManyArgs} args - Arguments to filter SaleMovements to delete.
     * @example
     * // Delete a few SaleMovements
     * const { count } = await prisma.saleMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleMovementDeleteManyArgs>(args?: SelectSubset<T, SaleMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleMovements
     * const saleMovement = await prisma.saleMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleMovementUpdateManyArgs>(args: SelectSubset<T, SaleMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleMovements and returns the data updated in the database.
     * @param {SaleMovementUpdateManyAndReturnArgs} args - Arguments to update many SaleMovements.
     * @example
     * // Update many SaleMovements
     * const saleMovement = await prisma.saleMovement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleMovements and only return the `id`
     * const saleMovementWithIdOnly = await prisma.saleMovement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleMovementUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleMovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleMovement.
     * @param {SaleMovementUpsertArgs} args - Arguments to update or create a SaleMovement.
     * @example
     * // Update or create a SaleMovement
     * const saleMovement = await prisma.saleMovement.upsert({
     *   create: {
     *     // ... data to create a SaleMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleMovement we want to update
     *   }
     * })
     */
    upsert<T extends SaleMovementUpsertArgs>(args: SelectSubset<T, SaleMovementUpsertArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementCountArgs} args - Arguments to filter SaleMovements to count.
     * @example
     * // Count the number of SaleMovements
     * const count = await prisma.saleMovement.count({
     *   where: {
     *     // ... the filter for the SaleMovements we want to count
     *   }
     * })
    **/
    count<T extends SaleMovementCountArgs>(
      args?: Subset<T, SaleMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleMovementAggregateArgs>(args: Subset<T, SaleMovementAggregateArgs>): Prisma.PrismaPromise<GetSaleMovementAggregateType<T>>

    /**
     * Group by SaleMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleMovementGroupByArgs['orderBy'] }
        : { orderBy?: SaleMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleMovement model
   */
  readonly fields: SaleMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends SaleMovement$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, SaleMovement$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changes<T extends SaleMovement$changesArgs<ExtArgs> = {}>(args?: Subset<T, SaleMovement$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleMovement model
   */
  interface SaleMovementFieldRefs {
    readonly id: FieldRef<"SaleMovement", 'String'>
    readonly type: FieldRef<"SaleMovement", 'ESaleMovementType'>
    readonly createdAt: FieldRef<"SaleMovement", 'DateTime'>
    readonly updatedAt: FieldRef<"SaleMovement", 'DateTime'>
    readonly saleId: FieldRef<"SaleMovement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SaleMovement findUnique
   */
  export type SaleMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovement to fetch.
     */
    where: SaleMovementWhereUniqueInput
  }

  /**
   * SaleMovement findUniqueOrThrow
   */
  export type SaleMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovement to fetch.
     */
    where: SaleMovementWhereUniqueInput
  }

  /**
   * SaleMovement findFirst
   */
  export type SaleMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovement to fetch.
     */
    where?: SaleMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovements to fetch.
     */
    orderBy?: SaleMovementOrderByWithRelationInput | SaleMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleMovements.
     */
    cursor?: SaleMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleMovements.
     */
    distinct?: SaleMovementScalarFieldEnum | SaleMovementScalarFieldEnum[]
  }

  /**
   * SaleMovement findFirstOrThrow
   */
  export type SaleMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovement to fetch.
     */
    where?: SaleMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovements to fetch.
     */
    orderBy?: SaleMovementOrderByWithRelationInput | SaleMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleMovements.
     */
    cursor?: SaleMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleMovements.
     */
    distinct?: SaleMovementScalarFieldEnum | SaleMovementScalarFieldEnum[]
  }

  /**
   * SaleMovement findMany
   */
  export type SaleMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovements to fetch.
     */
    where?: SaleMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovements to fetch.
     */
    orderBy?: SaleMovementOrderByWithRelationInput | SaleMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleMovements.
     */
    cursor?: SaleMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovements.
     */
    skip?: number
    distinct?: SaleMovementScalarFieldEnum | SaleMovementScalarFieldEnum[]
  }

  /**
   * SaleMovement create
   */
  export type SaleMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleMovement.
     */
    data: XOR<SaleMovementCreateInput, SaleMovementUncheckedCreateInput>
  }

  /**
   * SaleMovement createMany
   */
  export type SaleMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleMovements.
     */
    data: SaleMovementCreateManyInput | SaleMovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleMovement createManyAndReturn
   */
  export type SaleMovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * The data used to create many SaleMovements.
     */
    data: SaleMovementCreateManyInput | SaleMovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleMovement update
   */
  export type SaleMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleMovement.
     */
    data: XOR<SaleMovementUpdateInput, SaleMovementUncheckedUpdateInput>
    /**
     * Choose, which SaleMovement to update.
     */
    where: SaleMovementWhereUniqueInput
  }

  /**
   * SaleMovement updateMany
   */
  export type SaleMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleMovements.
     */
    data: XOR<SaleMovementUpdateManyMutationInput, SaleMovementUncheckedUpdateManyInput>
    /**
     * Filter which SaleMovements to update
     */
    where?: SaleMovementWhereInput
    /**
     * Limit how many SaleMovements to update.
     */
    limit?: number
  }

  /**
   * SaleMovement updateManyAndReturn
   */
  export type SaleMovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * The data used to update SaleMovements.
     */
    data: XOR<SaleMovementUpdateManyMutationInput, SaleMovementUncheckedUpdateManyInput>
    /**
     * Filter which SaleMovements to update
     */
    where?: SaleMovementWhereInput
    /**
     * Limit how many SaleMovements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleMovement upsert
   */
  export type SaleMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleMovement to update in case it exists.
     */
    where: SaleMovementWhereUniqueInput
    /**
     * In case the SaleMovement found by the `where` argument doesn't exist, create a new SaleMovement with this data.
     */
    create: XOR<SaleMovementCreateInput, SaleMovementUncheckedCreateInput>
    /**
     * In case the SaleMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleMovementUpdateInput, SaleMovementUncheckedUpdateInput>
  }

  /**
   * SaleMovement delete
   */
  export type SaleMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
    /**
     * Filter which SaleMovement to delete.
     */
    where: SaleMovementWhereUniqueInput
  }

  /**
   * SaleMovement deleteMany
   */
  export type SaleMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleMovements to delete
     */
    where?: SaleMovementWhereInput
    /**
     * Limit how many SaleMovements to delete.
     */
    limit?: number
  }

  /**
   * SaleMovement.payments
   */
  export type SaleMovement$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    where?: SaleMovementPaymentWhereInput
    orderBy?: SaleMovementPaymentOrderByWithRelationInput | SaleMovementPaymentOrderByWithRelationInput[]
    cursor?: SaleMovementPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleMovementPaymentScalarFieldEnum | SaleMovementPaymentScalarFieldEnum[]
  }

  /**
   * SaleMovement.changes
   */
  export type SaleMovement$changesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    where?: SaleMovementChangeWhereInput
    orderBy?: SaleMovementChangeOrderByWithRelationInput | SaleMovementChangeOrderByWithRelationInput[]
    cursor?: SaleMovementChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleMovementChangeScalarFieldEnum | SaleMovementChangeScalarFieldEnum[]
  }

  /**
   * SaleMovement without action
   */
  export type SaleMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovement
     */
    select?: SaleMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovement
     */
    omit?: SaleMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementInclude<ExtArgs> | null
  }


  /**
   * Model SaleMovementPayment
   */

  export type AggregateSaleMovementPayment = {
    _count: SaleMovementPaymentCountAggregateOutputType | null
    _avg: SaleMovementPaymentAvgAggregateOutputType | null
    _sum: SaleMovementPaymentSumAggregateOutputType | null
    _min: SaleMovementPaymentMinAggregateOutputType | null
    _max: SaleMovementPaymentMaxAggregateOutputType | null
  }

  export type SaleMovementPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SaleMovementPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SaleMovementPaymentMinAggregateOutputType = {
    id: string | null
    method: $Enums.EPaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMovementPaymentMaxAggregateOutputType = {
    id: string | null
    method: $Enums.EPaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMovementPaymentCountAggregateOutputType = {
    id: number
    method: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleMovementPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type SaleMovementPaymentSumAggregateInputType = {
    amount?: true
  }

  export type SaleMovementPaymentMinAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMovementPaymentMaxAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMovementPaymentCountAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleMovementPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleMovementPayment to aggregate.
     */
    where?: SaleMovementPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovementPayments to fetch.
     */
    orderBy?: SaleMovementPaymentOrderByWithRelationInput | SaleMovementPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleMovementPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovementPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovementPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleMovementPayments
    **/
    _count?: true | SaleMovementPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleMovementPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleMovementPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMovementPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMovementPaymentMaxAggregateInputType
  }

  export type GetSaleMovementPaymentAggregateType<T extends SaleMovementPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleMovementPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleMovementPayment[P]>
      : GetScalarType<T[P], AggregateSaleMovementPayment[P]>
  }




  export type SaleMovementPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleMovementPaymentWhereInput
    orderBy?: SaleMovementPaymentOrderByWithAggregationInput | SaleMovementPaymentOrderByWithAggregationInput[]
    by: SaleMovementPaymentScalarFieldEnum[] | SaleMovementPaymentScalarFieldEnum
    having?: SaleMovementPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleMovementPaymentCountAggregateInputType | true
    _avg?: SaleMovementPaymentAvgAggregateInputType
    _sum?: SaleMovementPaymentSumAggregateInputType
    _min?: SaleMovementPaymentMinAggregateInputType
    _max?: SaleMovementPaymentMaxAggregateInputType
  }

  export type SaleMovementPaymentGroupByOutputType = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: SaleMovementPaymentCountAggregateOutputType | null
    _avg: SaleMovementPaymentAvgAggregateOutputType | null
    _sum: SaleMovementPaymentSumAggregateOutputType | null
    _min: SaleMovementPaymentMinAggregateOutputType | null
    _max: SaleMovementPaymentMaxAggregateOutputType | null
  }

  type GetSaleMovementPaymentGroupByPayload<T extends SaleMovementPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleMovementPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleMovementPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleMovementPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SaleMovementPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SaleMovementPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovementPayment"]>

  export type SaleMovementPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovementPayment"]>

  export type SaleMovementPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovementPayment"]>

  export type SaleMovementPaymentSelectScalar = {
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleMovementPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "method" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["saleMovementPayment"]>
  export type SaleMovementPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }
  export type SaleMovementPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }
  export type SaleMovementPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }

  export type $SaleMovementPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleMovementPayment"
    objects: {
      saleMovement: Prisma.$SaleMovementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      method: $Enums.EPaymentMethod
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saleMovementPayment"]>
    composites: {}
  }

  type SaleMovementPaymentGetPayload<S extends boolean | null | undefined | SaleMovementPaymentDefaultArgs> = $Result.GetResult<Prisma.$SaleMovementPaymentPayload, S>

  type SaleMovementPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleMovementPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleMovementPaymentCountAggregateInputType | true
    }

  export interface SaleMovementPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleMovementPayment'], meta: { name: 'SaleMovementPayment' } }
    /**
     * Find zero or one SaleMovementPayment that matches the filter.
     * @param {SaleMovementPaymentFindUniqueArgs} args - Arguments to find a SaleMovementPayment
     * @example
     * // Get one SaleMovementPayment
     * const saleMovementPayment = await prisma.saleMovementPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleMovementPaymentFindUniqueArgs>(args: SelectSubset<T, SaleMovementPaymentFindUniqueArgs<ExtArgs>>): Prisma__SaleMovementPaymentClient<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleMovementPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleMovementPaymentFindUniqueOrThrowArgs} args - Arguments to find a SaleMovementPayment
     * @example
     * // Get one SaleMovementPayment
     * const saleMovementPayment = await prisma.saleMovementPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleMovementPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleMovementPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleMovementPaymentClient<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleMovementPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementPaymentFindFirstArgs} args - Arguments to find a SaleMovementPayment
     * @example
     * // Get one SaleMovementPayment
     * const saleMovementPayment = await prisma.saleMovementPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleMovementPaymentFindFirstArgs>(args?: SelectSubset<T, SaleMovementPaymentFindFirstArgs<ExtArgs>>): Prisma__SaleMovementPaymentClient<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleMovementPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementPaymentFindFirstOrThrowArgs} args - Arguments to find a SaleMovementPayment
     * @example
     * // Get one SaleMovementPayment
     * const saleMovementPayment = await prisma.saleMovementPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleMovementPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleMovementPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleMovementPaymentClient<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleMovementPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleMovementPayments
     * const saleMovementPayments = await prisma.saleMovementPayment.findMany()
     * 
     * // Get first 10 SaleMovementPayments
     * const saleMovementPayments = await prisma.saleMovementPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleMovementPaymentWithIdOnly = await prisma.saleMovementPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleMovementPaymentFindManyArgs>(args?: SelectSubset<T, SaleMovementPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleMovementPayment.
     * @param {SaleMovementPaymentCreateArgs} args - Arguments to create a SaleMovementPayment.
     * @example
     * // Create one SaleMovementPayment
     * const SaleMovementPayment = await prisma.saleMovementPayment.create({
     *   data: {
     *     // ... data to create a SaleMovementPayment
     *   }
     * })
     * 
     */
    create<T extends SaleMovementPaymentCreateArgs>(args: SelectSubset<T, SaleMovementPaymentCreateArgs<ExtArgs>>): Prisma__SaleMovementPaymentClient<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleMovementPayments.
     * @param {SaleMovementPaymentCreateManyArgs} args - Arguments to create many SaleMovementPayments.
     * @example
     * // Create many SaleMovementPayments
     * const saleMovementPayment = await prisma.saleMovementPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleMovementPaymentCreateManyArgs>(args?: SelectSubset<T, SaleMovementPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleMovementPayments and returns the data saved in the database.
     * @param {SaleMovementPaymentCreateManyAndReturnArgs} args - Arguments to create many SaleMovementPayments.
     * @example
     * // Create many SaleMovementPayments
     * const saleMovementPayment = await prisma.saleMovementPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleMovementPayments and only return the `id`
     * const saleMovementPaymentWithIdOnly = await prisma.saleMovementPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleMovementPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleMovementPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleMovementPayment.
     * @param {SaleMovementPaymentDeleteArgs} args - Arguments to delete one SaleMovementPayment.
     * @example
     * // Delete one SaleMovementPayment
     * const SaleMovementPayment = await prisma.saleMovementPayment.delete({
     *   where: {
     *     // ... filter to delete one SaleMovementPayment
     *   }
     * })
     * 
     */
    delete<T extends SaleMovementPaymentDeleteArgs>(args: SelectSubset<T, SaleMovementPaymentDeleteArgs<ExtArgs>>): Prisma__SaleMovementPaymentClient<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleMovementPayment.
     * @param {SaleMovementPaymentUpdateArgs} args - Arguments to update one SaleMovementPayment.
     * @example
     * // Update one SaleMovementPayment
     * const saleMovementPayment = await prisma.saleMovementPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleMovementPaymentUpdateArgs>(args: SelectSubset<T, SaleMovementPaymentUpdateArgs<ExtArgs>>): Prisma__SaleMovementPaymentClient<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleMovementPayments.
     * @param {SaleMovementPaymentDeleteManyArgs} args - Arguments to filter SaleMovementPayments to delete.
     * @example
     * // Delete a few SaleMovementPayments
     * const { count } = await prisma.saleMovementPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleMovementPaymentDeleteManyArgs>(args?: SelectSubset<T, SaleMovementPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleMovementPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleMovementPayments
     * const saleMovementPayment = await prisma.saleMovementPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleMovementPaymentUpdateManyArgs>(args: SelectSubset<T, SaleMovementPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleMovementPayments and returns the data updated in the database.
     * @param {SaleMovementPaymentUpdateManyAndReturnArgs} args - Arguments to update many SaleMovementPayments.
     * @example
     * // Update many SaleMovementPayments
     * const saleMovementPayment = await prisma.saleMovementPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleMovementPayments and only return the `id`
     * const saleMovementPaymentWithIdOnly = await prisma.saleMovementPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleMovementPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleMovementPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleMovementPayment.
     * @param {SaleMovementPaymentUpsertArgs} args - Arguments to update or create a SaleMovementPayment.
     * @example
     * // Update or create a SaleMovementPayment
     * const saleMovementPayment = await prisma.saleMovementPayment.upsert({
     *   create: {
     *     // ... data to create a SaleMovementPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleMovementPayment we want to update
     *   }
     * })
     */
    upsert<T extends SaleMovementPaymentUpsertArgs>(args: SelectSubset<T, SaleMovementPaymentUpsertArgs<ExtArgs>>): Prisma__SaleMovementPaymentClient<$Result.GetResult<Prisma.$SaleMovementPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleMovementPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementPaymentCountArgs} args - Arguments to filter SaleMovementPayments to count.
     * @example
     * // Count the number of SaleMovementPayments
     * const count = await prisma.saleMovementPayment.count({
     *   where: {
     *     // ... the filter for the SaleMovementPayments we want to count
     *   }
     * })
    **/
    count<T extends SaleMovementPaymentCountArgs>(
      args?: Subset<T, SaleMovementPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleMovementPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleMovementPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleMovementPaymentAggregateArgs>(args: Subset<T, SaleMovementPaymentAggregateArgs>): Prisma.PrismaPromise<GetSaleMovementPaymentAggregateType<T>>

    /**
     * Group by SaleMovementPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleMovementPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleMovementPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SaleMovementPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleMovementPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleMovementPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleMovementPayment model
   */
  readonly fields: SaleMovementPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleMovementPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleMovementPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saleMovement<T extends SaleMovementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleMovementDefaultArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleMovementPayment model
   */
  interface SaleMovementPaymentFieldRefs {
    readonly id: FieldRef<"SaleMovementPayment", 'String'>
    readonly method: FieldRef<"SaleMovementPayment", 'EPaymentMethod'>
    readonly amount: FieldRef<"SaleMovementPayment", 'Decimal'>
    readonly createdAt: FieldRef<"SaleMovementPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"SaleMovementPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleMovementPayment findUnique
   */
  export type SaleMovementPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementPayment to fetch.
     */
    where: SaleMovementPaymentWhereUniqueInput
  }

  /**
   * SaleMovementPayment findUniqueOrThrow
   */
  export type SaleMovementPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementPayment to fetch.
     */
    where: SaleMovementPaymentWhereUniqueInput
  }

  /**
   * SaleMovementPayment findFirst
   */
  export type SaleMovementPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementPayment to fetch.
     */
    where?: SaleMovementPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovementPayments to fetch.
     */
    orderBy?: SaleMovementPaymentOrderByWithRelationInput | SaleMovementPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleMovementPayments.
     */
    cursor?: SaleMovementPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovementPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovementPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleMovementPayments.
     */
    distinct?: SaleMovementPaymentScalarFieldEnum | SaleMovementPaymentScalarFieldEnum[]
  }

  /**
   * SaleMovementPayment findFirstOrThrow
   */
  export type SaleMovementPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementPayment to fetch.
     */
    where?: SaleMovementPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovementPayments to fetch.
     */
    orderBy?: SaleMovementPaymentOrderByWithRelationInput | SaleMovementPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleMovementPayments.
     */
    cursor?: SaleMovementPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovementPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovementPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleMovementPayments.
     */
    distinct?: SaleMovementPaymentScalarFieldEnum | SaleMovementPaymentScalarFieldEnum[]
  }

  /**
   * SaleMovementPayment findMany
   */
  export type SaleMovementPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementPayments to fetch.
     */
    where?: SaleMovementPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovementPayments to fetch.
     */
    orderBy?: SaleMovementPaymentOrderByWithRelationInput | SaleMovementPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleMovementPayments.
     */
    cursor?: SaleMovementPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovementPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovementPayments.
     */
    skip?: number
    distinct?: SaleMovementPaymentScalarFieldEnum | SaleMovementPaymentScalarFieldEnum[]
  }

  /**
   * SaleMovementPayment create
   */
  export type SaleMovementPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleMovementPayment.
     */
    data: XOR<SaleMovementPaymentCreateInput, SaleMovementPaymentUncheckedCreateInput>
  }

  /**
   * SaleMovementPayment createMany
   */
  export type SaleMovementPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleMovementPayments.
     */
    data: SaleMovementPaymentCreateManyInput | SaleMovementPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleMovementPayment createManyAndReturn
   */
  export type SaleMovementPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many SaleMovementPayments.
     */
    data: SaleMovementPaymentCreateManyInput | SaleMovementPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleMovementPayment update
   */
  export type SaleMovementPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleMovementPayment.
     */
    data: XOR<SaleMovementPaymentUpdateInput, SaleMovementPaymentUncheckedUpdateInput>
    /**
     * Choose, which SaleMovementPayment to update.
     */
    where: SaleMovementPaymentWhereUniqueInput
  }

  /**
   * SaleMovementPayment updateMany
   */
  export type SaleMovementPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleMovementPayments.
     */
    data: XOR<SaleMovementPaymentUpdateManyMutationInput, SaleMovementPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SaleMovementPayments to update
     */
    where?: SaleMovementPaymentWhereInput
    /**
     * Limit how many SaleMovementPayments to update.
     */
    limit?: number
  }

  /**
   * SaleMovementPayment updateManyAndReturn
   */
  export type SaleMovementPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * The data used to update SaleMovementPayments.
     */
    data: XOR<SaleMovementPaymentUpdateManyMutationInput, SaleMovementPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SaleMovementPayments to update
     */
    where?: SaleMovementPaymentWhereInput
    /**
     * Limit how many SaleMovementPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleMovementPayment upsert
   */
  export type SaleMovementPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleMovementPayment to update in case it exists.
     */
    where: SaleMovementPaymentWhereUniqueInput
    /**
     * In case the SaleMovementPayment found by the `where` argument doesn't exist, create a new SaleMovementPayment with this data.
     */
    create: XOR<SaleMovementPaymentCreateInput, SaleMovementPaymentUncheckedCreateInput>
    /**
     * In case the SaleMovementPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleMovementPaymentUpdateInput, SaleMovementPaymentUncheckedUpdateInput>
  }

  /**
   * SaleMovementPayment delete
   */
  export type SaleMovementPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
    /**
     * Filter which SaleMovementPayment to delete.
     */
    where: SaleMovementPaymentWhereUniqueInput
  }

  /**
   * SaleMovementPayment deleteMany
   */
  export type SaleMovementPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleMovementPayments to delete
     */
    where?: SaleMovementPaymentWhereInput
    /**
     * Limit how many SaleMovementPayments to delete.
     */
    limit?: number
  }

  /**
   * SaleMovementPayment without action
   */
  export type SaleMovementPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementPayment
     */
    select?: SaleMovementPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementPayment
     */
    omit?: SaleMovementPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementPaymentInclude<ExtArgs> | null
  }


  /**
   * Model SaleMovementChange
   */

  export type AggregateSaleMovementChange = {
    _count: SaleMovementChangeCountAggregateOutputType | null
    _avg: SaleMovementChangeAvgAggregateOutputType | null
    _sum: SaleMovementChangeSumAggregateOutputType | null
    _min: SaleMovementChangeMinAggregateOutputType | null
    _max: SaleMovementChangeMaxAggregateOutputType | null
  }

  export type SaleMovementChangeAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SaleMovementChangeSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SaleMovementChangeMinAggregateOutputType = {
    id: string | null
    method: $Enums.EPaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMovementChangeMaxAggregateOutputType = {
    id: string | null
    method: $Enums.EPaymentMethod | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMovementChangeCountAggregateOutputType = {
    id: number
    method: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleMovementChangeAvgAggregateInputType = {
    amount?: true
  }

  export type SaleMovementChangeSumAggregateInputType = {
    amount?: true
  }

  export type SaleMovementChangeMinAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMovementChangeMaxAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMovementChangeCountAggregateInputType = {
    id?: true
    method?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleMovementChangeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleMovementChange to aggregate.
     */
    where?: SaleMovementChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovementChanges to fetch.
     */
    orderBy?: SaleMovementChangeOrderByWithRelationInput | SaleMovementChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleMovementChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovementChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovementChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleMovementChanges
    **/
    _count?: true | SaleMovementChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleMovementChangeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleMovementChangeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMovementChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMovementChangeMaxAggregateInputType
  }

  export type GetSaleMovementChangeAggregateType<T extends SaleMovementChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleMovementChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleMovementChange[P]>
      : GetScalarType<T[P], AggregateSaleMovementChange[P]>
  }




  export type SaleMovementChangeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleMovementChangeWhereInput
    orderBy?: SaleMovementChangeOrderByWithAggregationInput | SaleMovementChangeOrderByWithAggregationInput[]
    by: SaleMovementChangeScalarFieldEnum[] | SaleMovementChangeScalarFieldEnum
    having?: SaleMovementChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleMovementChangeCountAggregateInputType | true
    _avg?: SaleMovementChangeAvgAggregateInputType
    _sum?: SaleMovementChangeSumAggregateInputType
    _min?: SaleMovementChangeMinAggregateInputType
    _max?: SaleMovementChangeMaxAggregateInputType
  }

  export type SaleMovementChangeGroupByOutputType = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: SaleMovementChangeCountAggregateOutputType | null
    _avg: SaleMovementChangeAvgAggregateOutputType | null
    _sum: SaleMovementChangeSumAggregateOutputType | null
    _min: SaleMovementChangeMinAggregateOutputType | null
    _max: SaleMovementChangeMaxAggregateOutputType | null
  }

  type GetSaleMovementChangeGroupByPayload<T extends SaleMovementChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleMovementChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleMovementChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleMovementChangeGroupByOutputType[P]>
            : GetScalarType<T[P], SaleMovementChangeGroupByOutputType[P]>
        }
      >
    >


  export type SaleMovementChangeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovementChange"]>

  export type SaleMovementChangeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovementChange"]>

  export type SaleMovementChangeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleMovementChange"]>

  export type SaleMovementChangeSelectScalar = {
    id?: boolean
    method?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleMovementChangeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "method" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["saleMovementChange"]>
  export type SaleMovementChangeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }
  export type SaleMovementChangeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }
  export type SaleMovementChangeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleMovement?: boolean | SaleMovementDefaultArgs<ExtArgs>
  }

  export type $SaleMovementChangePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleMovementChange"
    objects: {
      saleMovement: Prisma.$SaleMovementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      method: $Enums.EPaymentMethod
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saleMovementChange"]>
    composites: {}
  }

  type SaleMovementChangeGetPayload<S extends boolean | null | undefined | SaleMovementChangeDefaultArgs> = $Result.GetResult<Prisma.$SaleMovementChangePayload, S>

  type SaleMovementChangeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleMovementChangeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleMovementChangeCountAggregateInputType | true
    }

  export interface SaleMovementChangeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleMovementChange'], meta: { name: 'SaleMovementChange' } }
    /**
     * Find zero or one SaleMovementChange that matches the filter.
     * @param {SaleMovementChangeFindUniqueArgs} args - Arguments to find a SaleMovementChange
     * @example
     * // Get one SaleMovementChange
     * const saleMovementChange = await prisma.saleMovementChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleMovementChangeFindUniqueArgs>(args: SelectSubset<T, SaleMovementChangeFindUniqueArgs<ExtArgs>>): Prisma__SaleMovementChangeClient<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleMovementChange that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleMovementChangeFindUniqueOrThrowArgs} args - Arguments to find a SaleMovementChange
     * @example
     * // Get one SaleMovementChange
     * const saleMovementChange = await prisma.saleMovementChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleMovementChangeFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleMovementChangeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleMovementChangeClient<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleMovementChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementChangeFindFirstArgs} args - Arguments to find a SaleMovementChange
     * @example
     * // Get one SaleMovementChange
     * const saleMovementChange = await prisma.saleMovementChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleMovementChangeFindFirstArgs>(args?: SelectSubset<T, SaleMovementChangeFindFirstArgs<ExtArgs>>): Prisma__SaleMovementChangeClient<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleMovementChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementChangeFindFirstOrThrowArgs} args - Arguments to find a SaleMovementChange
     * @example
     * // Get one SaleMovementChange
     * const saleMovementChange = await prisma.saleMovementChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleMovementChangeFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleMovementChangeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleMovementChangeClient<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleMovementChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementChangeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleMovementChanges
     * const saleMovementChanges = await prisma.saleMovementChange.findMany()
     * 
     * // Get first 10 SaleMovementChanges
     * const saleMovementChanges = await prisma.saleMovementChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleMovementChangeWithIdOnly = await prisma.saleMovementChange.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleMovementChangeFindManyArgs>(args?: SelectSubset<T, SaleMovementChangeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleMovementChange.
     * @param {SaleMovementChangeCreateArgs} args - Arguments to create a SaleMovementChange.
     * @example
     * // Create one SaleMovementChange
     * const SaleMovementChange = await prisma.saleMovementChange.create({
     *   data: {
     *     // ... data to create a SaleMovementChange
     *   }
     * })
     * 
     */
    create<T extends SaleMovementChangeCreateArgs>(args: SelectSubset<T, SaleMovementChangeCreateArgs<ExtArgs>>): Prisma__SaleMovementChangeClient<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleMovementChanges.
     * @param {SaleMovementChangeCreateManyArgs} args - Arguments to create many SaleMovementChanges.
     * @example
     * // Create many SaleMovementChanges
     * const saleMovementChange = await prisma.saleMovementChange.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleMovementChangeCreateManyArgs>(args?: SelectSubset<T, SaleMovementChangeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleMovementChanges and returns the data saved in the database.
     * @param {SaleMovementChangeCreateManyAndReturnArgs} args - Arguments to create many SaleMovementChanges.
     * @example
     * // Create many SaleMovementChanges
     * const saleMovementChange = await prisma.saleMovementChange.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleMovementChanges and only return the `id`
     * const saleMovementChangeWithIdOnly = await prisma.saleMovementChange.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleMovementChangeCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleMovementChangeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleMovementChange.
     * @param {SaleMovementChangeDeleteArgs} args - Arguments to delete one SaleMovementChange.
     * @example
     * // Delete one SaleMovementChange
     * const SaleMovementChange = await prisma.saleMovementChange.delete({
     *   where: {
     *     // ... filter to delete one SaleMovementChange
     *   }
     * })
     * 
     */
    delete<T extends SaleMovementChangeDeleteArgs>(args: SelectSubset<T, SaleMovementChangeDeleteArgs<ExtArgs>>): Prisma__SaleMovementChangeClient<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleMovementChange.
     * @param {SaleMovementChangeUpdateArgs} args - Arguments to update one SaleMovementChange.
     * @example
     * // Update one SaleMovementChange
     * const saleMovementChange = await prisma.saleMovementChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleMovementChangeUpdateArgs>(args: SelectSubset<T, SaleMovementChangeUpdateArgs<ExtArgs>>): Prisma__SaleMovementChangeClient<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleMovementChanges.
     * @param {SaleMovementChangeDeleteManyArgs} args - Arguments to filter SaleMovementChanges to delete.
     * @example
     * // Delete a few SaleMovementChanges
     * const { count } = await prisma.saleMovementChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleMovementChangeDeleteManyArgs>(args?: SelectSubset<T, SaleMovementChangeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleMovementChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleMovementChanges
     * const saleMovementChange = await prisma.saleMovementChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleMovementChangeUpdateManyArgs>(args: SelectSubset<T, SaleMovementChangeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleMovementChanges and returns the data updated in the database.
     * @param {SaleMovementChangeUpdateManyAndReturnArgs} args - Arguments to update many SaleMovementChanges.
     * @example
     * // Update many SaleMovementChanges
     * const saleMovementChange = await prisma.saleMovementChange.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleMovementChanges and only return the `id`
     * const saleMovementChangeWithIdOnly = await prisma.saleMovementChange.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleMovementChangeUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleMovementChangeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleMovementChange.
     * @param {SaleMovementChangeUpsertArgs} args - Arguments to update or create a SaleMovementChange.
     * @example
     * // Update or create a SaleMovementChange
     * const saleMovementChange = await prisma.saleMovementChange.upsert({
     *   create: {
     *     // ... data to create a SaleMovementChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleMovementChange we want to update
     *   }
     * })
     */
    upsert<T extends SaleMovementChangeUpsertArgs>(args: SelectSubset<T, SaleMovementChangeUpsertArgs<ExtArgs>>): Prisma__SaleMovementChangeClient<$Result.GetResult<Prisma.$SaleMovementChangePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleMovementChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementChangeCountArgs} args - Arguments to filter SaleMovementChanges to count.
     * @example
     * // Count the number of SaleMovementChanges
     * const count = await prisma.saleMovementChange.count({
     *   where: {
     *     // ... the filter for the SaleMovementChanges we want to count
     *   }
     * })
    **/
    count<T extends SaleMovementChangeCountArgs>(
      args?: Subset<T, SaleMovementChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleMovementChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleMovementChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleMovementChangeAggregateArgs>(args: Subset<T, SaleMovementChangeAggregateArgs>): Prisma.PrismaPromise<GetSaleMovementChangeAggregateType<T>>

    /**
     * Group by SaleMovementChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleMovementChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleMovementChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleMovementChangeGroupByArgs['orderBy'] }
        : { orderBy?: SaleMovementChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleMovementChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleMovementChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleMovementChange model
   */
  readonly fields: SaleMovementChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleMovementChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleMovementChangeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saleMovement<T extends SaleMovementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleMovementDefaultArgs<ExtArgs>>): Prisma__SaleMovementClient<$Result.GetResult<Prisma.$SaleMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleMovementChange model
   */
  interface SaleMovementChangeFieldRefs {
    readonly id: FieldRef<"SaleMovementChange", 'String'>
    readonly method: FieldRef<"SaleMovementChange", 'EPaymentMethod'>
    readonly amount: FieldRef<"SaleMovementChange", 'Decimal'>
    readonly createdAt: FieldRef<"SaleMovementChange", 'DateTime'>
    readonly updatedAt: FieldRef<"SaleMovementChange", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleMovementChange findUnique
   */
  export type SaleMovementChangeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementChange to fetch.
     */
    where: SaleMovementChangeWhereUniqueInput
  }

  /**
   * SaleMovementChange findUniqueOrThrow
   */
  export type SaleMovementChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementChange to fetch.
     */
    where: SaleMovementChangeWhereUniqueInput
  }

  /**
   * SaleMovementChange findFirst
   */
  export type SaleMovementChangeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementChange to fetch.
     */
    where?: SaleMovementChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovementChanges to fetch.
     */
    orderBy?: SaleMovementChangeOrderByWithRelationInput | SaleMovementChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleMovementChanges.
     */
    cursor?: SaleMovementChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovementChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovementChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleMovementChanges.
     */
    distinct?: SaleMovementChangeScalarFieldEnum | SaleMovementChangeScalarFieldEnum[]
  }

  /**
   * SaleMovementChange findFirstOrThrow
   */
  export type SaleMovementChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementChange to fetch.
     */
    where?: SaleMovementChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovementChanges to fetch.
     */
    orderBy?: SaleMovementChangeOrderByWithRelationInput | SaleMovementChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleMovementChanges.
     */
    cursor?: SaleMovementChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovementChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovementChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleMovementChanges.
     */
    distinct?: SaleMovementChangeScalarFieldEnum | SaleMovementChangeScalarFieldEnum[]
  }

  /**
   * SaleMovementChange findMany
   */
  export type SaleMovementChangeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter, which SaleMovementChanges to fetch.
     */
    where?: SaleMovementChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleMovementChanges to fetch.
     */
    orderBy?: SaleMovementChangeOrderByWithRelationInput | SaleMovementChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleMovementChanges.
     */
    cursor?: SaleMovementChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleMovementChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleMovementChanges.
     */
    skip?: number
    distinct?: SaleMovementChangeScalarFieldEnum | SaleMovementChangeScalarFieldEnum[]
  }

  /**
   * SaleMovementChange create
   */
  export type SaleMovementChangeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleMovementChange.
     */
    data: XOR<SaleMovementChangeCreateInput, SaleMovementChangeUncheckedCreateInput>
  }

  /**
   * SaleMovementChange createMany
   */
  export type SaleMovementChangeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleMovementChanges.
     */
    data: SaleMovementChangeCreateManyInput | SaleMovementChangeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleMovementChange createManyAndReturn
   */
  export type SaleMovementChangeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * The data used to create many SaleMovementChanges.
     */
    data: SaleMovementChangeCreateManyInput | SaleMovementChangeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleMovementChange update
   */
  export type SaleMovementChangeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleMovementChange.
     */
    data: XOR<SaleMovementChangeUpdateInput, SaleMovementChangeUncheckedUpdateInput>
    /**
     * Choose, which SaleMovementChange to update.
     */
    where: SaleMovementChangeWhereUniqueInput
  }

  /**
   * SaleMovementChange updateMany
   */
  export type SaleMovementChangeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleMovementChanges.
     */
    data: XOR<SaleMovementChangeUpdateManyMutationInput, SaleMovementChangeUncheckedUpdateManyInput>
    /**
     * Filter which SaleMovementChanges to update
     */
    where?: SaleMovementChangeWhereInput
    /**
     * Limit how many SaleMovementChanges to update.
     */
    limit?: number
  }

  /**
   * SaleMovementChange updateManyAndReturn
   */
  export type SaleMovementChangeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * The data used to update SaleMovementChanges.
     */
    data: XOR<SaleMovementChangeUpdateManyMutationInput, SaleMovementChangeUncheckedUpdateManyInput>
    /**
     * Filter which SaleMovementChanges to update
     */
    where?: SaleMovementChangeWhereInput
    /**
     * Limit how many SaleMovementChanges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleMovementChange upsert
   */
  export type SaleMovementChangeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleMovementChange to update in case it exists.
     */
    where: SaleMovementChangeWhereUniqueInput
    /**
     * In case the SaleMovementChange found by the `where` argument doesn't exist, create a new SaleMovementChange with this data.
     */
    create: XOR<SaleMovementChangeCreateInput, SaleMovementChangeUncheckedCreateInput>
    /**
     * In case the SaleMovementChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleMovementChangeUpdateInput, SaleMovementChangeUncheckedUpdateInput>
  }

  /**
   * SaleMovementChange delete
   */
  export type SaleMovementChangeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
    /**
     * Filter which SaleMovementChange to delete.
     */
    where: SaleMovementChangeWhereUniqueInput
  }

  /**
   * SaleMovementChange deleteMany
   */
  export type SaleMovementChangeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleMovementChanges to delete
     */
    where?: SaleMovementChangeWhereInput
    /**
     * Limit how many SaleMovementChanges to delete.
     */
    limit?: number
  }

  /**
   * SaleMovementChange without action
   */
  export type SaleMovementChangeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleMovementChange
     */
    select?: SaleMovementChangeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleMovementChange
     */
    omit?: SaleMovementChangeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleMovementChangeInclude<ExtArgs> | null
  }


  /**
   * Model SaleProduct
   */

  export type AggregateSaleProduct = {
    _count: SaleProductCountAggregateOutputType | null
    _avg: SaleProductAvgAggregateOutputType | null
    _sum: SaleProductSumAggregateOutputType | null
    _min: SaleProductMinAggregateOutputType | null
    _max: SaleProductMaxAggregateOutputType | null
  }

  export type SaleProductAvgAggregateOutputType = {
    costPrice: Decimal | null
    salePrice: Decimal | null
    totalQty: number | null
  }

  export type SaleProductSumAggregateOutputType = {
    costPrice: Decimal | null
    salePrice: Decimal | null
    totalQty: number | null
  }

  export type SaleProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    costPrice: Decimal | null
    salePrice: Decimal | null
    totalQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
    saleId: string | null
    productId: string | null
    stockLotId: string | null
  }

  export type SaleProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    costPrice: Decimal | null
    salePrice: Decimal | null
    totalQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
    saleId: string | null
    productId: string | null
    stockLotId: string | null
  }

  export type SaleProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    costPrice: number
    salePrice: number
    totalQty: number
    createdAt: number
    updatedAt: number
    saleId: number
    productId: number
    stockLotId: number
    _all: number
  }


  export type SaleProductAvgAggregateInputType = {
    costPrice?: true
    salePrice?: true
    totalQty?: true
  }

  export type SaleProductSumAggregateInputType = {
    costPrice?: true
    salePrice?: true
    totalQty?: true
  }

  export type SaleProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    costPrice?: true
    salePrice?: true
    totalQty?: true
    createdAt?: true
    updatedAt?: true
    saleId?: true
    productId?: true
    stockLotId?: true
  }

  export type SaleProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    costPrice?: true
    salePrice?: true
    totalQty?: true
    createdAt?: true
    updatedAt?: true
    saleId?: true
    productId?: true
    stockLotId?: true
  }

  export type SaleProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    costPrice?: true
    salePrice?: true
    totalQty?: true
    createdAt?: true
    updatedAt?: true
    saleId?: true
    productId?: true
    stockLotId?: true
    _all?: true
  }

  export type SaleProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleProduct to aggregate.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleProducts
    **/
    _count?: true | SaleProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleProductMaxAggregateInputType
  }

  export type GetSaleProductAggregateType<T extends SaleProductAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleProduct[P]>
      : GetScalarType<T[P], AggregateSaleProduct[P]>
  }




  export type SaleProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithAggregationInput | SaleProductOrderByWithAggregationInput[]
    by: SaleProductScalarFieldEnum[] | SaleProductScalarFieldEnum
    having?: SaleProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleProductCountAggregateInputType | true
    _avg?: SaleProductAvgAggregateInputType
    _sum?: SaleProductSumAggregateInputType
    _min?: SaleProductMinAggregateInputType
    _max?: SaleProductMaxAggregateInputType
  }

  export type SaleProductGroupByOutputType = {
    id: string
    name: string
    description: string
    costPrice: Decimal
    salePrice: Decimal
    totalQty: number
    createdAt: Date
    updatedAt: Date
    saleId: string
    productId: string
    stockLotId: string
    _count: SaleProductCountAggregateOutputType | null
    _avg: SaleProductAvgAggregateOutputType | null
    _sum: SaleProductSumAggregateOutputType | null
    _min: SaleProductMinAggregateOutputType | null
    _max: SaleProductMaxAggregateOutputType | null
  }

  type GetSaleProductGroupByPayload<T extends SaleProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleProductGroupByOutputType[P]>
            : GetScalarType<T[P], SaleProductGroupByOutputType[P]>
        }
      >
    >


  export type SaleProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    costPrice?: boolean
    salePrice?: boolean
    totalQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleId?: boolean
    productId?: boolean
    stockLotId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    stockLot?: boolean | StockLotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleProduct"]>

  export type SaleProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    costPrice?: boolean
    salePrice?: boolean
    totalQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleId?: boolean
    productId?: boolean
    stockLotId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    stockLot?: boolean | StockLotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleProduct"]>

  export type SaleProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    costPrice?: boolean
    salePrice?: boolean
    totalQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleId?: boolean
    productId?: boolean
    stockLotId?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    stockLot?: boolean | StockLotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleProduct"]>

  export type SaleProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    costPrice?: boolean
    salePrice?: boolean
    totalQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleId?: boolean
    productId?: boolean
    stockLotId?: boolean
  }

  export type SaleProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "costPrice" | "salePrice" | "totalQty" | "createdAt" | "updatedAt" | "saleId" | "productId" | "stockLotId", ExtArgs["result"]["saleProduct"]>
  export type SaleProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    stockLot?: boolean | StockLotDefaultArgs<ExtArgs>
  }
  export type SaleProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    stockLot?: boolean | StockLotDefaultArgs<ExtArgs>
  }
  export type SaleProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    stockLot?: boolean | StockLotDefaultArgs<ExtArgs>
  }

  export type $SaleProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleProduct"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      stockLot: Prisma.$StockLotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      costPrice: Prisma.Decimal
      salePrice: Prisma.Decimal
      totalQty: number
      createdAt: Date
      updatedAt: Date
      saleId: string
      productId: string
      stockLotId: string
    }, ExtArgs["result"]["saleProduct"]>
    composites: {}
  }

  type SaleProductGetPayload<S extends boolean | null | undefined | SaleProductDefaultArgs> = $Result.GetResult<Prisma.$SaleProductPayload, S>

  type SaleProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleProductCountAggregateInputType | true
    }

  export interface SaleProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleProduct'], meta: { name: 'SaleProduct' } }
    /**
     * Find zero or one SaleProduct that matches the filter.
     * @param {SaleProductFindUniqueArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleProductFindUniqueArgs>(args: SelectSubset<T, SaleProductFindUniqueArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleProductFindUniqueOrThrowArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleProductFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindFirstArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleProductFindFirstArgs>(args?: SelectSubset<T, SaleProductFindFirstArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindFirstOrThrowArgs} args - Arguments to find a SaleProduct
     * @example
     * // Get one SaleProduct
     * const saleProduct = await prisma.saleProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleProductFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleProducts
     * const saleProducts = await prisma.saleProduct.findMany()
     * 
     * // Get first 10 SaleProducts
     * const saleProducts = await prisma.saleProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleProductWithIdOnly = await prisma.saleProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleProductFindManyArgs>(args?: SelectSubset<T, SaleProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleProduct.
     * @param {SaleProductCreateArgs} args - Arguments to create a SaleProduct.
     * @example
     * // Create one SaleProduct
     * const SaleProduct = await prisma.saleProduct.create({
     *   data: {
     *     // ... data to create a SaleProduct
     *   }
     * })
     * 
     */
    create<T extends SaleProductCreateArgs>(args: SelectSubset<T, SaleProductCreateArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleProducts.
     * @param {SaleProductCreateManyArgs} args - Arguments to create many SaleProducts.
     * @example
     * // Create many SaleProducts
     * const saleProduct = await prisma.saleProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleProductCreateManyArgs>(args?: SelectSubset<T, SaleProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleProducts and returns the data saved in the database.
     * @param {SaleProductCreateManyAndReturnArgs} args - Arguments to create many SaleProducts.
     * @example
     * // Create many SaleProducts
     * const saleProduct = await prisma.saleProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleProducts and only return the `id`
     * const saleProductWithIdOnly = await prisma.saleProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleProductCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleProduct.
     * @param {SaleProductDeleteArgs} args - Arguments to delete one SaleProduct.
     * @example
     * // Delete one SaleProduct
     * const SaleProduct = await prisma.saleProduct.delete({
     *   where: {
     *     // ... filter to delete one SaleProduct
     *   }
     * })
     * 
     */
    delete<T extends SaleProductDeleteArgs>(args: SelectSubset<T, SaleProductDeleteArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleProduct.
     * @param {SaleProductUpdateArgs} args - Arguments to update one SaleProduct.
     * @example
     * // Update one SaleProduct
     * const saleProduct = await prisma.saleProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleProductUpdateArgs>(args: SelectSubset<T, SaleProductUpdateArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleProducts.
     * @param {SaleProductDeleteManyArgs} args - Arguments to filter SaleProducts to delete.
     * @example
     * // Delete a few SaleProducts
     * const { count } = await prisma.saleProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleProductDeleteManyArgs>(args?: SelectSubset<T, SaleProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleProducts
     * const saleProduct = await prisma.saleProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleProductUpdateManyArgs>(args: SelectSubset<T, SaleProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleProducts and returns the data updated in the database.
     * @param {SaleProductUpdateManyAndReturnArgs} args - Arguments to update many SaleProducts.
     * @example
     * // Update many SaleProducts
     * const saleProduct = await prisma.saleProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleProducts and only return the `id`
     * const saleProductWithIdOnly = await prisma.saleProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleProductUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleProduct.
     * @param {SaleProductUpsertArgs} args - Arguments to update or create a SaleProduct.
     * @example
     * // Update or create a SaleProduct
     * const saleProduct = await prisma.saleProduct.upsert({
     *   create: {
     *     // ... data to create a SaleProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleProduct we want to update
     *   }
     * })
     */
    upsert<T extends SaleProductUpsertArgs>(args: SelectSubset<T, SaleProductUpsertArgs<ExtArgs>>): Prisma__SaleProductClient<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductCountArgs} args - Arguments to filter SaleProducts to count.
     * @example
     * // Count the number of SaleProducts
     * const count = await prisma.saleProduct.count({
     *   where: {
     *     // ... the filter for the SaleProducts we want to count
     *   }
     * })
    **/
    count<T extends SaleProductCountArgs>(
      args?: Subset<T, SaleProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleProductAggregateArgs>(args: Subset<T, SaleProductAggregateArgs>): Prisma.PrismaPromise<GetSaleProductAggregateType<T>>

    /**
     * Group by SaleProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleProductGroupByArgs['orderBy'] }
        : { orderBy?: SaleProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleProduct model
   */
  readonly fields: SaleProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stockLot<T extends StockLotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockLotDefaultArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleProduct model
   */
  interface SaleProductFieldRefs {
    readonly id: FieldRef<"SaleProduct", 'String'>
    readonly name: FieldRef<"SaleProduct", 'String'>
    readonly description: FieldRef<"SaleProduct", 'String'>
    readonly costPrice: FieldRef<"SaleProduct", 'Decimal'>
    readonly salePrice: FieldRef<"SaleProduct", 'Decimal'>
    readonly totalQty: FieldRef<"SaleProduct", 'Int'>
    readonly createdAt: FieldRef<"SaleProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"SaleProduct", 'DateTime'>
    readonly saleId: FieldRef<"SaleProduct", 'String'>
    readonly productId: FieldRef<"SaleProduct", 'String'>
    readonly stockLotId: FieldRef<"SaleProduct", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SaleProduct findUnique
   */
  export type SaleProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct findUniqueOrThrow
   */
  export type SaleProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct findFirst
   */
  export type SaleProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleProducts.
     */
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct findFirstOrThrow
   */
  export type SaleProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProduct to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleProducts.
     */
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct findMany
   */
  export type SaleProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter, which SaleProducts to fetch.
     */
    where?: SaleProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleProducts to fetch.
     */
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleProducts.
     */
    cursor?: SaleProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleProducts.
     */
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * SaleProduct create
   */
  export type SaleProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleProduct.
     */
    data: XOR<SaleProductCreateInput, SaleProductUncheckedCreateInput>
  }

  /**
   * SaleProduct createMany
   */
  export type SaleProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleProducts.
     */
    data: SaleProductCreateManyInput | SaleProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleProduct createManyAndReturn
   */
  export type SaleProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * The data used to create many SaleProducts.
     */
    data: SaleProductCreateManyInput | SaleProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleProduct update
   */
  export type SaleProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleProduct.
     */
    data: XOR<SaleProductUpdateInput, SaleProductUncheckedUpdateInput>
    /**
     * Choose, which SaleProduct to update.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct updateMany
   */
  export type SaleProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleProducts.
     */
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyInput>
    /**
     * Filter which SaleProducts to update
     */
    where?: SaleProductWhereInput
    /**
     * Limit how many SaleProducts to update.
     */
    limit?: number
  }

  /**
   * SaleProduct updateManyAndReturn
   */
  export type SaleProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * The data used to update SaleProducts.
     */
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyInput>
    /**
     * Filter which SaleProducts to update
     */
    where?: SaleProductWhereInput
    /**
     * Limit how many SaleProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleProduct upsert
   */
  export type SaleProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleProduct to update in case it exists.
     */
    where: SaleProductWhereUniqueInput
    /**
     * In case the SaleProduct found by the `where` argument doesn't exist, create a new SaleProduct with this data.
     */
    create: XOR<SaleProductCreateInput, SaleProductUncheckedCreateInput>
    /**
     * In case the SaleProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleProductUpdateInput, SaleProductUncheckedUpdateInput>
  }

  /**
   * SaleProduct delete
   */
  export type SaleProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    /**
     * Filter which SaleProduct to delete.
     */
    where: SaleProductWhereUniqueInput
  }

  /**
   * SaleProduct deleteMany
   */
  export type SaleProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleProducts to delete
     */
    where?: SaleProductWhereInput
    /**
     * Limit how many SaleProducts to delete.
     */
    limit?: number
  }

  /**
   * SaleProduct without action
   */
  export type SaleProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
  }


  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    totalQty: number | null
    availableQty: number | null
  }

  export type StockSumAggregateOutputType = {
    totalQty: number | null
    availableQty: number | null
  }

  export type StockMinAggregateOutputType = {
    id: string | null
    strategy: $Enums.EStockStrategy | null
    productId: string | null
    totalQty: number | null
    availableQty: number | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockMaxAggregateOutputType = {
    id: string | null
    strategy: $Enums.EStockStrategy | null
    productId: string | null
    totalQty: number | null
    availableQty: number | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockCountAggregateOutputType = {
    id: number
    strategy: number
    productId: number
    totalQty: number
    availableQty: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    totalQty?: true
    availableQty?: true
  }

  export type StockSumAggregateInputType = {
    totalQty?: true
    availableQty?: true
  }

  export type StockMinAggregateInputType = {
    id?: true
    strategy?: true
    productId?: true
    totalQty?: true
    availableQty?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockMaxAggregateInputType = {
    id?: true
    strategy?: true
    productId?: true
    totalQty?: true
    availableQty?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockCountAggregateInputType = {
    id?: true
    strategy?: true
    productId?: true
    totalQty?: true
    availableQty?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    id: string
    strategy: $Enums.EStockStrategy
    productId: string
    totalQty: number
    availableQty: number
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategy?: boolean
    productId?: boolean
    totalQty?: boolean
    availableQty?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    lots?: boolean | Stock$lotsArgs<ExtArgs>
    StockEvent?: boolean | Stock$StockEventArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategy?: boolean
    productId?: boolean
    totalQty?: boolean
    availableQty?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategy?: boolean
    productId?: boolean
    totalQty?: boolean
    availableQty?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectScalar = {
    id?: boolean
    strategy?: boolean
    productId?: boolean
    totalQty?: boolean
    availableQty?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "strategy" | "productId" | "totalQty" | "availableQty" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["stock"]>
  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    lots?: boolean | Stock$lotsArgs<ExtArgs>
    StockEvent?: boolean | Stock$StockEventArgs<ExtArgs>
    _count?: boolean | StockCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type StockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      lots: Prisma.$StockLotPayload<ExtArgs>[]
      StockEvent: Prisma.$StockEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      strategy: $Enums.EStockStrategy
      productId: string
      totalQty: number
      availableQty: number
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockWithIdOnly = await prisma.stock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stocks and returns the data saved in the database.
     * @param {StockCreateManyAndReturnArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stocks and only return the `id`
     * const stockWithIdOnly = await prisma.stock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockCreateManyAndReturnArgs>(args?: SelectSubset<T, StockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks and returns the data updated in the database.
     * @param {StockUpdateManyAndReturnArgs} args - Arguments to update many Stocks.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stocks and only return the `id`
     * const stockWithIdOnly = await prisma.stock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockUpdateManyAndReturnArgs>(args: SelectSubset<T, StockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lots<T extends Stock$lotsArgs<ExtArgs> = {}>(args?: Subset<T, Stock$lotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockEvent<T extends Stock$StockEventArgs<ExtArgs> = {}>(args?: Subset<T, Stock$StockEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */
  interface StockFieldRefs {
    readonly id: FieldRef<"Stock", 'String'>
    readonly strategy: FieldRef<"Stock", 'EStockStrategy'>
    readonly productId: FieldRef<"Stock", 'String'>
    readonly totalQty: FieldRef<"Stock", 'Int'>
    readonly availableQty: FieldRef<"Stock", 'Int'>
    readonly tenantId: FieldRef<"Stock", 'String'>
    readonly createdAt: FieldRef<"Stock", 'DateTime'>
    readonly updatedAt: FieldRef<"Stock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock createManyAndReturn
   */
  export type StockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
  }

  /**
   * Stock updateManyAndReturn
   */
  export type StockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
    /**
     * Limit how many Stocks to delete.
     */
    limit?: number
  }

  /**
   * Stock.lots
   */
  export type Stock$lotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    where?: StockLotWhereInput
    orderBy?: StockLotOrderByWithRelationInput | StockLotOrderByWithRelationInput[]
    cursor?: StockLotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLotScalarFieldEnum | StockLotScalarFieldEnum[]
  }

  /**
   * Stock.StockEvent
   */
  export type Stock$StockEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    where?: StockEventWhereInput
    orderBy?: StockEventOrderByWithRelationInput | StockEventOrderByWithRelationInput[]
    cursor?: StockEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockEventScalarFieldEnum | StockEventScalarFieldEnum[]
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Model StockEvent
   */

  export type AggregateStockEvent = {
    _count: StockEventCountAggregateOutputType | null
    _min: StockEventMinAggregateOutputType | null
    _max: StockEventMaxAggregateOutputType | null
  }

  export type StockEventMinAggregateOutputType = {
    id: string | null
    type: $Enums.EStockEventType | null
    stockId: string | null
    tenantId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stockLotId: string | null
  }

  export type StockEventMaxAggregateOutputType = {
    id: string | null
    type: $Enums.EStockEventType | null
    stockId: string | null
    tenantId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    stockLotId: string | null
  }

  export type StockEventCountAggregateOutputType = {
    id: number
    type: number
    stockId: number
    tenantId: number
    description: number
    createdAt: number
    updatedAt: number
    stockLotId: number
    _all: number
  }


  export type StockEventMinAggregateInputType = {
    id?: true
    type?: true
    stockId?: true
    tenantId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    stockLotId?: true
  }

  export type StockEventMaxAggregateInputType = {
    id?: true
    type?: true
    stockId?: true
    tenantId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    stockLotId?: true
  }

  export type StockEventCountAggregateInputType = {
    id?: true
    type?: true
    stockId?: true
    tenantId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    stockLotId?: true
    _all?: true
  }

  export type StockEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockEvent to aggregate.
     */
    where?: StockEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEvents to fetch.
     */
    orderBy?: StockEventOrderByWithRelationInput | StockEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockEvents
    **/
    _count?: true | StockEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockEventMaxAggregateInputType
  }

  export type GetStockEventAggregateType<T extends StockEventAggregateArgs> = {
        [P in keyof T & keyof AggregateStockEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockEvent[P]>
      : GetScalarType<T[P], AggregateStockEvent[P]>
  }




  export type StockEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockEventWhereInput
    orderBy?: StockEventOrderByWithAggregationInput | StockEventOrderByWithAggregationInput[]
    by: StockEventScalarFieldEnum[] | StockEventScalarFieldEnum
    having?: StockEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockEventCountAggregateInputType | true
    _min?: StockEventMinAggregateInputType
    _max?: StockEventMaxAggregateInputType
  }

  export type StockEventGroupByOutputType = {
    id: string
    type: $Enums.EStockEventType
    stockId: string
    tenantId: string
    description: string
    createdAt: Date
    updatedAt: Date
    stockLotId: string | null
    _count: StockEventCountAggregateOutputType | null
    _min: StockEventMinAggregateOutputType | null
    _max: StockEventMaxAggregateOutputType | null
  }

  type GetStockEventGroupByPayload<T extends StockEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockEventGroupByOutputType[P]>
            : GetScalarType<T[P], StockEventGroupByOutputType[P]>
        }
      >
    >


  export type StockEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    stockId?: boolean
    tenantId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockLotId?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    entry?: boolean | StockEvent$entryArgs<ExtArgs>
    output?: boolean | StockEvent$outputArgs<ExtArgs>
    StockLot?: boolean | StockEvent$StockLotArgs<ExtArgs>
  }, ExtArgs["result"]["stockEvent"]>

  export type StockEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    stockId?: boolean
    tenantId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockLotId?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    StockLot?: boolean | StockEvent$StockLotArgs<ExtArgs>
  }, ExtArgs["result"]["stockEvent"]>

  export type StockEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    stockId?: boolean
    tenantId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockLotId?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    StockLot?: boolean | StockEvent$StockLotArgs<ExtArgs>
  }, ExtArgs["result"]["stockEvent"]>

  export type StockEventSelectScalar = {
    id?: boolean
    type?: boolean
    stockId?: boolean
    tenantId?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stockLotId?: boolean
  }

  export type StockEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "stockId" | "tenantId" | "description" | "createdAt" | "updatedAt" | "stockLotId", ExtArgs["result"]["stockEvent"]>
  export type StockEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    entry?: boolean | StockEvent$entryArgs<ExtArgs>
    output?: boolean | StockEvent$outputArgs<ExtArgs>
    StockLot?: boolean | StockEvent$StockLotArgs<ExtArgs>
  }
  export type StockEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    StockLot?: boolean | StockEvent$StockLotArgs<ExtArgs>
  }
  export type StockEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    StockLot?: boolean | StockEvent$StockLotArgs<ExtArgs>
  }

  export type $StockEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockEvent"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      entry: Prisma.$StockEventEntryPayload<ExtArgs> | null
      output: Prisma.$StockEventOutputPayload<ExtArgs> | null
      StockLot: Prisma.$StockLotPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.EStockEventType
      stockId: string
      tenantId: string
      description: string
      createdAt: Date
      updatedAt: Date
      stockLotId: string | null
    }, ExtArgs["result"]["stockEvent"]>
    composites: {}
  }

  type StockEventGetPayload<S extends boolean | null | undefined | StockEventDefaultArgs> = $Result.GetResult<Prisma.$StockEventPayload, S>

  type StockEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockEventCountAggregateInputType | true
    }

  export interface StockEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockEvent'], meta: { name: 'StockEvent' } }
    /**
     * Find zero or one StockEvent that matches the filter.
     * @param {StockEventFindUniqueArgs} args - Arguments to find a StockEvent
     * @example
     * // Get one StockEvent
     * const stockEvent = await prisma.stockEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockEventFindUniqueArgs>(args: SelectSubset<T, StockEventFindUniqueArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockEventFindUniqueOrThrowArgs} args - Arguments to find a StockEvent
     * @example
     * // Get one StockEvent
     * const stockEvent = await prisma.stockEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockEventFindUniqueOrThrowArgs>(args: SelectSubset<T, StockEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventFindFirstArgs} args - Arguments to find a StockEvent
     * @example
     * // Get one StockEvent
     * const stockEvent = await prisma.stockEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockEventFindFirstArgs>(args?: SelectSubset<T, StockEventFindFirstArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventFindFirstOrThrowArgs} args - Arguments to find a StockEvent
     * @example
     * // Get one StockEvent
     * const stockEvent = await prisma.stockEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockEventFindFirstOrThrowArgs>(args?: SelectSubset<T, StockEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockEvents
     * const stockEvents = await prisma.stockEvent.findMany()
     * 
     * // Get first 10 StockEvents
     * const stockEvents = await prisma.stockEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockEventWithIdOnly = await prisma.stockEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockEventFindManyArgs>(args?: SelectSubset<T, StockEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockEvent.
     * @param {StockEventCreateArgs} args - Arguments to create a StockEvent.
     * @example
     * // Create one StockEvent
     * const StockEvent = await prisma.stockEvent.create({
     *   data: {
     *     // ... data to create a StockEvent
     *   }
     * })
     * 
     */
    create<T extends StockEventCreateArgs>(args: SelectSubset<T, StockEventCreateArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockEvents.
     * @param {StockEventCreateManyArgs} args - Arguments to create many StockEvents.
     * @example
     * // Create many StockEvents
     * const stockEvent = await prisma.stockEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockEventCreateManyArgs>(args?: SelectSubset<T, StockEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockEvents and returns the data saved in the database.
     * @param {StockEventCreateManyAndReturnArgs} args - Arguments to create many StockEvents.
     * @example
     * // Create many StockEvents
     * const stockEvent = await prisma.stockEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockEvents and only return the `id`
     * const stockEventWithIdOnly = await prisma.stockEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockEventCreateManyAndReturnArgs>(args?: SelectSubset<T, StockEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockEvent.
     * @param {StockEventDeleteArgs} args - Arguments to delete one StockEvent.
     * @example
     * // Delete one StockEvent
     * const StockEvent = await prisma.stockEvent.delete({
     *   where: {
     *     // ... filter to delete one StockEvent
     *   }
     * })
     * 
     */
    delete<T extends StockEventDeleteArgs>(args: SelectSubset<T, StockEventDeleteArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockEvent.
     * @param {StockEventUpdateArgs} args - Arguments to update one StockEvent.
     * @example
     * // Update one StockEvent
     * const stockEvent = await prisma.stockEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockEventUpdateArgs>(args: SelectSubset<T, StockEventUpdateArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockEvents.
     * @param {StockEventDeleteManyArgs} args - Arguments to filter StockEvents to delete.
     * @example
     * // Delete a few StockEvents
     * const { count } = await prisma.stockEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockEventDeleteManyArgs>(args?: SelectSubset<T, StockEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockEvents
     * const stockEvent = await prisma.stockEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockEventUpdateManyArgs>(args: SelectSubset<T, StockEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockEvents and returns the data updated in the database.
     * @param {StockEventUpdateManyAndReturnArgs} args - Arguments to update many StockEvents.
     * @example
     * // Update many StockEvents
     * const stockEvent = await prisma.stockEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockEvents and only return the `id`
     * const stockEventWithIdOnly = await prisma.stockEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockEventUpdateManyAndReturnArgs>(args: SelectSubset<T, StockEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockEvent.
     * @param {StockEventUpsertArgs} args - Arguments to update or create a StockEvent.
     * @example
     * // Update or create a StockEvent
     * const stockEvent = await prisma.stockEvent.upsert({
     *   create: {
     *     // ... data to create a StockEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockEvent we want to update
     *   }
     * })
     */
    upsert<T extends StockEventUpsertArgs>(args: SelectSubset<T, StockEventUpsertArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventCountArgs} args - Arguments to filter StockEvents to count.
     * @example
     * // Count the number of StockEvents
     * const count = await prisma.stockEvent.count({
     *   where: {
     *     // ... the filter for the StockEvents we want to count
     *   }
     * })
    **/
    count<T extends StockEventCountArgs>(
      args?: Subset<T, StockEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockEventAggregateArgs>(args: Subset<T, StockEventAggregateArgs>): Prisma.PrismaPromise<GetStockEventAggregateType<T>>

    /**
     * Group by StockEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockEventGroupByArgs['orderBy'] }
        : { orderBy?: StockEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockEvent model
   */
  readonly fields: StockEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entry<T extends StockEvent$entryArgs<ExtArgs> = {}>(args?: Subset<T, StockEvent$entryArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    output<T extends StockEvent$outputArgs<ExtArgs> = {}>(args?: Subset<T, StockEvent$outputArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    StockLot<T extends StockEvent$StockLotArgs<ExtArgs> = {}>(args?: Subset<T, StockEvent$StockLotArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockEvent model
   */
  interface StockEventFieldRefs {
    readonly id: FieldRef<"StockEvent", 'String'>
    readonly type: FieldRef<"StockEvent", 'EStockEventType'>
    readonly stockId: FieldRef<"StockEvent", 'String'>
    readonly tenantId: FieldRef<"StockEvent", 'String'>
    readonly description: FieldRef<"StockEvent", 'String'>
    readonly createdAt: FieldRef<"StockEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"StockEvent", 'DateTime'>
    readonly stockLotId: FieldRef<"StockEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StockEvent findUnique
   */
  export type StockEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * Filter, which StockEvent to fetch.
     */
    where: StockEventWhereUniqueInput
  }

  /**
   * StockEvent findUniqueOrThrow
   */
  export type StockEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * Filter, which StockEvent to fetch.
     */
    where: StockEventWhereUniqueInput
  }

  /**
   * StockEvent findFirst
   */
  export type StockEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * Filter, which StockEvent to fetch.
     */
    where?: StockEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEvents to fetch.
     */
    orderBy?: StockEventOrderByWithRelationInput | StockEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockEvents.
     */
    cursor?: StockEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockEvents.
     */
    distinct?: StockEventScalarFieldEnum | StockEventScalarFieldEnum[]
  }

  /**
   * StockEvent findFirstOrThrow
   */
  export type StockEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * Filter, which StockEvent to fetch.
     */
    where?: StockEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEvents to fetch.
     */
    orderBy?: StockEventOrderByWithRelationInput | StockEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockEvents.
     */
    cursor?: StockEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockEvents.
     */
    distinct?: StockEventScalarFieldEnum | StockEventScalarFieldEnum[]
  }

  /**
   * StockEvent findMany
   */
  export type StockEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * Filter, which StockEvents to fetch.
     */
    where?: StockEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEvents to fetch.
     */
    orderBy?: StockEventOrderByWithRelationInput | StockEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockEvents.
     */
    cursor?: StockEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEvents.
     */
    skip?: number
    distinct?: StockEventScalarFieldEnum | StockEventScalarFieldEnum[]
  }

  /**
   * StockEvent create
   */
  export type StockEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * The data needed to create a StockEvent.
     */
    data: XOR<StockEventCreateInput, StockEventUncheckedCreateInput>
  }

  /**
   * StockEvent createMany
   */
  export type StockEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockEvents.
     */
    data: StockEventCreateManyInput | StockEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockEvent createManyAndReturn
   */
  export type StockEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * The data used to create many StockEvents.
     */
    data: StockEventCreateManyInput | StockEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockEvent update
   */
  export type StockEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * The data needed to update a StockEvent.
     */
    data: XOR<StockEventUpdateInput, StockEventUncheckedUpdateInput>
    /**
     * Choose, which StockEvent to update.
     */
    where: StockEventWhereUniqueInput
  }

  /**
   * StockEvent updateMany
   */
  export type StockEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockEvents.
     */
    data: XOR<StockEventUpdateManyMutationInput, StockEventUncheckedUpdateManyInput>
    /**
     * Filter which StockEvents to update
     */
    where?: StockEventWhereInput
    /**
     * Limit how many StockEvents to update.
     */
    limit?: number
  }

  /**
   * StockEvent updateManyAndReturn
   */
  export type StockEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * The data used to update StockEvents.
     */
    data: XOR<StockEventUpdateManyMutationInput, StockEventUncheckedUpdateManyInput>
    /**
     * Filter which StockEvents to update
     */
    where?: StockEventWhereInput
    /**
     * Limit how many StockEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockEvent upsert
   */
  export type StockEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * The filter to search for the StockEvent to update in case it exists.
     */
    where: StockEventWhereUniqueInput
    /**
     * In case the StockEvent found by the `where` argument doesn't exist, create a new StockEvent with this data.
     */
    create: XOR<StockEventCreateInput, StockEventUncheckedCreateInput>
    /**
     * In case the StockEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockEventUpdateInput, StockEventUncheckedUpdateInput>
  }

  /**
   * StockEvent delete
   */
  export type StockEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    /**
     * Filter which StockEvent to delete.
     */
    where: StockEventWhereUniqueInput
  }

  /**
   * StockEvent deleteMany
   */
  export type StockEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockEvents to delete
     */
    where?: StockEventWhereInput
    /**
     * Limit how many StockEvents to delete.
     */
    limit?: number
  }

  /**
   * StockEvent.entry
   */
  export type StockEvent$entryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    where?: StockEventEntryWhereInput
  }

  /**
   * StockEvent.output
   */
  export type StockEvent$outputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    where?: StockEventOutputWhereInput
  }

  /**
   * StockEvent.StockLot
   */
  export type StockEvent$StockLotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    where?: StockLotWhereInput
  }

  /**
   * StockEvent without action
   */
  export type StockEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
  }


  /**
   * Model StockEventEntry
   */

  export type AggregateStockEventEntry = {
    _count: StockEventEntryCountAggregateOutputType | null
    _avg: StockEventEntryAvgAggregateOutputType | null
    _sum: StockEventEntrySumAggregateOutputType | null
    _min: StockEventEntryMinAggregateOutputType | null
    _max: StockEventEntryMaxAggregateOutputType | null
  }

  export type StockEventEntryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockEventEntrySumAggregateOutputType = {
    quantity: number | null
  }

  export type StockEventEntryMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    description: string | null
  }

  export type StockEventEntryMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    description: string | null
  }

  export type StockEventEntryCountAggregateOutputType = {
    id: number
    quantity: number
    description: number
    _all: number
  }


  export type StockEventEntryAvgAggregateInputType = {
    quantity?: true
  }

  export type StockEventEntrySumAggregateInputType = {
    quantity?: true
  }

  export type StockEventEntryMinAggregateInputType = {
    id?: true
    quantity?: true
    description?: true
  }

  export type StockEventEntryMaxAggregateInputType = {
    id?: true
    quantity?: true
    description?: true
  }

  export type StockEventEntryCountAggregateInputType = {
    id?: true
    quantity?: true
    description?: true
    _all?: true
  }

  export type StockEventEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockEventEntry to aggregate.
     */
    where?: StockEventEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEventEntries to fetch.
     */
    orderBy?: StockEventEntryOrderByWithRelationInput | StockEventEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockEventEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEventEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEventEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockEventEntries
    **/
    _count?: true | StockEventEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockEventEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockEventEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockEventEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockEventEntryMaxAggregateInputType
  }

  export type GetStockEventEntryAggregateType<T extends StockEventEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateStockEventEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockEventEntry[P]>
      : GetScalarType<T[P], AggregateStockEventEntry[P]>
  }




  export type StockEventEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockEventEntryWhereInput
    orderBy?: StockEventEntryOrderByWithAggregationInput | StockEventEntryOrderByWithAggregationInput[]
    by: StockEventEntryScalarFieldEnum[] | StockEventEntryScalarFieldEnum
    having?: StockEventEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockEventEntryCountAggregateInputType | true
    _avg?: StockEventEntryAvgAggregateInputType
    _sum?: StockEventEntrySumAggregateInputType
    _min?: StockEventEntryMinAggregateInputType
    _max?: StockEventEntryMaxAggregateInputType
  }

  export type StockEventEntryGroupByOutputType = {
    id: string
    quantity: number
    description: string
    _count: StockEventEntryCountAggregateOutputType | null
    _avg: StockEventEntryAvgAggregateOutputType | null
    _sum: StockEventEntrySumAggregateOutputType | null
    _min: StockEventEntryMinAggregateOutputType | null
    _max: StockEventEntryMaxAggregateOutputType | null
  }

  type GetStockEventEntryGroupByPayload<T extends StockEventEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockEventEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockEventEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockEventEntryGroupByOutputType[P]>
            : GetScalarType<T[P], StockEventEntryGroupByOutputType[P]>
        }
      >
    >


  export type StockEventEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    description?: boolean
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockEventEntry"]>

  export type StockEventEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    description?: boolean
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockEventEntry"]>

  export type StockEventEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    description?: boolean
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockEventEntry"]>

  export type StockEventEntrySelectScalar = {
    id?: boolean
    quantity?: boolean
    description?: boolean
  }

  export type StockEventEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "description", ExtArgs["result"]["stockEventEntry"]>
  export type StockEventEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }
  export type StockEventEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }
  export type StockEventEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }

  export type $StockEventEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockEventEntry"
    objects: {
      stockEvent: Prisma.$StockEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      description: string
    }, ExtArgs["result"]["stockEventEntry"]>
    composites: {}
  }

  type StockEventEntryGetPayload<S extends boolean | null | undefined | StockEventEntryDefaultArgs> = $Result.GetResult<Prisma.$StockEventEntryPayload, S>

  type StockEventEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockEventEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockEventEntryCountAggregateInputType | true
    }

  export interface StockEventEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockEventEntry'], meta: { name: 'StockEventEntry' } }
    /**
     * Find zero or one StockEventEntry that matches the filter.
     * @param {StockEventEntryFindUniqueArgs} args - Arguments to find a StockEventEntry
     * @example
     * // Get one StockEventEntry
     * const stockEventEntry = await prisma.stockEventEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockEventEntryFindUniqueArgs>(args: SelectSubset<T, StockEventEntryFindUniqueArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockEventEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockEventEntryFindUniqueOrThrowArgs} args - Arguments to find a StockEventEntry
     * @example
     * // Get one StockEventEntry
     * const stockEventEntry = await prisma.stockEventEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockEventEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, StockEventEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockEventEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventEntryFindFirstArgs} args - Arguments to find a StockEventEntry
     * @example
     * // Get one StockEventEntry
     * const stockEventEntry = await prisma.stockEventEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockEventEntryFindFirstArgs>(args?: SelectSubset<T, StockEventEntryFindFirstArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockEventEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventEntryFindFirstOrThrowArgs} args - Arguments to find a StockEventEntry
     * @example
     * // Get one StockEventEntry
     * const stockEventEntry = await prisma.stockEventEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockEventEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, StockEventEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockEventEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockEventEntries
     * const stockEventEntries = await prisma.stockEventEntry.findMany()
     * 
     * // Get first 10 StockEventEntries
     * const stockEventEntries = await prisma.stockEventEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockEventEntryWithIdOnly = await prisma.stockEventEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockEventEntryFindManyArgs>(args?: SelectSubset<T, StockEventEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockEventEntry.
     * @param {StockEventEntryCreateArgs} args - Arguments to create a StockEventEntry.
     * @example
     * // Create one StockEventEntry
     * const StockEventEntry = await prisma.stockEventEntry.create({
     *   data: {
     *     // ... data to create a StockEventEntry
     *   }
     * })
     * 
     */
    create<T extends StockEventEntryCreateArgs>(args: SelectSubset<T, StockEventEntryCreateArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockEventEntries.
     * @param {StockEventEntryCreateManyArgs} args - Arguments to create many StockEventEntries.
     * @example
     * // Create many StockEventEntries
     * const stockEventEntry = await prisma.stockEventEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockEventEntryCreateManyArgs>(args?: SelectSubset<T, StockEventEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockEventEntries and returns the data saved in the database.
     * @param {StockEventEntryCreateManyAndReturnArgs} args - Arguments to create many StockEventEntries.
     * @example
     * // Create many StockEventEntries
     * const stockEventEntry = await prisma.stockEventEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockEventEntries and only return the `id`
     * const stockEventEntryWithIdOnly = await prisma.stockEventEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockEventEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, StockEventEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockEventEntry.
     * @param {StockEventEntryDeleteArgs} args - Arguments to delete one StockEventEntry.
     * @example
     * // Delete one StockEventEntry
     * const StockEventEntry = await prisma.stockEventEntry.delete({
     *   where: {
     *     // ... filter to delete one StockEventEntry
     *   }
     * })
     * 
     */
    delete<T extends StockEventEntryDeleteArgs>(args: SelectSubset<T, StockEventEntryDeleteArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockEventEntry.
     * @param {StockEventEntryUpdateArgs} args - Arguments to update one StockEventEntry.
     * @example
     * // Update one StockEventEntry
     * const stockEventEntry = await prisma.stockEventEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockEventEntryUpdateArgs>(args: SelectSubset<T, StockEventEntryUpdateArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockEventEntries.
     * @param {StockEventEntryDeleteManyArgs} args - Arguments to filter StockEventEntries to delete.
     * @example
     * // Delete a few StockEventEntries
     * const { count } = await prisma.stockEventEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockEventEntryDeleteManyArgs>(args?: SelectSubset<T, StockEventEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockEventEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockEventEntries
     * const stockEventEntry = await prisma.stockEventEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockEventEntryUpdateManyArgs>(args: SelectSubset<T, StockEventEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockEventEntries and returns the data updated in the database.
     * @param {StockEventEntryUpdateManyAndReturnArgs} args - Arguments to update many StockEventEntries.
     * @example
     * // Update many StockEventEntries
     * const stockEventEntry = await prisma.stockEventEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockEventEntries and only return the `id`
     * const stockEventEntryWithIdOnly = await prisma.stockEventEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockEventEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, StockEventEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockEventEntry.
     * @param {StockEventEntryUpsertArgs} args - Arguments to update or create a StockEventEntry.
     * @example
     * // Update or create a StockEventEntry
     * const stockEventEntry = await prisma.stockEventEntry.upsert({
     *   create: {
     *     // ... data to create a StockEventEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockEventEntry we want to update
     *   }
     * })
     */
    upsert<T extends StockEventEntryUpsertArgs>(args: SelectSubset<T, StockEventEntryUpsertArgs<ExtArgs>>): Prisma__StockEventEntryClient<$Result.GetResult<Prisma.$StockEventEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockEventEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventEntryCountArgs} args - Arguments to filter StockEventEntries to count.
     * @example
     * // Count the number of StockEventEntries
     * const count = await prisma.stockEventEntry.count({
     *   where: {
     *     // ... the filter for the StockEventEntries we want to count
     *   }
     * })
    **/
    count<T extends StockEventEntryCountArgs>(
      args?: Subset<T, StockEventEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockEventEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockEventEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockEventEntryAggregateArgs>(args: Subset<T, StockEventEntryAggregateArgs>): Prisma.PrismaPromise<GetStockEventEntryAggregateType<T>>

    /**
     * Group by StockEventEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockEventEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockEventEntryGroupByArgs['orderBy'] }
        : { orderBy?: StockEventEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockEventEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockEventEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockEventEntry model
   */
  readonly fields: StockEventEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockEventEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockEventEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockEvent<T extends StockEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockEventDefaultArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockEventEntry model
   */
  interface StockEventEntryFieldRefs {
    readonly id: FieldRef<"StockEventEntry", 'String'>
    readonly quantity: FieldRef<"StockEventEntry", 'Int'>
    readonly description: FieldRef<"StockEventEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StockEventEntry findUnique
   */
  export type StockEventEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which StockEventEntry to fetch.
     */
    where: StockEventEntryWhereUniqueInput
  }

  /**
   * StockEventEntry findUniqueOrThrow
   */
  export type StockEventEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which StockEventEntry to fetch.
     */
    where: StockEventEntryWhereUniqueInput
  }

  /**
   * StockEventEntry findFirst
   */
  export type StockEventEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which StockEventEntry to fetch.
     */
    where?: StockEventEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEventEntries to fetch.
     */
    orderBy?: StockEventEntryOrderByWithRelationInput | StockEventEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockEventEntries.
     */
    cursor?: StockEventEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEventEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEventEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockEventEntries.
     */
    distinct?: StockEventEntryScalarFieldEnum | StockEventEntryScalarFieldEnum[]
  }

  /**
   * StockEventEntry findFirstOrThrow
   */
  export type StockEventEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which StockEventEntry to fetch.
     */
    where?: StockEventEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEventEntries to fetch.
     */
    orderBy?: StockEventEntryOrderByWithRelationInput | StockEventEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockEventEntries.
     */
    cursor?: StockEventEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEventEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEventEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockEventEntries.
     */
    distinct?: StockEventEntryScalarFieldEnum | StockEventEntryScalarFieldEnum[]
  }

  /**
   * StockEventEntry findMany
   */
  export type StockEventEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * Filter, which StockEventEntries to fetch.
     */
    where?: StockEventEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEventEntries to fetch.
     */
    orderBy?: StockEventEntryOrderByWithRelationInput | StockEventEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockEventEntries.
     */
    cursor?: StockEventEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEventEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEventEntries.
     */
    skip?: number
    distinct?: StockEventEntryScalarFieldEnum | StockEventEntryScalarFieldEnum[]
  }

  /**
   * StockEventEntry create
   */
  export type StockEventEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a StockEventEntry.
     */
    data: XOR<StockEventEntryCreateInput, StockEventEntryUncheckedCreateInput>
  }

  /**
   * StockEventEntry createMany
   */
  export type StockEventEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockEventEntries.
     */
    data: StockEventEntryCreateManyInput | StockEventEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockEventEntry createManyAndReturn
   */
  export type StockEventEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * The data used to create many StockEventEntries.
     */
    data: StockEventEntryCreateManyInput | StockEventEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockEventEntry update
   */
  export type StockEventEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a StockEventEntry.
     */
    data: XOR<StockEventEntryUpdateInput, StockEventEntryUncheckedUpdateInput>
    /**
     * Choose, which StockEventEntry to update.
     */
    where: StockEventEntryWhereUniqueInput
  }

  /**
   * StockEventEntry updateMany
   */
  export type StockEventEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockEventEntries.
     */
    data: XOR<StockEventEntryUpdateManyMutationInput, StockEventEntryUncheckedUpdateManyInput>
    /**
     * Filter which StockEventEntries to update
     */
    where?: StockEventEntryWhereInput
    /**
     * Limit how many StockEventEntries to update.
     */
    limit?: number
  }

  /**
   * StockEventEntry updateManyAndReturn
   */
  export type StockEventEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * The data used to update StockEventEntries.
     */
    data: XOR<StockEventEntryUpdateManyMutationInput, StockEventEntryUncheckedUpdateManyInput>
    /**
     * Filter which StockEventEntries to update
     */
    where?: StockEventEntryWhereInput
    /**
     * Limit how many StockEventEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockEventEntry upsert
   */
  export type StockEventEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the StockEventEntry to update in case it exists.
     */
    where: StockEventEntryWhereUniqueInput
    /**
     * In case the StockEventEntry found by the `where` argument doesn't exist, create a new StockEventEntry with this data.
     */
    create: XOR<StockEventEntryCreateInput, StockEventEntryUncheckedCreateInput>
    /**
     * In case the StockEventEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockEventEntryUpdateInput, StockEventEntryUncheckedUpdateInput>
  }

  /**
   * StockEventEntry delete
   */
  export type StockEventEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
    /**
     * Filter which StockEventEntry to delete.
     */
    where: StockEventEntryWhereUniqueInput
  }

  /**
   * StockEventEntry deleteMany
   */
  export type StockEventEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockEventEntries to delete
     */
    where?: StockEventEntryWhereInput
    /**
     * Limit how many StockEventEntries to delete.
     */
    limit?: number
  }

  /**
   * StockEventEntry without action
   */
  export type StockEventEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventEntry
     */
    select?: StockEventEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventEntry
     */
    omit?: StockEventEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventEntryInclude<ExtArgs> | null
  }


  /**
   * Model StockEventOutput
   */

  export type AggregateStockEventOutput = {
    _count: StockEventOutputCountAggregateOutputType | null
    _avg: StockEventOutputAvgAggregateOutputType | null
    _sum: StockEventOutputSumAggregateOutputType | null
    _min: StockEventOutputMinAggregateOutputType | null
    _max: StockEventOutputMaxAggregateOutputType | null
  }

  export type StockEventOutputAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockEventOutputSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockEventOutputMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    description: string | null
  }

  export type StockEventOutputMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    description: string | null
  }

  export type StockEventOutputCountAggregateOutputType = {
    id: number
    quantity: number
    description: number
    _all: number
  }


  export type StockEventOutputAvgAggregateInputType = {
    quantity?: true
  }

  export type StockEventOutputSumAggregateInputType = {
    quantity?: true
  }

  export type StockEventOutputMinAggregateInputType = {
    id?: true
    quantity?: true
    description?: true
  }

  export type StockEventOutputMaxAggregateInputType = {
    id?: true
    quantity?: true
    description?: true
  }

  export type StockEventOutputCountAggregateInputType = {
    id?: true
    quantity?: true
    description?: true
    _all?: true
  }

  export type StockEventOutputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockEventOutput to aggregate.
     */
    where?: StockEventOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEventOutputs to fetch.
     */
    orderBy?: StockEventOutputOrderByWithRelationInput | StockEventOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockEventOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEventOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEventOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockEventOutputs
    **/
    _count?: true | StockEventOutputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockEventOutputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockEventOutputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockEventOutputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockEventOutputMaxAggregateInputType
  }

  export type GetStockEventOutputAggregateType<T extends StockEventOutputAggregateArgs> = {
        [P in keyof T & keyof AggregateStockEventOutput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockEventOutput[P]>
      : GetScalarType<T[P], AggregateStockEventOutput[P]>
  }




  export type StockEventOutputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockEventOutputWhereInput
    orderBy?: StockEventOutputOrderByWithAggregationInput | StockEventOutputOrderByWithAggregationInput[]
    by: StockEventOutputScalarFieldEnum[] | StockEventOutputScalarFieldEnum
    having?: StockEventOutputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockEventOutputCountAggregateInputType | true
    _avg?: StockEventOutputAvgAggregateInputType
    _sum?: StockEventOutputSumAggregateInputType
    _min?: StockEventOutputMinAggregateInputType
    _max?: StockEventOutputMaxAggregateInputType
  }

  export type StockEventOutputGroupByOutputType = {
    id: string
    quantity: number
    description: string
    _count: StockEventOutputCountAggregateOutputType | null
    _avg: StockEventOutputAvgAggregateOutputType | null
    _sum: StockEventOutputSumAggregateOutputType | null
    _min: StockEventOutputMinAggregateOutputType | null
    _max: StockEventOutputMaxAggregateOutputType | null
  }

  type GetStockEventOutputGroupByPayload<T extends StockEventOutputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockEventOutputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockEventOutputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockEventOutputGroupByOutputType[P]>
            : GetScalarType<T[P], StockEventOutputGroupByOutputType[P]>
        }
      >
    >


  export type StockEventOutputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    description?: boolean
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockEventOutput"]>

  export type StockEventOutputSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    description?: boolean
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockEventOutput"]>

  export type StockEventOutputSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    description?: boolean
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockEventOutput"]>

  export type StockEventOutputSelectScalar = {
    id?: boolean
    quantity?: boolean
    description?: boolean
  }

  export type StockEventOutputOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quantity" | "description", ExtArgs["result"]["stockEventOutput"]>
  export type StockEventOutputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }
  export type StockEventOutputIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }
  export type StockEventOutputIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockEvent?: boolean | StockEventDefaultArgs<ExtArgs>
  }

  export type $StockEventOutputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockEventOutput"
    objects: {
      stockEvent: Prisma.$StockEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      description: string
    }, ExtArgs["result"]["stockEventOutput"]>
    composites: {}
  }

  type StockEventOutputGetPayload<S extends boolean | null | undefined | StockEventOutputDefaultArgs> = $Result.GetResult<Prisma.$StockEventOutputPayload, S>

  type StockEventOutputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockEventOutputFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockEventOutputCountAggregateInputType | true
    }

  export interface StockEventOutputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockEventOutput'], meta: { name: 'StockEventOutput' } }
    /**
     * Find zero or one StockEventOutput that matches the filter.
     * @param {StockEventOutputFindUniqueArgs} args - Arguments to find a StockEventOutput
     * @example
     * // Get one StockEventOutput
     * const stockEventOutput = await prisma.stockEventOutput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockEventOutputFindUniqueArgs>(args: SelectSubset<T, StockEventOutputFindUniqueArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockEventOutput that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockEventOutputFindUniqueOrThrowArgs} args - Arguments to find a StockEventOutput
     * @example
     * // Get one StockEventOutput
     * const stockEventOutput = await prisma.stockEventOutput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockEventOutputFindUniqueOrThrowArgs>(args: SelectSubset<T, StockEventOutputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockEventOutput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventOutputFindFirstArgs} args - Arguments to find a StockEventOutput
     * @example
     * // Get one StockEventOutput
     * const stockEventOutput = await prisma.stockEventOutput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockEventOutputFindFirstArgs>(args?: SelectSubset<T, StockEventOutputFindFirstArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockEventOutput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventOutputFindFirstOrThrowArgs} args - Arguments to find a StockEventOutput
     * @example
     * // Get one StockEventOutput
     * const stockEventOutput = await prisma.stockEventOutput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockEventOutputFindFirstOrThrowArgs>(args?: SelectSubset<T, StockEventOutputFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockEventOutputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventOutputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockEventOutputs
     * const stockEventOutputs = await prisma.stockEventOutput.findMany()
     * 
     * // Get first 10 StockEventOutputs
     * const stockEventOutputs = await prisma.stockEventOutput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockEventOutputWithIdOnly = await prisma.stockEventOutput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockEventOutputFindManyArgs>(args?: SelectSubset<T, StockEventOutputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockEventOutput.
     * @param {StockEventOutputCreateArgs} args - Arguments to create a StockEventOutput.
     * @example
     * // Create one StockEventOutput
     * const StockEventOutput = await prisma.stockEventOutput.create({
     *   data: {
     *     // ... data to create a StockEventOutput
     *   }
     * })
     * 
     */
    create<T extends StockEventOutputCreateArgs>(args: SelectSubset<T, StockEventOutputCreateArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockEventOutputs.
     * @param {StockEventOutputCreateManyArgs} args - Arguments to create many StockEventOutputs.
     * @example
     * // Create many StockEventOutputs
     * const stockEventOutput = await prisma.stockEventOutput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockEventOutputCreateManyArgs>(args?: SelectSubset<T, StockEventOutputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockEventOutputs and returns the data saved in the database.
     * @param {StockEventOutputCreateManyAndReturnArgs} args - Arguments to create many StockEventOutputs.
     * @example
     * // Create many StockEventOutputs
     * const stockEventOutput = await prisma.stockEventOutput.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockEventOutputs and only return the `id`
     * const stockEventOutputWithIdOnly = await prisma.stockEventOutput.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockEventOutputCreateManyAndReturnArgs>(args?: SelectSubset<T, StockEventOutputCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockEventOutput.
     * @param {StockEventOutputDeleteArgs} args - Arguments to delete one StockEventOutput.
     * @example
     * // Delete one StockEventOutput
     * const StockEventOutput = await prisma.stockEventOutput.delete({
     *   where: {
     *     // ... filter to delete one StockEventOutput
     *   }
     * })
     * 
     */
    delete<T extends StockEventOutputDeleteArgs>(args: SelectSubset<T, StockEventOutputDeleteArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockEventOutput.
     * @param {StockEventOutputUpdateArgs} args - Arguments to update one StockEventOutput.
     * @example
     * // Update one StockEventOutput
     * const stockEventOutput = await prisma.stockEventOutput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockEventOutputUpdateArgs>(args: SelectSubset<T, StockEventOutputUpdateArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockEventOutputs.
     * @param {StockEventOutputDeleteManyArgs} args - Arguments to filter StockEventOutputs to delete.
     * @example
     * // Delete a few StockEventOutputs
     * const { count } = await prisma.stockEventOutput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockEventOutputDeleteManyArgs>(args?: SelectSubset<T, StockEventOutputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockEventOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventOutputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockEventOutputs
     * const stockEventOutput = await prisma.stockEventOutput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockEventOutputUpdateManyArgs>(args: SelectSubset<T, StockEventOutputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockEventOutputs and returns the data updated in the database.
     * @param {StockEventOutputUpdateManyAndReturnArgs} args - Arguments to update many StockEventOutputs.
     * @example
     * // Update many StockEventOutputs
     * const stockEventOutput = await prisma.stockEventOutput.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockEventOutputs and only return the `id`
     * const stockEventOutputWithIdOnly = await prisma.stockEventOutput.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockEventOutputUpdateManyAndReturnArgs>(args: SelectSubset<T, StockEventOutputUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockEventOutput.
     * @param {StockEventOutputUpsertArgs} args - Arguments to update or create a StockEventOutput.
     * @example
     * // Update or create a StockEventOutput
     * const stockEventOutput = await prisma.stockEventOutput.upsert({
     *   create: {
     *     // ... data to create a StockEventOutput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockEventOutput we want to update
     *   }
     * })
     */
    upsert<T extends StockEventOutputUpsertArgs>(args: SelectSubset<T, StockEventOutputUpsertArgs<ExtArgs>>): Prisma__StockEventOutputClient<$Result.GetResult<Prisma.$StockEventOutputPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockEventOutputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventOutputCountArgs} args - Arguments to filter StockEventOutputs to count.
     * @example
     * // Count the number of StockEventOutputs
     * const count = await prisma.stockEventOutput.count({
     *   where: {
     *     // ... the filter for the StockEventOutputs we want to count
     *   }
     * })
    **/
    count<T extends StockEventOutputCountArgs>(
      args?: Subset<T, StockEventOutputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockEventOutputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockEventOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventOutputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockEventOutputAggregateArgs>(args: Subset<T, StockEventOutputAggregateArgs>): Prisma.PrismaPromise<GetStockEventOutputAggregateType<T>>

    /**
     * Group by StockEventOutput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockEventOutputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockEventOutputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockEventOutputGroupByArgs['orderBy'] }
        : { orderBy?: StockEventOutputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockEventOutputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockEventOutputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockEventOutput model
   */
  readonly fields: StockEventOutputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockEventOutput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockEventOutputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockEvent<T extends StockEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockEventDefaultArgs<ExtArgs>>): Prisma__StockEventClient<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockEventOutput model
   */
  interface StockEventOutputFieldRefs {
    readonly id: FieldRef<"StockEventOutput", 'String'>
    readonly quantity: FieldRef<"StockEventOutput", 'Int'>
    readonly description: FieldRef<"StockEventOutput", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StockEventOutput findUnique
   */
  export type StockEventOutputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which StockEventOutput to fetch.
     */
    where: StockEventOutputWhereUniqueInput
  }

  /**
   * StockEventOutput findUniqueOrThrow
   */
  export type StockEventOutputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which StockEventOutput to fetch.
     */
    where: StockEventOutputWhereUniqueInput
  }

  /**
   * StockEventOutput findFirst
   */
  export type StockEventOutputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which StockEventOutput to fetch.
     */
    where?: StockEventOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEventOutputs to fetch.
     */
    orderBy?: StockEventOutputOrderByWithRelationInput | StockEventOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockEventOutputs.
     */
    cursor?: StockEventOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEventOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEventOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockEventOutputs.
     */
    distinct?: StockEventOutputScalarFieldEnum | StockEventOutputScalarFieldEnum[]
  }

  /**
   * StockEventOutput findFirstOrThrow
   */
  export type StockEventOutputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which StockEventOutput to fetch.
     */
    where?: StockEventOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEventOutputs to fetch.
     */
    orderBy?: StockEventOutputOrderByWithRelationInput | StockEventOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockEventOutputs.
     */
    cursor?: StockEventOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEventOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEventOutputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockEventOutputs.
     */
    distinct?: StockEventOutputScalarFieldEnum | StockEventOutputScalarFieldEnum[]
  }

  /**
   * StockEventOutput findMany
   */
  export type StockEventOutputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * Filter, which StockEventOutputs to fetch.
     */
    where?: StockEventOutputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockEventOutputs to fetch.
     */
    orderBy?: StockEventOutputOrderByWithRelationInput | StockEventOutputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockEventOutputs.
     */
    cursor?: StockEventOutputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockEventOutputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockEventOutputs.
     */
    skip?: number
    distinct?: StockEventOutputScalarFieldEnum | StockEventOutputScalarFieldEnum[]
  }

  /**
   * StockEventOutput create
   */
  export type StockEventOutputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * The data needed to create a StockEventOutput.
     */
    data: XOR<StockEventOutputCreateInput, StockEventOutputUncheckedCreateInput>
  }

  /**
   * StockEventOutput createMany
   */
  export type StockEventOutputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockEventOutputs.
     */
    data: StockEventOutputCreateManyInput | StockEventOutputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockEventOutput createManyAndReturn
   */
  export type StockEventOutputCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * The data used to create many StockEventOutputs.
     */
    data: StockEventOutputCreateManyInput | StockEventOutputCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockEventOutput update
   */
  export type StockEventOutputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * The data needed to update a StockEventOutput.
     */
    data: XOR<StockEventOutputUpdateInput, StockEventOutputUncheckedUpdateInput>
    /**
     * Choose, which StockEventOutput to update.
     */
    where: StockEventOutputWhereUniqueInput
  }

  /**
   * StockEventOutput updateMany
   */
  export type StockEventOutputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockEventOutputs.
     */
    data: XOR<StockEventOutputUpdateManyMutationInput, StockEventOutputUncheckedUpdateManyInput>
    /**
     * Filter which StockEventOutputs to update
     */
    where?: StockEventOutputWhereInput
    /**
     * Limit how many StockEventOutputs to update.
     */
    limit?: number
  }

  /**
   * StockEventOutput updateManyAndReturn
   */
  export type StockEventOutputUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * The data used to update StockEventOutputs.
     */
    data: XOR<StockEventOutputUpdateManyMutationInput, StockEventOutputUncheckedUpdateManyInput>
    /**
     * Filter which StockEventOutputs to update
     */
    where?: StockEventOutputWhereInput
    /**
     * Limit how many StockEventOutputs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockEventOutput upsert
   */
  export type StockEventOutputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * The filter to search for the StockEventOutput to update in case it exists.
     */
    where: StockEventOutputWhereUniqueInput
    /**
     * In case the StockEventOutput found by the `where` argument doesn't exist, create a new StockEventOutput with this data.
     */
    create: XOR<StockEventOutputCreateInput, StockEventOutputUncheckedCreateInput>
    /**
     * In case the StockEventOutput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockEventOutputUpdateInput, StockEventOutputUncheckedUpdateInput>
  }

  /**
   * StockEventOutput delete
   */
  export type StockEventOutputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
    /**
     * Filter which StockEventOutput to delete.
     */
    where: StockEventOutputWhereUniqueInput
  }

  /**
   * StockEventOutput deleteMany
   */
  export type StockEventOutputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockEventOutputs to delete
     */
    where?: StockEventOutputWhereInput
    /**
     * Limit how many StockEventOutputs to delete.
     */
    limit?: number
  }

  /**
   * StockEventOutput without action
   */
  export type StockEventOutputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEventOutput
     */
    select?: StockEventOutputSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEventOutput
     */
    omit?: StockEventOutputOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventOutputInclude<ExtArgs> | null
  }


  /**
   * Model StockLot
   */

  export type AggregateStockLot = {
    _count: StockLotCountAggregateOutputType | null
    _avg: StockLotAvgAggregateOutputType | null
    _sum: StockLotSumAggregateOutputType | null
    _min: StockLotMinAggregateOutputType | null
    _max: StockLotMaxAggregateOutputType | null
  }

  export type StockLotAvgAggregateOutputType = {
    totalQty: number | null
    costPrice: Decimal | null
  }

  export type StockLotSumAggregateOutputType = {
    totalQty: number | null
    costPrice: Decimal | null
  }

  export type StockLotMinAggregateOutputType = {
    id: string | null
    lotNumber: string | null
    totalQty: number | null
    costPrice: Decimal | null
    stockId: string | null
    tenantId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockLotMaxAggregateOutputType = {
    id: string | null
    lotNumber: string | null
    totalQty: number | null
    costPrice: Decimal | null
    stockId: string | null
    tenantId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockLotCountAggregateOutputType = {
    id: number
    lotNumber: number
    totalQty: number
    costPrice: number
    stockId: number
    tenantId: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockLotAvgAggregateInputType = {
    totalQty?: true
    costPrice?: true
  }

  export type StockLotSumAggregateInputType = {
    totalQty?: true
    costPrice?: true
  }

  export type StockLotMinAggregateInputType = {
    id?: true
    lotNumber?: true
    totalQty?: true
    costPrice?: true
    stockId?: true
    tenantId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockLotMaxAggregateInputType = {
    id?: true
    lotNumber?: true
    totalQty?: true
    costPrice?: true
    stockId?: true
    tenantId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockLotCountAggregateInputType = {
    id?: true
    lotNumber?: true
    totalQty?: true
    costPrice?: true
    stockId?: true
    tenantId?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockLotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLot to aggregate.
     */
    where?: StockLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLots to fetch.
     */
    orderBy?: StockLotOrderByWithRelationInput | StockLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockLots
    **/
    _count?: true | StockLotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockLotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockLotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockLotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockLotMaxAggregateInputType
  }

  export type GetStockLotAggregateType<T extends StockLotAggregateArgs> = {
        [P in keyof T & keyof AggregateStockLot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockLot[P]>
      : GetScalarType<T[P], AggregateStockLot[P]>
  }




  export type StockLotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockLotWhereInput
    orderBy?: StockLotOrderByWithAggregationInput | StockLotOrderByWithAggregationInput[]
    by: StockLotScalarFieldEnum[] | StockLotScalarFieldEnum
    having?: StockLotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockLotCountAggregateInputType | true
    _avg?: StockLotAvgAggregateInputType
    _sum?: StockLotSumAggregateInputType
    _min?: StockLotMinAggregateInputType
    _max?: StockLotMaxAggregateInputType
  }

  export type StockLotGroupByOutputType = {
    id: string
    lotNumber: string
    totalQty: number
    costPrice: Decimal
    stockId: string
    tenantId: string
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StockLotCountAggregateOutputType | null
    _avg: StockLotAvgAggregateOutputType | null
    _sum: StockLotSumAggregateOutputType | null
    _min: StockLotMinAggregateOutputType | null
    _max: StockLotMaxAggregateOutputType | null
  }

  type GetStockLotGroupByPayload<T extends StockLotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockLotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockLotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockLotGroupByOutputType[P]>
            : GetScalarType<T[P], StockLotGroupByOutputType[P]>
        }
      >
    >


  export type StockLotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lotNumber?: boolean
    totalQty?: boolean
    costPrice?: boolean
    stockId?: boolean
    tenantId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    stockEvents?: boolean | StockLot$stockEventsArgs<ExtArgs>
    saleProduct?: boolean | StockLot$saleProductArgs<ExtArgs>
    _count?: boolean | StockLotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockLot"]>

  export type StockLotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lotNumber?: boolean
    totalQty?: boolean
    costPrice?: boolean
    stockId?: boolean
    tenantId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockLot"]>

  export type StockLotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lotNumber?: boolean
    totalQty?: boolean
    costPrice?: boolean
    stockId?: boolean
    tenantId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockLot"]>

  export type StockLotSelectScalar = {
    id?: boolean
    lotNumber?: boolean
    totalQty?: boolean
    costPrice?: boolean
    stockId?: boolean
    tenantId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockLotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lotNumber" | "totalQty" | "costPrice" | "stockId" | "tenantId" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["stockLot"]>
  export type StockLotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    stockEvents?: boolean | StockLot$stockEventsArgs<ExtArgs>
    saleProduct?: boolean | StockLot$saleProductArgs<ExtArgs>
    _count?: boolean | StockLotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StockLotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type StockLotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock?: boolean | StockDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $StockLotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockLot"
    objects: {
      stock: Prisma.$StockPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
      stockEvents: Prisma.$StockEventPayload<ExtArgs>[]
      saleProduct: Prisma.$SaleProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lotNumber: string
      totalQty: number
      costPrice: Prisma.Decimal
      stockId: string
      tenantId: string
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockLot"]>
    composites: {}
  }

  type StockLotGetPayload<S extends boolean | null | undefined | StockLotDefaultArgs> = $Result.GetResult<Prisma.$StockLotPayload, S>

  type StockLotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockLotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockLotCountAggregateInputType | true
    }

  export interface StockLotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockLot'], meta: { name: 'StockLot' } }
    /**
     * Find zero or one StockLot that matches the filter.
     * @param {StockLotFindUniqueArgs} args - Arguments to find a StockLot
     * @example
     * // Get one StockLot
     * const stockLot = await prisma.stockLot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockLotFindUniqueArgs>(args: SelectSubset<T, StockLotFindUniqueArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockLot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockLotFindUniqueOrThrowArgs} args - Arguments to find a StockLot
     * @example
     * // Get one StockLot
     * const stockLot = await prisma.stockLot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockLotFindUniqueOrThrowArgs>(args: SelectSubset<T, StockLotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockLot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLotFindFirstArgs} args - Arguments to find a StockLot
     * @example
     * // Get one StockLot
     * const stockLot = await prisma.stockLot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockLotFindFirstArgs>(args?: SelectSubset<T, StockLotFindFirstArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockLot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLotFindFirstOrThrowArgs} args - Arguments to find a StockLot
     * @example
     * // Get one StockLot
     * const stockLot = await prisma.stockLot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockLotFindFirstOrThrowArgs>(args?: SelectSubset<T, StockLotFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockLots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockLots
     * const stockLots = await prisma.stockLot.findMany()
     * 
     * // Get first 10 StockLots
     * const stockLots = await prisma.stockLot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockLotWithIdOnly = await prisma.stockLot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockLotFindManyArgs>(args?: SelectSubset<T, StockLotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockLot.
     * @param {StockLotCreateArgs} args - Arguments to create a StockLot.
     * @example
     * // Create one StockLot
     * const StockLot = await prisma.stockLot.create({
     *   data: {
     *     // ... data to create a StockLot
     *   }
     * })
     * 
     */
    create<T extends StockLotCreateArgs>(args: SelectSubset<T, StockLotCreateArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockLots.
     * @param {StockLotCreateManyArgs} args - Arguments to create many StockLots.
     * @example
     * // Create many StockLots
     * const stockLot = await prisma.stockLot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockLotCreateManyArgs>(args?: SelectSubset<T, StockLotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockLots and returns the data saved in the database.
     * @param {StockLotCreateManyAndReturnArgs} args - Arguments to create many StockLots.
     * @example
     * // Create many StockLots
     * const stockLot = await prisma.stockLot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockLots and only return the `id`
     * const stockLotWithIdOnly = await prisma.stockLot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockLotCreateManyAndReturnArgs>(args?: SelectSubset<T, StockLotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockLot.
     * @param {StockLotDeleteArgs} args - Arguments to delete one StockLot.
     * @example
     * // Delete one StockLot
     * const StockLot = await prisma.stockLot.delete({
     *   where: {
     *     // ... filter to delete one StockLot
     *   }
     * })
     * 
     */
    delete<T extends StockLotDeleteArgs>(args: SelectSubset<T, StockLotDeleteArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockLot.
     * @param {StockLotUpdateArgs} args - Arguments to update one StockLot.
     * @example
     * // Update one StockLot
     * const stockLot = await prisma.stockLot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockLotUpdateArgs>(args: SelectSubset<T, StockLotUpdateArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockLots.
     * @param {StockLotDeleteManyArgs} args - Arguments to filter StockLots to delete.
     * @example
     * // Delete a few StockLots
     * const { count } = await prisma.stockLot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockLotDeleteManyArgs>(args?: SelectSubset<T, StockLotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockLots
     * const stockLot = await prisma.stockLot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockLotUpdateManyArgs>(args: SelectSubset<T, StockLotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockLots and returns the data updated in the database.
     * @param {StockLotUpdateManyAndReturnArgs} args - Arguments to update many StockLots.
     * @example
     * // Update many StockLots
     * const stockLot = await prisma.stockLot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockLots and only return the `id`
     * const stockLotWithIdOnly = await prisma.stockLot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockLotUpdateManyAndReturnArgs>(args: SelectSubset<T, StockLotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockLot.
     * @param {StockLotUpsertArgs} args - Arguments to update or create a StockLot.
     * @example
     * // Update or create a StockLot
     * const stockLot = await prisma.stockLot.upsert({
     *   create: {
     *     // ... data to create a StockLot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockLot we want to update
     *   }
     * })
     */
    upsert<T extends StockLotUpsertArgs>(args: SelectSubset<T, StockLotUpsertArgs<ExtArgs>>): Prisma__StockLotClient<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockLots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLotCountArgs} args - Arguments to filter StockLots to count.
     * @example
     * // Count the number of StockLots
     * const count = await prisma.stockLot.count({
     *   where: {
     *     // ... the filter for the StockLots we want to count
     *   }
     * })
    **/
    count<T extends StockLotCountArgs>(
      args?: Subset<T, StockLotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockLotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockLot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockLotAggregateArgs>(args: Subset<T, StockLotAggregateArgs>): Prisma.PrismaPromise<GetStockLotAggregateType<T>>

    /**
     * Group by StockLot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockLotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockLotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockLotGroupByArgs['orderBy'] }
        : { orderBy?: StockLotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockLotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockLotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockLot model
   */
  readonly fields: StockLotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockLot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockLotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock<T extends StockDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockDefaultArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stockEvents<T extends StockLot$stockEventsArgs<ExtArgs> = {}>(args?: Subset<T, StockLot$stockEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleProduct<T extends StockLot$saleProductArgs<ExtArgs> = {}>(args?: Subset<T, StockLot$saleProductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockLot model
   */
  interface StockLotFieldRefs {
    readonly id: FieldRef<"StockLot", 'String'>
    readonly lotNumber: FieldRef<"StockLot", 'String'>
    readonly totalQty: FieldRef<"StockLot", 'Int'>
    readonly costPrice: FieldRef<"StockLot", 'Decimal'>
    readonly stockId: FieldRef<"StockLot", 'String'>
    readonly tenantId: FieldRef<"StockLot", 'String'>
    readonly expiresAt: FieldRef<"StockLot", 'DateTime'>
    readonly createdAt: FieldRef<"StockLot", 'DateTime'>
    readonly updatedAt: FieldRef<"StockLot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockLot findUnique
   */
  export type StockLotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * Filter, which StockLot to fetch.
     */
    where: StockLotWhereUniqueInput
  }

  /**
   * StockLot findUniqueOrThrow
   */
  export type StockLotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * Filter, which StockLot to fetch.
     */
    where: StockLotWhereUniqueInput
  }

  /**
   * StockLot findFirst
   */
  export type StockLotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * Filter, which StockLot to fetch.
     */
    where?: StockLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLots to fetch.
     */
    orderBy?: StockLotOrderByWithRelationInput | StockLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLots.
     */
    cursor?: StockLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLots.
     */
    distinct?: StockLotScalarFieldEnum | StockLotScalarFieldEnum[]
  }

  /**
   * StockLot findFirstOrThrow
   */
  export type StockLotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * Filter, which StockLot to fetch.
     */
    where?: StockLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLots to fetch.
     */
    orderBy?: StockLotOrderByWithRelationInput | StockLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockLots.
     */
    cursor?: StockLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockLots.
     */
    distinct?: StockLotScalarFieldEnum | StockLotScalarFieldEnum[]
  }

  /**
   * StockLot findMany
   */
  export type StockLotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * Filter, which StockLots to fetch.
     */
    where?: StockLotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockLots to fetch.
     */
    orderBy?: StockLotOrderByWithRelationInput | StockLotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockLots.
     */
    cursor?: StockLotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockLots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockLots.
     */
    skip?: number
    distinct?: StockLotScalarFieldEnum | StockLotScalarFieldEnum[]
  }

  /**
   * StockLot create
   */
  export type StockLotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * The data needed to create a StockLot.
     */
    data: XOR<StockLotCreateInput, StockLotUncheckedCreateInput>
  }

  /**
   * StockLot createMany
   */
  export type StockLotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockLots.
     */
    data: StockLotCreateManyInput | StockLotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockLot createManyAndReturn
   */
  export type StockLotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * The data used to create many StockLots.
     */
    data: StockLotCreateManyInput | StockLotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockLot update
   */
  export type StockLotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * The data needed to update a StockLot.
     */
    data: XOR<StockLotUpdateInput, StockLotUncheckedUpdateInput>
    /**
     * Choose, which StockLot to update.
     */
    where: StockLotWhereUniqueInput
  }

  /**
   * StockLot updateMany
   */
  export type StockLotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockLots.
     */
    data: XOR<StockLotUpdateManyMutationInput, StockLotUncheckedUpdateManyInput>
    /**
     * Filter which StockLots to update
     */
    where?: StockLotWhereInput
    /**
     * Limit how many StockLots to update.
     */
    limit?: number
  }

  /**
   * StockLot updateManyAndReturn
   */
  export type StockLotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * The data used to update StockLots.
     */
    data: XOR<StockLotUpdateManyMutationInput, StockLotUncheckedUpdateManyInput>
    /**
     * Filter which StockLots to update
     */
    where?: StockLotWhereInput
    /**
     * Limit how many StockLots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockLot upsert
   */
  export type StockLotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * The filter to search for the StockLot to update in case it exists.
     */
    where: StockLotWhereUniqueInput
    /**
     * In case the StockLot found by the `where` argument doesn't exist, create a new StockLot with this data.
     */
    create: XOR<StockLotCreateInput, StockLotUncheckedCreateInput>
    /**
     * In case the StockLot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockLotUpdateInput, StockLotUncheckedUpdateInput>
  }

  /**
   * StockLot delete
   */
  export type StockLotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    /**
     * Filter which StockLot to delete.
     */
    where: StockLotWhereUniqueInput
  }

  /**
   * StockLot deleteMany
   */
  export type StockLotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockLots to delete
     */
    where?: StockLotWhereInput
    /**
     * Limit how many StockLots to delete.
     */
    limit?: number
  }

  /**
   * StockLot.stockEvents
   */
  export type StockLot$stockEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    where?: StockEventWhereInput
    orderBy?: StockEventOrderByWithRelationInput | StockEventOrderByWithRelationInput[]
    cursor?: StockEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockEventScalarFieldEnum | StockEventScalarFieldEnum[]
  }

  /**
   * StockLot.saleProduct
   */
  export type StockLot$saleProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleProduct
     */
    select?: SaleProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleProduct
     */
    omit?: SaleProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleProductInclude<ExtArgs> | null
    where?: SaleProductWhereInput
    orderBy?: SaleProductOrderByWithRelationInput | SaleProductOrderByWithRelationInput[]
    cursor?: SaleProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleProductScalarFieldEnum | SaleProductScalarFieldEnum[]
  }

  /**
   * StockLot without action
   */
  export type StockLotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    description: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    description: string | null
    active: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    memberships?: boolean | Tenant$membershipsArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    products?: boolean | Tenant$productsArgs<ExtArgs>
    sales?: boolean | Tenant$salesArgs<ExtArgs>
    stocks?: boolean | Tenant$stocksArgs<ExtArgs>
    stockLots?: boolean | Tenant$stockLotsArgs<ExtArgs>
    StockEvent?: boolean | Tenant$StockEventArgs<ExtArgs>
    NotificationTarget?: boolean | Tenant$NotificationTargetArgs<ExtArgs>
    UserTenantSettings?: boolean | Tenant$UserTenantSettingsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | Tenant$membershipsArgs<ExtArgs>
    customers?: boolean | Tenant$customersArgs<ExtArgs>
    products?: boolean | Tenant$productsArgs<ExtArgs>
    sales?: boolean | Tenant$salesArgs<ExtArgs>
    stocks?: boolean | Tenant$stocksArgs<ExtArgs>
    stockLots?: boolean | Tenant$stockLotsArgs<ExtArgs>
    StockEvent?: boolean | Tenant$StockEventArgs<ExtArgs>
    NotificationTarget?: boolean | Tenant$NotificationTargetArgs<ExtArgs>
    UserTenantSettings?: boolean | Tenant$UserTenantSettingsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      memberships: Prisma.$TenantMembershipPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      stocks: Prisma.$StockPayload<ExtArgs>[]
      stockLots: Prisma.$StockLotPayload<ExtArgs>[]
      StockEvent: Prisma.$StockEventPayload<ExtArgs>[]
      NotificationTarget: Prisma.$NotificationTargetPayload<ExtArgs>[]
      UserTenantSettings: Prisma.$UserTenantSettingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      active: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberships<T extends Tenant$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Tenant$customersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Tenant$productsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends Tenant$salesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stocks<T extends Tenant$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockLots<T extends Tenant$stockLotsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$stockLotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockLotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StockEvent<T extends Tenant$StockEventArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$StockEventArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationTarget<T extends Tenant$NotificationTargetArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$NotificationTargetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UserTenantSettings<T extends Tenant$UserTenantSettingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$UserTenantSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly description: FieldRef<"Tenant", 'String'>
    readonly active: FieldRef<"Tenant", 'Boolean'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.memberships
   */
  export type Tenant$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    where?: TenantMembershipWhereInput
    orderBy?: TenantMembershipOrderByWithRelationInput | TenantMembershipOrderByWithRelationInput[]
    cursor?: TenantMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TenantMembershipScalarFieldEnum | TenantMembershipScalarFieldEnum[]
  }

  /**
   * Tenant.customers
   */
  export type Tenant$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Tenant.products
   */
  export type Tenant$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Tenant.sales
   */
  export type Tenant$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Tenant.stocks
   */
  export type Tenant$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Tenant.stockLots
   */
  export type Tenant$stockLotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockLot
     */
    select?: StockLotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockLot
     */
    omit?: StockLotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockLotInclude<ExtArgs> | null
    where?: StockLotWhereInput
    orderBy?: StockLotOrderByWithRelationInput | StockLotOrderByWithRelationInput[]
    cursor?: StockLotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockLotScalarFieldEnum | StockLotScalarFieldEnum[]
  }

  /**
   * Tenant.StockEvent
   */
  export type Tenant$StockEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockEvent
     */
    select?: StockEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockEvent
     */
    omit?: StockEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockEventInclude<ExtArgs> | null
    where?: StockEventWhereInput
    orderBy?: StockEventOrderByWithRelationInput | StockEventOrderByWithRelationInput[]
    cursor?: StockEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockEventScalarFieldEnum | StockEventScalarFieldEnum[]
  }

  /**
   * Tenant.NotificationTarget
   */
  export type Tenant$NotificationTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    where?: NotificationTargetWhereInput
    orderBy?: NotificationTargetOrderByWithRelationInput | NotificationTargetOrderByWithRelationInput[]
    cursor?: NotificationTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationTargetScalarFieldEnum | NotificationTargetScalarFieldEnum[]
  }

  /**
   * Tenant.UserTenantSettings
   */
  export type Tenant$UserTenantSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    where?: UserTenantSettingsWhereInput
    orderBy?: UserTenantSettingsOrderByWithRelationInput | UserTenantSettingsOrderByWithRelationInput[]
    cursor?: UserTenantSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTenantSettingsScalarFieldEnum | UserTenantSettingsScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model TenantMembership
   */

  export type AggregateTenantMembership = {
    _count: TenantMembershipCountAggregateOutputType | null
    _min: TenantMembershipMinAggregateOutputType | null
    _max: TenantMembershipMaxAggregateOutputType | null
  }

  export type TenantMembershipMinAggregateOutputType = {
    membershipId: string | null
    tenantId: string | null
  }

  export type TenantMembershipMaxAggregateOutputType = {
    membershipId: string | null
    tenantId: string | null
  }

  export type TenantMembershipCountAggregateOutputType = {
    membershipId: number
    tenantId: number
    _all: number
  }


  export type TenantMembershipMinAggregateInputType = {
    membershipId?: true
    tenantId?: true
  }

  export type TenantMembershipMaxAggregateInputType = {
    membershipId?: true
    tenantId?: true
  }

  export type TenantMembershipCountAggregateInputType = {
    membershipId?: true
    tenantId?: true
    _all?: true
  }

  export type TenantMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantMembership to aggregate.
     */
    where?: TenantMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantMemberships to fetch.
     */
    orderBy?: TenantMembershipOrderByWithRelationInput | TenantMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TenantMemberships
    **/
    _count?: true | TenantMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMembershipMaxAggregateInputType
  }

  export type GetTenantMembershipAggregateType<T extends TenantMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateTenantMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenantMembership[P]>
      : GetScalarType<T[P], AggregateTenantMembership[P]>
  }




  export type TenantMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantMembershipWhereInput
    orderBy?: TenantMembershipOrderByWithAggregationInput | TenantMembershipOrderByWithAggregationInput[]
    by: TenantMembershipScalarFieldEnum[] | TenantMembershipScalarFieldEnum
    having?: TenantMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantMembershipCountAggregateInputType | true
    _min?: TenantMembershipMinAggregateInputType
    _max?: TenantMembershipMaxAggregateInputType
  }

  export type TenantMembershipGroupByOutputType = {
    membershipId: string
    tenantId: string
    _count: TenantMembershipCountAggregateOutputType | null
    _min: TenantMembershipMinAggregateOutputType | null
    _max: TenantMembershipMaxAggregateOutputType | null
  }

  type GetTenantMembershipGroupByPayload<T extends TenantMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], TenantMembershipGroupByOutputType[P]>
        }
      >
    >


  export type TenantMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    membershipId?: boolean
    tenantId?: boolean
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantMembership"]>

  export type TenantMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    membershipId?: boolean
    tenantId?: boolean
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantMembership"]>

  export type TenantMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    membershipId?: boolean
    tenantId?: boolean
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenantMembership"]>

  export type TenantMembershipSelectScalar = {
    membershipId?: boolean
    tenantId?: boolean
  }

  export type TenantMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"membershipId" | "tenantId", ExtArgs["result"]["tenantMembership"]>
  export type TenantMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type TenantMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membership?: boolean | MembershipDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $TenantMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TenantMembership"
    objects: {
      membership: Prisma.$MembershipPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      membershipId: string
      tenantId: string
    }, ExtArgs["result"]["tenantMembership"]>
    composites: {}
  }

  type TenantMembershipGetPayload<S extends boolean | null | undefined | TenantMembershipDefaultArgs> = $Result.GetResult<Prisma.$TenantMembershipPayload, S>

  type TenantMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantMembershipCountAggregateInputType | true
    }

  export interface TenantMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TenantMembership'], meta: { name: 'TenantMembership' } }
    /**
     * Find zero or one TenantMembership that matches the filter.
     * @param {TenantMembershipFindUniqueArgs} args - Arguments to find a TenantMembership
     * @example
     * // Get one TenantMembership
     * const tenantMembership = await prisma.tenantMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantMembershipFindUniqueArgs>(args: SelectSubset<T, TenantMembershipFindUniqueArgs<ExtArgs>>): Prisma__TenantMembershipClient<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TenantMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantMembershipFindUniqueOrThrowArgs} args - Arguments to find a TenantMembership
     * @example
     * // Get one TenantMembership
     * const tenantMembership = await prisma.tenantMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantMembershipClient<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantMembershipFindFirstArgs} args - Arguments to find a TenantMembership
     * @example
     * // Get one TenantMembership
     * const tenantMembership = await prisma.tenantMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantMembershipFindFirstArgs>(args?: SelectSubset<T, TenantMembershipFindFirstArgs<ExtArgs>>): Prisma__TenantMembershipClient<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TenantMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantMembershipFindFirstOrThrowArgs} args - Arguments to find a TenantMembership
     * @example
     * // Get one TenantMembership
     * const tenantMembership = await prisma.tenantMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantMembershipClient<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TenantMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TenantMemberships
     * const tenantMemberships = await prisma.tenantMembership.findMany()
     * 
     * // Get first 10 TenantMemberships
     * const tenantMemberships = await prisma.tenantMembership.findMany({ take: 10 })
     * 
     * // Only select the `membershipId`
     * const tenantMembershipWithMembershipIdOnly = await prisma.tenantMembership.findMany({ select: { membershipId: true } })
     * 
     */
    findMany<T extends TenantMembershipFindManyArgs>(args?: SelectSubset<T, TenantMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TenantMembership.
     * @param {TenantMembershipCreateArgs} args - Arguments to create a TenantMembership.
     * @example
     * // Create one TenantMembership
     * const TenantMembership = await prisma.tenantMembership.create({
     *   data: {
     *     // ... data to create a TenantMembership
     *   }
     * })
     * 
     */
    create<T extends TenantMembershipCreateArgs>(args: SelectSubset<T, TenantMembershipCreateArgs<ExtArgs>>): Prisma__TenantMembershipClient<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TenantMemberships.
     * @param {TenantMembershipCreateManyArgs} args - Arguments to create many TenantMemberships.
     * @example
     * // Create many TenantMemberships
     * const tenantMembership = await prisma.tenantMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantMembershipCreateManyArgs>(args?: SelectSubset<T, TenantMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TenantMemberships and returns the data saved in the database.
     * @param {TenantMembershipCreateManyAndReturnArgs} args - Arguments to create many TenantMemberships.
     * @example
     * // Create many TenantMemberships
     * const tenantMembership = await prisma.tenantMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TenantMemberships and only return the `membershipId`
     * const tenantMembershipWithMembershipIdOnly = await prisma.tenantMembership.createManyAndReturn({
     *   select: { membershipId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TenantMembership.
     * @param {TenantMembershipDeleteArgs} args - Arguments to delete one TenantMembership.
     * @example
     * // Delete one TenantMembership
     * const TenantMembership = await prisma.tenantMembership.delete({
     *   where: {
     *     // ... filter to delete one TenantMembership
     *   }
     * })
     * 
     */
    delete<T extends TenantMembershipDeleteArgs>(args: SelectSubset<T, TenantMembershipDeleteArgs<ExtArgs>>): Prisma__TenantMembershipClient<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TenantMembership.
     * @param {TenantMembershipUpdateArgs} args - Arguments to update one TenantMembership.
     * @example
     * // Update one TenantMembership
     * const tenantMembership = await prisma.tenantMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantMembershipUpdateArgs>(args: SelectSubset<T, TenantMembershipUpdateArgs<ExtArgs>>): Prisma__TenantMembershipClient<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TenantMemberships.
     * @param {TenantMembershipDeleteManyArgs} args - Arguments to filter TenantMemberships to delete.
     * @example
     * // Delete a few TenantMemberships
     * const { count } = await prisma.tenantMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantMembershipDeleteManyArgs>(args?: SelectSubset<T, TenantMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TenantMemberships
     * const tenantMembership = await prisma.tenantMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantMembershipUpdateManyArgs>(args: SelectSubset<T, TenantMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TenantMemberships and returns the data updated in the database.
     * @param {TenantMembershipUpdateManyAndReturnArgs} args - Arguments to update many TenantMemberships.
     * @example
     * // Update many TenantMemberships
     * const tenantMembership = await prisma.tenantMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TenantMemberships and only return the `membershipId`
     * const tenantMembershipWithMembershipIdOnly = await prisma.tenantMembership.updateManyAndReturn({
     *   select: { membershipId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TenantMembership.
     * @param {TenantMembershipUpsertArgs} args - Arguments to update or create a TenantMembership.
     * @example
     * // Update or create a TenantMembership
     * const tenantMembership = await prisma.tenantMembership.upsert({
     *   create: {
     *     // ... data to create a TenantMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TenantMembership we want to update
     *   }
     * })
     */
    upsert<T extends TenantMembershipUpsertArgs>(args: SelectSubset<T, TenantMembershipUpsertArgs<ExtArgs>>): Prisma__TenantMembershipClient<$Result.GetResult<Prisma.$TenantMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TenantMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantMembershipCountArgs} args - Arguments to filter TenantMemberships to count.
     * @example
     * // Count the number of TenantMemberships
     * const count = await prisma.tenantMembership.count({
     *   where: {
     *     // ... the filter for the TenantMemberships we want to count
     *   }
     * })
    **/
    count<T extends TenantMembershipCountArgs>(
      args?: Subset<T, TenantMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TenantMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantMembershipAggregateArgs>(args: Subset<T, TenantMembershipAggregateArgs>): Prisma.PrismaPromise<GetTenantMembershipAggregateType<T>>

    /**
     * Group by TenantMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantMembershipGroupByArgs['orderBy'] }
        : { orderBy?: TenantMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TenantMembership model
   */
  readonly fields: TenantMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TenantMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    membership<T extends MembershipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MembershipDefaultArgs<ExtArgs>>): Prisma__MembershipClient<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TenantMembership model
   */
  interface TenantMembershipFieldRefs {
    readonly membershipId: FieldRef<"TenantMembership", 'String'>
    readonly tenantId: FieldRef<"TenantMembership", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TenantMembership findUnique
   */
  export type TenantMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TenantMembership to fetch.
     */
    where: TenantMembershipWhereUniqueInput
  }

  /**
   * TenantMembership findUniqueOrThrow
   */
  export type TenantMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TenantMembership to fetch.
     */
    where: TenantMembershipWhereUniqueInput
  }

  /**
   * TenantMembership findFirst
   */
  export type TenantMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TenantMembership to fetch.
     */
    where?: TenantMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantMemberships to fetch.
     */
    orderBy?: TenantMembershipOrderByWithRelationInput | TenantMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantMemberships.
     */
    cursor?: TenantMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantMemberships.
     */
    distinct?: TenantMembershipScalarFieldEnum | TenantMembershipScalarFieldEnum[]
  }

  /**
   * TenantMembership findFirstOrThrow
   */
  export type TenantMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TenantMembership to fetch.
     */
    where?: TenantMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantMemberships to fetch.
     */
    orderBy?: TenantMembershipOrderByWithRelationInput | TenantMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TenantMemberships.
     */
    cursor?: TenantMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TenantMemberships.
     */
    distinct?: TenantMembershipScalarFieldEnum | TenantMembershipScalarFieldEnum[]
  }

  /**
   * TenantMembership findMany
   */
  export type TenantMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * Filter, which TenantMemberships to fetch.
     */
    where?: TenantMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TenantMemberships to fetch.
     */
    orderBy?: TenantMembershipOrderByWithRelationInput | TenantMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TenantMemberships.
     */
    cursor?: TenantMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TenantMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TenantMemberships.
     */
    skip?: number
    distinct?: TenantMembershipScalarFieldEnum | TenantMembershipScalarFieldEnum[]
  }

  /**
   * TenantMembership create
   */
  export type TenantMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a TenantMembership.
     */
    data: XOR<TenantMembershipCreateInput, TenantMembershipUncheckedCreateInput>
  }

  /**
   * TenantMembership createMany
   */
  export type TenantMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TenantMemberships.
     */
    data: TenantMembershipCreateManyInput | TenantMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TenantMembership createManyAndReturn
   */
  export type TenantMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many TenantMemberships.
     */
    data: TenantMembershipCreateManyInput | TenantMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantMembership update
   */
  export type TenantMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a TenantMembership.
     */
    data: XOR<TenantMembershipUpdateInput, TenantMembershipUncheckedUpdateInput>
    /**
     * Choose, which TenantMembership to update.
     */
    where: TenantMembershipWhereUniqueInput
  }

  /**
   * TenantMembership updateMany
   */
  export type TenantMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TenantMemberships.
     */
    data: XOR<TenantMembershipUpdateManyMutationInput, TenantMembershipUncheckedUpdateManyInput>
    /**
     * Filter which TenantMemberships to update
     */
    where?: TenantMembershipWhereInput
    /**
     * Limit how many TenantMemberships to update.
     */
    limit?: number
  }

  /**
   * TenantMembership updateManyAndReturn
   */
  export type TenantMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * The data used to update TenantMemberships.
     */
    data: XOR<TenantMembershipUpdateManyMutationInput, TenantMembershipUncheckedUpdateManyInput>
    /**
     * Filter which TenantMemberships to update
     */
    where?: TenantMembershipWhereInput
    /**
     * Limit how many TenantMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TenantMembership upsert
   */
  export type TenantMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the TenantMembership to update in case it exists.
     */
    where: TenantMembershipWhereUniqueInput
    /**
     * In case the TenantMembership found by the `where` argument doesn't exist, create a new TenantMembership with this data.
     */
    create: XOR<TenantMembershipCreateInput, TenantMembershipUncheckedCreateInput>
    /**
     * In case the TenantMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantMembershipUpdateInput, TenantMembershipUncheckedUpdateInput>
  }

  /**
   * TenantMembership delete
   */
  export type TenantMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
    /**
     * Filter which TenantMembership to delete.
     */
    where: TenantMembershipWhereUniqueInput
  }

  /**
   * TenantMembership deleteMany
   */
  export type TenantMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TenantMemberships to delete
     */
    where?: TenantMembershipWhereInput
    /**
     * Limit how many TenantMemberships to delete.
     */
    limit?: number
  }

  /**
   * TenantMembership without action
   */
  export type TenantMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantMembership
     */
    select?: TenantMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TenantMembership
     */
    omit?: TenantMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantMembershipInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    active: boolean | null
    firstAccess: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    active: boolean | null
    firstAccess: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    active: number
    firstAccess: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    active?: true
    firstAccess?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    active?: true
    firstAccess?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    active?: true
    firstAccess?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: string
    active: boolean
    firstAccess: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    active?: boolean
    firstAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenantSettings?: boolean | User$tenantSettingsArgs<ExtArgs>
    NotificationTarget?: boolean | User$NotificationTargetArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    active?: boolean
    firstAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    active?: boolean
    firstAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    active?: boolean
    firstAccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "active" | "firstAccess" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenantSettings?: boolean | User$tenantSettingsArgs<ExtArgs>
    NotificationTarget?: boolean | User$NotificationTargetArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenantSettings: Prisma.$UserTenantSettingsPayload<ExtArgs>[]
      NotificationTarget: Prisma.$NotificationTargetPayload<ExtArgs>[]
      memberships: Prisma.$MembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: string
      active: boolean
      firstAccess: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenantSettings<T extends User$tenantSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationTarget<T extends User$NotificationTargetArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationTargetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTargetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly active: FieldRef<"User", 'Boolean'>
    readonly firstAccess: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.tenantSettings
   */
  export type User$tenantSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    where?: UserTenantSettingsWhereInput
    orderBy?: UserTenantSettingsOrderByWithRelationInput | UserTenantSettingsOrderByWithRelationInput[]
    cursor?: UserTenantSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTenantSettingsScalarFieldEnum | UserTenantSettingsScalarFieldEnum[]
  }

  /**
   * User.NotificationTarget
   */
  export type User$NotificationTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTarget
     */
    select?: NotificationTargetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTarget
     */
    omit?: NotificationTargetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTargetInclude<ExtArgs> | null
    where?: NotificationTargetWhereInput
    orderBy?: NotificationTargetOrderByWithRelationInput | NotificationTargetOrderByWithRelationInput[]
    cursor?: NotificationTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationTargetScalarFieldEnum | NotificationTargetScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Membership
     */
    select?: MembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Membership
     */
    omit?: MembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembershipInclude<ExtArgs> | null
    where?: MembershipWhereInput
    orderBy?: MembershipOrderByWithRelationInput | MembershipOrderByWithRelationInput[]
    cursor?: MembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MembershipScalarFieldEnum | MembershipScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserTenantSettings
   */

  export type AggregateUserTenantSettings = {
    _count: UserTenantSettingsCountAggregateOutputType | null
    _min: UserTenantSettingsMinAggregateOutputType | null
    _max: UserTenantSettingsMaxAggregateOutputType | null
  }

  export type UserTenantSettingsMinAggregateOutputType = {
    doNotDisturb: boolean | null
    userId: string | null
    tenantId: string | null
  }

  export type UserTenantSettingsMaxAggregateOutputType = {
    doNotDisturb: boolean | null
    userId: string | null
    tenantId: string | null
  }

  export type UserTenantSettingsCountAggregateOutputType = {
    doNotDisturb: number
    userId: number
    tenantId: number
    _all: number
  }


  export type UserTenantSettingsMinAggregateInputType = {
    doNotDisturb?: true
    userId?: true
    tenantId?: true
  }

  export type UserTenantSettingsMaxAggregateInputType = {
    doNotDisturb?: true
    userId?: true
    tenantId?: true
  }

  export type UserTenantSettingsCountAggregateInputType = {
    doNotDisturb?: true
    userId?: true
    tenantId?: true
    _all?: true
  }

  export type UserTenantSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTenantSettings to aggregate.
     */
    where?: UserTenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTenantSettings to fetch.
     */
    orderBy?: UserTenantSettingsOrderByWithRelationInput | UserTenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTenantSettings
    **/
    _count?: true | UserTenantSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTenantSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTenantSettingsMaxAggregateInputType
  }

  export type GetUserTenantSettingsAggregateType<T extends UserTenantSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTenantSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTenantSettings[P]>
      : GetScalarType<T[P], AggregateUserTenantSettings[P]>
  }




  export type UserTenantSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTenantSettingsWhereInput
    orderBy?: UserTenantSettingsOrderByWithAggregationInput | UserTenantSettingsOrderByWithAggregationInput[]
    by: UserTenantSettingsScalarFieldEnum[] | UserTenantSettingsScalarFieldEnum
    having?: UserTenantSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTenantSettingsCountAggregateInputType | true
    _min?: UserTenantSettingsMinAggregateInputType
    _max?: UserTenantSettingsMaxAggregateInputType
  }

  export type UserTenantSettingsGroupByOutputType = {
    doNotDisturb: boolean
    userId: string
    tenantId: string
    _count: UserTenantSettingsCountAggregateOutputType | null
    _min: UserTenantSettingsMinAggregateOutputType | null
    _max: UserTenantSettingsMaxAggregateOutputType | null
  }

  type GetUserTenantSettingsGroupByPayload<T extends UserTenantSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTenantSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTenantSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTenantSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserTenantSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserTenantSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doNotDisturb?: boolean
    userId?: boolean
    tenantId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTenantSettings"]>

  export type UserTenantSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doNotDisturb?: boolean
    userId?: boolean
    tenantId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTenantSettings"]>

  export type UserTenantSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doNotDisturb?: boolean
    userId?: boolean
    tenantId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTenantSettings"]>

  export type UserTenantSettingsSelectScalar = {
    doNotDisturb?: boolean
    userId?: boolean
    tenantId?: boolean
  }

  export type UserTenantSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"doNotDisturb" | "userId" | "tenantId", ExtArgs["result"]["userTenantSettings"]>
  export type UserTenantSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserTenantSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserTenantSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserTenantSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTenantSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      doNotDisturb: boolean
      userId: string
      tenantId: string
    }, ExtArgs["result"]["userTenantSettings"]>
    composites: {}
  }

  type UserTenantSettingsGetPayload<S extends boolean | null | undefined | UserTenantSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserTenantSettingsPayload, S>

  type UserTenantSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTenantSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTenantSettingsCountAggregateInputType | true
    }

  export interface UserTenantSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTenantSettings'], meta: { name: 'UserTenantSettings' } }
    /**
     * Find zero or one UserTenantSettings that matches the filter.
     * @param {UserTenantSettingsFindUniqueArgs} args - Arguments to find a UserTenantSettings
     * @example
     * // Get one UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTenantSettingsFindUniqueArgs>(args: SelectSubset<T, UserTenantSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserTenantSettingsClient<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTenantSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTenantSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserTenantSettings
     * @example
     * // Get one UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTenantSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTenantSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTenantSettingsClient<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTenantSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantSettingsFindFirstArgs} args - Arguments to find a UserTenantSettings
     * @example
     * // Get one UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTenantSettingsFindFirstArgs>(args?: SelectSubset<T, UserTenantSettingsFindFirstArgs<ExtArgs>>): Prisma__UserTenantSettingsClient<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTenantSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantSettingsFindFirstOrThrowArgs} args - Arguments to find a UserTenantSettings
     * @example
     * // Get one UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTenantSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTenantSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTenantSettingsClient<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTenantSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.findMany()
     * 
     * // Get first 10 UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.findMany({ take: 10 })
     * 
     * // Only select the `doNotDisturb`
     * const userTenantSettingsWithDoNotDisturbOnly = await prisma.userTenantSettings.findMany({ select: { doNotDisturb: true } })
     * 
     */
    findMany<T extends UserTenantSettingsFindManyArgs>(args?: SelectSubset<T, UserTenantSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTenantSettings.
     * @param {UserTenantSettingsCreateArgs} args - Arguments to create a UserTenantSettings.
     * @example
     * // Create one UserTenantSettings
     * const UserTenantSettings = await prisma.userTenantSettings.create({
     *   data: {
     *     // ... data to create a UserTenantSettings
     *   }
     * })
     * 
     */
    create<T extends UserTenantSettingsCreateArgs>(args: SelectSubset<T, UserTenantSettingsCreateArgs<ExtArgs>>): Prisma__UserTenantSettingsClient<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTenantSettings.
     * @param {UserTenantSettingsCreateManyArgs} args - Arguments to create many UserTenantSettings.
     * @example
     * // Create many UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTenantSettingsCreateManyArgs>(args?: SelectSubset<T, UserTenantSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTenantSettings and returns the data saved in the database.
     * @param {UserTenantSettingsCreateManyAndReturnArgs} args - Arguments to create many UserTenantSettings.
     * @example
     * // Create many UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTenantSettings and only return the `doNotDisturb`
     * const userTenantSettingsWithDoNotDisturbOnly = await prisma.userTenantSettings.createManyAndReturn({
     *   select: { doNotDisturb: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTenantSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTenantSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTenantSettings.
     * @param {UserTenantSettingsDeleteArgs} args - Arguments to delete one UserTenantSettings.
     * @example
     * // Delete one UserTenantSettings
     * const UserTenantSettings = await prisma.userTenantSettings.delete({
     *   where: {
     *     // ... filter to delete one UserTenantSettings
     *   }
     * })
     * 
     */
    delete<T extends UserTenantSettingsDeleteArgs>(args: SelectSubset<T, UserTenantSettingsDeleteArgs<ExtArgs>>): Prisma__UserTenantSettingsClient<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTenantSettings.
     * @param {UserTenantSettingsUpdateArgs} args - Arguments to update one UserTenantSettings.
     * @example
     * // Update one UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTenantSettingsUpdateArgs>(args: SelectSubset<T, UserTenantSettingsUpdateArgs<ExtArgs>>): Prisma__UserTenantSettingsClient<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTenantSettings.
     * @param {UserTenantSettingsDeleteManyArgs} args - Arguments to filter UserTenantSettings to delete.
     * @example
     * // Delete a few UserTenantSettings
     * const { count } = await prisma.userTenantSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTenantSettingsDeleteManyArgs>(args?: SelectSubset<T, UserTenantSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTenantSettingsUpdateManyArgs>(args: SelectSubset<T, UserTenantSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTenantSettings and returns the data updated in the database.
     * @param {UserTenantSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserTenantSettings.
     * @example
     * // Update many UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTenantSettings and only return the `doNotDisturb`
     * const userTenantSettingsWithDoNotDisturbOnly = await prisma.userTenantSettings.updateManyAndReturn({
     *   select: { doNotDisturb: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTenantSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTenantSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTenantSettings.
     * @param {UserTenantSettingsUpsertArgs} args - Arguments to update or create a UserTenantSettings.
     * @example
     * // Update or create a UserTenantSettings
     * const userTenantSettings = await prisma.userTenantSettings.upsert({
     *   create: {
     *     // ... data to create a UserTenantSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTenantSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserTenantSettingsUpsertArgs>(args: SelectSubset<T, UserTenantSettingsUpsertArgs<ExtArgs>>): Prisma__UserTenantSettingsClient<$Result.GetResult<Prisma.$UserTenantSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantSettingsCountArgs} args - Arguments to filter UserTenantSettings to count.
     * @example
     * // Count the number of UserTenantSettings
     * const count = await prisma.userTenantSettings.count({
     *   where: {
     *     // ... the filter for the UserTenantSettings we want to count
     *   }
     * })
    **/
    count<T extends UserTenantSettingsCountArgs>(
      args?: Subset<T, UserTenantSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTenantSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTenantSettingsAggregateArgs>(args: Subset<T, UserTenantSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserTenantSettingsAggregateType<T>>

    /**
     * Group by UserTenantSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTenantSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTenantSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTenantSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserTenantSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTenantSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTenantSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTenantSettings model
   */
  readonly fields: UserTenantSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTenantSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTenantSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTenantSettings model
   */
  interface UserTenantSettingsFieldRefs {
    readonly doNotDisturb: FieldRef<"UserTenantSettings", 'Boolean'>
    readonly userId: FieldRef<"UserTenantSettings", 'String'>
    readonly tenantId: FieldRef<"UserTenantSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserTenantSettings findUnique
   */
  export type UserTenantSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTenantSettings to fetch.
     */
    where: UserTenantSettingsWhereUniqueInput
  }

  /**
   * UserTenantSettings findUniqueOrThrow
   */
  export type UserTenantSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTenantSettings to fetch.
     */
    where: UserTenantSettingsWhereUniqueInput
  }

  /**
   * UserTenantSettings findFirst
   */
  export type UserTenantSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTenantSettings to fetch.
     */
    where?: UserTenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTenantSettings to fetch.
     */
    orderBy?: UserTenantSettingsOrderByWithRelationInput | UserTenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTenantSettings.
     */
    cursor?: UserTenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTenantSettings.
     */
    distinct?: UserTenantSettingsScalarFieldEnum | UserTenantSettingsScalarFieldEnum[]
  }

  /**
   * UserTenantSettings findFirstOrThrow
   */
  export type UserTenantSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTenantSettings to fetch.
     */
    where?: UserTenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTenantSettings to fetch.
     */
    orderBy?: UserTenantSettingsOrderByWithRelationInput | UserTenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTenantSettings.
     */
    cursor?: UserTenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTenantSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTenantSettings.
     */
    distinct?: UserTenantSettingsScalarFieldEnum | UserTenantSettingsScalarFieldEnum[]
  }

  /**
   * UserTenantSettings findMany
   */
  export type UserTenantSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserTenantSettings to fetch.
     */
    where?: UserTenantSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTenantSettings to fetch.
     */
    orderBy?: UserTenantSettingsOrderByWithRelationInput | UserTenantSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTenantSettings.
     */
    cursor?: UserTenantSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTenantSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTenantSettings.
     */
    skip?: number
    distinct?: UserTenantSettingsScalarFieldEnum | UserTenantSettingsScalarFieldEnum[]
  }

  /**
   * UserTenantSettings create
   */
  export type UserTenantSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTenantSettings.
     */
    data: XOR<UserTenantSettingsCreateInput, UserTenantSettingsUncheckedCreateInput>
  }

  /**
   * UserTenantSettings createMany
   */
  export type UserTenantSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTenantSettings.
     */
    data: UserTenantSettingsCreateManyInput | UserTenantSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTenantSettings createManyAndReturn
   */
  export type UserTenantSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserTenantSettings.
     */
    data: UserTenantSettingsCreateManyInput | UserTenantSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTenantSettings update
   */
  export type UserTenantSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTenantSettings.
     */
    data: XOR<UserTenantSettingsUpdateInput, UserTenantSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserTenantSettings to update.
     */
    where: UserTenantSettingsWhereUniqueInput
  }

  /**
   * UserTenantSettings updateMany
   */
  export type UserTenantSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTenantSettings.
     */
    data: XOR<UserTenantSettingsUpdateManyMutationInput, UserTenantSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserTenantSettings to update
     */
    where?: UserTenantSettingsWhereInput
    /**
     * Limit how many UserTenantSettings to update.
     */
    limit?: number
  }

  /**
   * UserTenantSettings updateManyAndReturn
   */
  export type UserTenantSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserTenantSettings.
     */
    data: XOR<UserTenantSettingsUpdateManyMutationInput, UserTenantSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserTenantSettings to update
     */
    where?: UserTenantSettingsWhereInput
    /**
     * Limit how many UserTenantSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTenantSettings upsert
   */
  export type UserTenantSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTenantSettings to update in case it exists.
     */
    where: UserTenantSettingsWhereUniqueInput
    /**
     * In case the UserTenantSettings found by the `where` argument doesn't exist, create a new UserTenantSettings with this data.
     */
    create: XOR<UserTenantSettingsCreateInput, UserTenantSettingsUncheckedCreateInput>
    /**
     * In case the UserTenantSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTenantSettingsUpdateInput, UserTenantSettingsUncheckedUpdateInput>
  }

  /**
   * UserTenantSettings delete
   */
  export type UserTenantSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserTenantSettings to delete.
     */
    where: UserTenantSettingsWhereUniqueInput
  }

  /**
   * UserTenantSettings deleteMany
   */
  export type UserTenantSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTenantSettings to delete
     */
    where?: UserTenantSettingsWhereInput
    /**
     * Limit how many UserTenantSettings to delete.
     */
    limit?: number
  }

  /**
   * UserTenantSettings without action
   */
  export type UserTenantSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTenantSettings
     */
    select?: UserTenantSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTenantSettings
     */
    omit?: UserTenantSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTenantSettingsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AddressScalarFieldEnum: {
    id: 'id',
    street: 'street',
    houseNumber: 'houseNumber',
    neighborhood: 'neighborhood',
    zipCode: 'zipCode',
    city: 'city',
    state: 'state',
    complement: 'complement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phoneNumber: 'phoneNumber',
    active: 'active',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    number: 'number',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const MembershipScalarFieldEnum: {
    id: 'id',
    role: 'role',
    permissions: 'permissions',
    active: 'active',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MembershipScalarFieldEnum = (typeof MembershipScalarFieldEnum)[keyof typeof MembershipScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    subject: 'subject',
    body: 'body',
    href: 'href',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationTargetScalarFieldEnum: {
    id: 'id',
    status: 'status',
    notificationId: 'notificationId',
    userId: 'userId',
    tenantId: 'tenantId'
  };

  export type NotificationTargetScalarFieldEnum = (typeof NotificationTargetScalarFieldEnum)[keyof typeof NotificationTargetScalarFieldEnum]


  export const PosScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PosScalarFieldEnum = (typeof PosScalarFieldEnum)[keyof typeof PosScalarFieldEnum]


  export const PosEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    posId: 'posId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PosEventScalarFieldEnum = (typeof PosEventScalarFieldEnum)[keyof typeof PosEventScalarFieldEnum]


  export const PosEventEntryScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    description: 'description'
  };

  export type PosEventEntryScalarFieldEnum = (typeof PosEventEntryScalarFieldEnum)[keyof typeof PosEventEntryScalarFieldEnum]


  export const PosEventOutputScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    description: 'description'
  };

  export type PosEventOutputScalarFieldEnum = (typeof PosEventOutputScalarFieldEnum)[keyof typeof PosEventOutputScalarFieldEnum]


  export const PosEventSaleScalarFieldEnum: {
    id: 'id',
    description: 'description',
    amount: 'amount',
    discountVariant: 'discountVariant',
    discountValue: 'discountValue',
    customerId: 'customerId',
    saleId: 'saleId'
  };

  export type PosEventSaleScalarFieldEnum = (typeof PosEventSaleScalarFieldEnum)[keyof typeof PosEventSaleScalarFieldEnum]


  export const PosEventSaleMovementScalarFieldEnum: {
    id: 'id',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    posEventSaleId: 'posEventSaleId'
  };

  export type PosEventSaleMovementScalarFieldEnum = (typeof PosEventSaleMovementScalarFieldEnum)[keyof typeof PosEventSaleMovementScalarFieldEnum]


  export const PosEventSaleMovementPaymentScalarFieldEnum: {
    id: 'id',
    method: 'method',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PosEventSaleMovementPaymentScalarFieldEnum = (typeof PosEventSaleMovementPaymentScalarFieldEnum)[keyof typeof PosEventSaleMovementPaymentScalarFieldEnum]


  export const PosEventSaleMovementChangeScalarFieldEnum: {
    id: 'id',
    method: 'method',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PosEventSaleMovementChangeScalarFieldEnum = (typeof PosEventSaleMovementChangeScalarFieldEnum)[keyof typeof PosEventSaleMovementChangeScalarFieldEnum]


  export const PosEventSaleProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    costPrice: 'costPrice',
    salePrice: 'salePrice',
    totalQty: 'totalQty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    productId: 'productId'
  };

  export type PosEventSaleProductScalarFieldEnum = (typeof PosEventSaleProductScalarFieldEnum)[keyof typeof PosEventSaleProductScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    barCode: 'barCode',
    internalCode: 'internalCode',
    active: 'active',
    skuCode: 'skuCode',
    tenantId: 'tenantId',
    salePrice: 'salePrice',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductSpecificationScalarFieldEnum: {
    id: 'id',
    label: 'label',
    value: 'value',
    productId: 'productId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductSpecificationScalarFieldEnum = (typeof ProductSpecificationScalarFieldEnum)[keyof typeof ProductSpecificationScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    status: 'status',
    internalCode: 'internalCode',
    customerId: 'customerId',
    tenantId: 'tenantId',
    discountVariant: 'discountVariant',
    discountValue: 'discountValue',
    paidTotal: 'paidTotal',
    estimatedTotal: 'estimatedTotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const SaleMovementScalarFieldEnum: {
    id: 'id',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    saleId: 'saleId'
  };

  export type SaleMovementScalarFieldEnum = (typeof SaleMovementScalarFieldEnum)[keyof typeof SaleMovementScalarFieldEnum]


  export const SaleMovementPaymentScalarFieldEnum: {
    id: 'id',
    method: 'method',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleMovementPaymentScalarFieldEnum = (typeof SaleMovementPaymentScalarFieldEnum)[keyof typeof SaleMovementPaymentScalarFieldEnum]


  export const SaleMovementChangeScalarFieldEnum: {
    id: 'id',
    method: 'method',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleMovementChangeScalarFieldEnum = (typeof SaleMovementChangeScalarFieldEnum)[keyof typeof SaleMovementChangeScalarFieldEnum]


  export const SaleProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    costPrice: 'costPrice',
    salePrice: 'salePrice',
    totalQty: 'totalQty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    saleId: 'saleId',
    productId: 'productId',
    stockLotId: 'stockLotId'
  };

  export type SaleProductScalarFieldEnum = (typeof SaleProductScalarFieldEnum)[keyof typeof SaleProductScalarFieldEnum]


  export const StockScalarFieldEnum: {
    id: 'id',
    strategy: 'strategy',
    productId: 'productId',
    totalQty: 'totalQty',
    availableQty: 'availableQty',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const StockEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    stockId: 'stockId',
    tenantId: 'tenantId',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    stockLotId: 'stockLotId'
  };

  export type StockEventScalarFieldEnum = (typeof StockEventScalarFieldEnum)[keyof typeof StockEventScalarFieldEnum]


  export const StockEventEntryScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    description: 'description'
  };

  export type StockEventEntryScalarFieldEnum = (typeof StockEventEntryScalarFieldEnum)[keyof typeof StockEventEntryScalarFieldEnum]


  export const StockEventOutputScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    description: 'description'
  };

  export type StockEventOutputScalarFieldEnum = (typeof StockEventOutputScalarFieldEnum)[keyof typeof StockEventOutputScalarFieldEnum]


  export const StockLotScalarFieldEnum: {
    id: 'id',
    lotNumber: 'lotNumber',
    totalQty: 'totalQty',
    costPrice: 'costPrice',
    stockId: 'stockId',
    tenantId: 'tenantId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockLotScalarFieldEnum = (typeof StockLotScalarFieldEnum)[keyof typeof StockLotScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const TenantMembershipScalarFieldEnum: {
    membershipId: 'membershipId',
    tenantId: 'tenantId'
  };

  export type TenantMembershipScalarFieldEnum = (typeof TenantMembershipScalarFieldEnum)[keyof typeof TenantMembershipScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    active: 'active',
    firstAccess: 'firstAccess',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserTenantSettingsScalarFieldEnum: {
    doNotDisturb: 'doNotDisturb',
    userId: 'userId',
    tenantId: 'tenantId'
  };

  export type UserTenantSettingsScalarFieldEnum = (typeof UserTenantSettingsScalarFieldEnum)[keyof typeof UserTenantSettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'EMembershipRole'
   */
  export type EnumEMembershipRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EMembershipRole'>
    


  /**
   * Reference to a field of type 'EMembershipRole[]'
   */
  export type ListEnumEMembershipRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EMembershipRole[]'>
    


  /**
   * Reference to a field of type 'ENotificationType'
   */
  export type EnumENotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ENotificationType'>
    


  /**
   * Reference to a field of type 'ENotificationType[]'
   */
  export type ListEnumENotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ENotificationType[]'>
    


  /**
   * Reference to a field of type 'ENotificationTargetStatus'
   */
  export type EnumENotificationTargetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ENotificationTargetStatus'>
    


  /**
   * Reference to a field of type 'ENotificationTargetStatus[]'
   */
  export type ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ENotificationTargetStatus[]'>
    


  /**
   * Reference to a field of type 'EPosStatus'
   */
  export type EnumEPosStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EPosStatus'>
    


  /**
   * Reference to a field of type 'EPosStatus[]'
   */
  export type ListEnumEPosStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EPosStatus[]'>
    


  /**
   * Reference to a field of type 'EPosEventType'
   */
  export type EnumEPosEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EPosEventType'>
    


  /**
   * Reference to a field of type 'EPosEventType[]'
   */
  export type ListEnumEPosEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EPosEventType[]'>
    


  /**
   * Reference to a field of type 'EPosEventStatus'
   */
  export type EnumEPosEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EPosEventStatus'>
    


  /**
   * Reference to a field of type 'EPosEventStatus[]'
   */
  export type ListEnumEPosEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EPosEventStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'EDiscountVariant'
   */
  export type EnumEDiscountVariantFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EDiscountVariant'>
    


  /**
   * Reference to a field of type 'EDiscountVariant[]'
   */
  export type ListEnumEDiscountVariantFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EDiscountVariant[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ESaleMovementType'
   */
  export type EnumESaleMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ESaleMovementType'>
    


  /**
   * Reference to a field of type 'ESaleMovementType[]'
   */
  export type ListEnumESaleMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ESaleMovementType[]'>
    


  /**
   * Reference to a field of type 'EPaymentMethod'
   */
  export type EnumEPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EPaymentMethod'>
    


  /**
   * Reference to a field of type 'EPaymentMethod[]'
   */
  export type ListEnumEPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EPaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ESaleStatus'
   */
  export type EnumESaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ESaleStatus'>
    


  /**
   * Reference to a field of type 'ESaleStatus[]'
   */
  export type ListEnumESaleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ESaleStatus[]'>
    


  /**
   * Reference to a field of type 'EStockStrategy'
   */
  export type EnumEStockStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EStockStrategy'>
    


  /**
   * Reference to a field of type 'EStockStrategy[]'
   */
  export type ListEnumEStockStrategyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EStockStrategy[]'>
    


  /**
   * Reference to a field of type 'EStockEventType'
   */
  export type EnumEStockEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EStockEventType'>
    


  /**
   * Reference to a field of type 'EStockEventType[]'
   */
  export type ListEnumEStockEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EStockEventType[]'>
    
  /**
   * Deep Input Types
   */


  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: UuidFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    houseNumber?: StringFilter<"Address"> | string
    neighborhood?: StringFilter<"Address"> | string
    zipCode?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    complement?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    street?: SortOrder
    houseNumber?: SortOrder
    neighborhood?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    street?: StringFilter<"Address"> | string
    houseNumber?: StringFilter<"Address"> | string
    neighborhood?: StringFilter<"Address"> | string
    zipCode?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    complement?: StringFilter<"Address"> | string
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    street?: SortOrder
    houseNumber?: SortOrder
    neighborhood?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Address"> | string
    street?: StringWithAggregatesFilter<"Address"> | string
    houseNumber?: StringWithAggregatesFilter<"Address"> | string
    neighborhood?: StringWithAggregatesFilter<"Address"> | string
    zipCode?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    complement?: StringWithAggregatesFilter<"Address"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: UuidFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    active?: BoolNullableFilter<"Customer"> | boolean | null
    tenantId?: UuidFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    sales?: SaleListRelationFilter
    posEventSales?: PosEventSaleListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    sales?: SaleOrderByRelationAggregateInput
    posEventSales?: PosEventSaleOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    active?: BoolNullableFilter<"Customer"> | boolean | null
    tenantId?: UuidFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    sales?: SaleListRelationFilter
    posEventSales?: PosEventSaleListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    active?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    tenantId?: UuidWithAggregatesFilter<"Customer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: UuidFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    number?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    number?: StringFilter<"Document"> | string
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    number?: StringWithAggregatesFilter<"Document"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type MembershipWhereInput = {
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    id?: UuidFilter<"Membership"> | string
    role?: EnumEMembershipRoleFilter<"Membership"> | $Enums.EMembershipRole
    permissions?: StringNullableListFilter<"Membership">
    active?: BoolNullableFilter<"Membership"> | boolean | null
    userId?: UuidFilter<"Membership"> | string
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    updatedAt?: DateTimeFilter<"Membership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant_memberships?: TenantMembershipListRelationFilter
  }

  export type MembershipOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    active?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant_memberships?: TenantMembershipOrderByRelationAggregateInput
  }

  export type MembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MembershipWhereInput | MembershipWhereInput[]
    OR?: MembershipWhereInput[]
    NOT?: MembershipWhereInput | MembershipWhereInput[]
    role?: EnumEMembershipRoleFilter<"Membership"> | $Enums.EMembershipRole
    permissions?: StringNullableListFilter<"Membership">
    active?: BoolNullableFilter<"Membership"> | boolean | null
    userId?: UuidFilter<"Membership"> | string
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    updatedAt?: DateTimeFilter<"Membership"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant_memberships?: TenantMembershipListRelationFilter
  }, "id">

  export type MembershipOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    active?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MembershipCountOrderByAggregateInput
    _max?: MembershipMaxOrderByAggregateInput
    _min?: MembershipMinOrderByAggregateInput
  }

  export type MembershipScalarWhereWithAggregatesInput = {
    AND?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    OR?: MembershipScalarWhereWithAggregatesInput[]
    NOT?: MembershipScalarWhereWithAggregatesInput | MembershipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Membership"> | string
    role?: EnumEMembershipRoleWithAggregatesFilter<"Membership"> | $Enums.EMembershipRole
    permissions?: StringNullableListFilter<"Membership">
    active?: BoolNullableWithAggregatesFilter<"Membership"> | boolean | null
    userId?: UuidWithAggregatesFilter<"Membership"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Membership"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    type?: EnumENotificationTypeFilter<"Notification"> | $Enums.ENotificationType
    subject?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    href?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    deletedAt?: DateTimeFilter<"Notification"> | Date | string
    targets?: NotificationTargetListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    href?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    targets?: NotificationTargetOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumENotificationTypeFilter<"Notification"> | $Enums.ENotificationType
    subject?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    href?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    deletedAt?: DateTimeFilter<"Notification"> | Date | string
    targets?: NotificationTargetListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    href?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    type?: EnumENotificationTypeWithAggregatesFilter<"Notification"> | $Enums.ENotificationType
    subject?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    href?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    deletedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationTargetWhereInput = {
    AND?: NotificationTargetWhereInput | NotificationTargetWhereInput[]
    OR?: NotificationTargetWhereInput[]
    NOT?: NotificationTargetWhereInput | NotificationTargetWhereInput[]
    id?: UuidFilter<"NotificationTarget"> | string
    status?: EnumENotificationTargetStatusFilter<"NotificationTarget"> | $Enums.ENotificationTargetStatus
    notificationId?: UuidFilter<"NotificationTarget"> | string
    userId?: UuidFilter<"NotificationTarget"> | string
    tenantId?: UuidFilter<"NotificationTarget"> | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type NotificationTargetOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    notification?: NotificationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type NotificationTargetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    notificationId_userId_tenantId?: NotificationTargetNotificationIdUserIdTenantIdCompoundUniqueInput
    AND?: NotificationTargetWhereInput | NotificationTargetWhereInput[]
    OR?: NotificationTargetWhereInput[]
    NOT?: NotificationTargetWhereInput | NotificationTargetWhereInput[]
    status?: EnumENotificationTargetStatusFilter<"NotificationTarget"> | $Enums.ENotificationTargetStatus
    notificationId?: UuidFilter<"NotificationTarget"> | string
    userId?: UuidFilter<"NotificationTarget"> | string
    tenantId?: UuidFilter<"NotificationTarget"> | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "notificationId_userId_tenantId">

  export type NotificationTargetOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    _count?: NotificationTargetCountOrderByAggregateInput
    _max?: NotificationTargetMaxOrderByAggregateInput
    _min?: NotificationTargetMinOrderByAggregateInput
  }

  export type NotificationTargetScalarWhereWithAggregatesInput = {
    AND?: NotificationTargetScalarWhereWithAggregatesInput | NotificationTargetScalarWhereWithAggregatesInput[]
    OR?: NotificationTargetScalarWhereWithAggregatesInput[]
    NOT?: NotificationTargetScalarWhereWithAggregatesInput | NotificationTargetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NotificationTarget"> | string
    status?: EnumENotificationTargetStatusWithAggregatesFilter<"NotificationTarget"> | $Enums.ENotificationTargetStatus
    notificationId?: UuidWithAggregatesFilter<"NotificationTarget"> | string
    userId?: UuidWithAggregatesFilter<"NotificationTarget"> | string
    tenantId?: UuidWithAggregatesFilter<"NotificationTarget"> | string
  }

  export type PosWhereInput = {
    AND?: PosWhereInput | PosWhereInput[]
    OR?: PosWhereInput[]
    NOT?: PosWhereInput | PosWhereInput[]
    id?: UuidFilter<"Pos"> | string
    name?: StringFilter<"Pos"> | string
    description?: StringFilter<"Pos"> | string
    status?: EnumEPosStatusFilter<"Pos"> | $Enums.EPosStatus
    tenantId?: UuidFilter<"Pos"> | string
    createdAt?: DateTimeFilter<"Pos"> | Date | string
    updatedAt?: DateTimeFilter<"Pos"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Pos"> | Date | string | null
  }

  export type PosOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type PosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosWhereInput | PosWhereInput[]
    OR?: PosWhereInput[]
    NOT?: PosWhereInput | PosWhereInput[]
    name?: StringFilter<"Pos"> | string
    description?: StringFilter<"Pos"> | string
    status?: EnumEPosStatusFilter<"Pos"> | $Enums.EPosStatus
    tenantId?: UuidFilter<"Pos"> | string
    createdAt?: DateTimeFilter<"Pos"> | Date | string
    updatedAt?: DateTimeFilter<"Pos"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Pos"> | Date | string | null
  }, "id">

  export type PosOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PosCountOrderByAggregateInput
    _max?: PosMaxOrderByAggregateInput
    _min?: PosMinOrderByAggregateInput
  }

  export type PosScalarWhereWithAggregatesInput = {
    AND?: PosScalarWhereWithAggregatesInput | PosScalarWhereWithAggregatesInput[]
    OR?: PosScalarWhereWithAggregatesInput[]
    NOT?: PosScalarWhereWithAggregatesInput | PosScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Pos"> | string
    name?: StringWithAggregatesFilter<"Pos"> | string
    description?: StringWithAggregatesFilter<"Pos"> | string
    status?: EnumEPosStatusWithAggregatesFilter<"Pos"> | $Enums.EPosStatus
    tenantId?: UuidWithAggregatesFilter<"Pos"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pos"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Pos"> | Date | string | null
  }

  export type PosEventWhereInput = {
    AND?: PosEventWhereInput | PosEventWhereInput[]
    OR?: PosEventWhereInput[]
    NOT?: PosEventWhereInput | PosEventWhereInput[]
    id?: UuidFilter<"PosEvent"> | string
    type?: EnumEPosEventTypeFilter<"PosEvent"> | $Enums.EPosEventType
    status?: EnumEPosEventStatusFilter<"PosEvent"> | $Enums.EPosEventStatus
    posId?: UuidFilter<"PosEvent"> | string
    createdAt?: DateTimeFilter<"PosEvent"> | Date | string
    updatedAt?: DateTimeFilter<"PosEvent"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PosEvent"> | Date | string | null
    entry?: XOR<PosEventEntryNullableScalarRelationFilter, PosEventEntryWhereInput> | null
    output?: XOR<PosEventOutputNullableScalarRelationFilter, PosEventOutputWhereInput> | null
    sale?: XOR<PosEventSaleNullableScalarRelationFilter, PosEventSaleWhereInput> | null
  }

  export type PosEventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    posId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    entry?: PosEventEntryOrderByWithRelationInput
    output?: PosEventOutputOrderByWithRelationInput
    sale?: PosEventSaleOrderByWithRelationInput
  }

  export type PosEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosEventWhereInput | PosEventWhereInput[]
    OR?: PosEventWhereInput[]
    NOT?: PosEventWhereInput | PosEventWhereInput[]
    type?: EnumEPosEventTypeFilter<"PosEvent"> | $Enums.EPosEventType
    status?: EnumEPosEventStatusFilter<"PosEvent"> | $Enums.EPosEventStatus
    posId?: UuidFilter<"PosEvent"> | string
    createdAt?: DateTimeFilter<"PosEvent"> | Date | string
    updatedAt?: DateTimeFilter<"PosEvent"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PosEvent"> | Date | string | null
    entry?: XOR<PosEventEntryNullableScalarRelationFilter, PosEventEntryWhereInput> | null
    output?: XOR<PosEventOutputNullableScalarRelationFilter, PosEventOutputWhereInput> | null
    sale?: XOR<PosEventSaleNullableScalarRelationFilter, PosEventSaleWhereInput> | null
  }, "id">

  export type PosEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    posId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PosEventCountOrderByAggregateInput
    _max?: PosEventMaxOrderByAggregateInput
    _min?: PosEventMinOrderByAggregateInput
  }

  export type PosEventScalarWhereWithAggregatesInput = {
    AND?: PosEventScalarWhereWithAggregatesInput | PosEventScalarWhereWithAggregatesInput[]
    OR?: PosEventScalarWhereWithAggregatesInput[]
    NOT?: PosEventScalarWhereWithAggregatesInput | PosEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosEvent"> | string
    type?: EnumEPosEventTypeWithAggregatesFilter<"PosEvent"> | $Enums.EPosEventType
    status?: EnumEPosEventStatusWithAggregatesFilter<"PosEvent"> | $Enums.EPosEventStatus
    posId?: UuidWithAggregatesFilter<"PosEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PosEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PosEvent"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PosEvent"> | Date | string | null
  }

  export type PosEventEntryWhereInput = {
    AND?: PosEventEntryWhereInput | PosEventEntryWhereInput[]
    OR?: PosEventEntryWhereInput[]
    NOT?: PosEventEntryWhereInput | PosEventEntryWhereInput[]
    id?: UuidFilter<"PosEventEntry"> | string
    amount?: DecimalFilter<"PosEventEntry"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"PosEventEntry"> | string
    posEvent?: XOR<PosEventScalarRelationFilter, PosEventWhereInput>
  }

  export type PosEventEntryOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    posEvent?: PosEventOrderByWithRelationInput
  }

  export type PosEventEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosEventEntryWhereInput | PosEventEntryWhereInput[]
    OR?: PosEventEntryWhereInput[]
    NOT?: PosEventEntryWhereInput | PosEventEntryWhereInput[]
    amount?: DecimalFilter<"PosEventEntry"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"PosEventEntry"> | string
    posEvent?: XOR<PosEventScalarRelationFilter, PosEventWhereInput>
  }, "id">

  export type PosEventEntryOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    _count?: PosEventEntryCountOrderByAggregateInput
    _avg?: PosEventEntryAvgOrderByAggregateInput
    _max?: PosEventEntryMaxOrderByAggregateInput
    _min?: PosEventEntryMinOrderByAggregateInput
    _sum?: PosEventEntrySumOrderByAggregateInput
  }

  export type PosEventEntryScalarWhereWithAggregatesInput = {
    AND?: PosEventEntryScalarWhereWithAggregatesInput | PosEventEntryScalarWhereWithAggregatesInput[]
    OR?: PosEventEntryScalarWhereWithAggregatesInput[]
    NOT?: PosEventEntryScalarWhereWithAggregatesInput | PosEventEntryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosEventEntry"> | string
    amount?: DecimalWithAggregatesFilter<"PosEventEntry"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"PosEventEntry"> | string
  }

  export type PosEventOutputWhereInput = {
    AND?: PosEventOutputWhereInput | PosEventOutputWhereInput[]
    OR?: PosEventOutputWhereInput[]
    NOT?: PosEventOutputWhereInput | PosEventOutputWhereInput[]
    id?: UuidFilter<"PosEventOutput"> | string
    amount?: DecimalFilter<"PosEventOutput"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"PosEventOutput"> | string
    posEvent?: XOR<PosEventScalarRelationFilter, PosEventWhereInput>
  }

  export type PosEventOutputOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    posEvent?: PosEventOrderByWithRelationInput
  }

  export type PosEventOutputWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosEventOutputWhereInput | PosEventOutputWhereInput[]
    OR?: PosEventOutputWhereInput[]
    NOT?: PosEventOutputWhereInput | PosEventOutputWhereInput[]
    amount?: DecimalFilter<"PosEventOutput"> | Decimal | DecimalJsLike | number | string
    description?: StringFilter<"PosEventOutput"> | string
    posEvent?: XOR<PosEventScalarRelationFilter, PosEventWhereInput>
  }, "id">

  export type PosEventOutputOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    _count?: PosEventOutputCountOrderByAggregateInput
    _avg?: PosEventOutputAvgOrderByAggregateInput
    _max?: PosEventOutputMaxOrderByAggregateInput
    _min?: PosEventOutputMinOrderByAggregateInput
    _sum?: PosEventOutputSumOrderByAggregateInput
  }

  export type PosEventOutputScalarWhereWithAggregatesInput = {
    AND?: PosEventOutputScalarWhereWithAggregatesInput | PosEventOutputScalarWhereWithAggregatesInput[]
    OR?: PosEventOutputScalarWhereWithAggregatesInput[]
    NOT?: PosEventOutputScalarWhereWithAggregatesInput | PosEventOutputScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosEventOutput"> | string
    amount?: DecimalWithAggregatesFilter<"PosEventOutput"> | Decimal | DecimalJsLike | number | string
    description?: StringWithAggregatesFilter<"PosEventOutput"> | string
  }

  export type PosEventSaleWhereInput = {
    AND?: PosEventSaleWhereInput | PosEventSaleWhereInput[]
    OR?: PosEventSaleWhereInput[]
    NOT?: PosEventSaleWhereInput | PosEventSaleWhereInput[]
    id?: UuidFilter<"PosEventSale"> | string
    description?: StringFilter<"PosEventSale"> | string
    amount?: DecimalFilter<"PosEventSale"> | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFilter<"PosEventSale"> | $Enums.EDiscountVariant
    discountValue?: FloatFilter<"PosEventSale"> | number
    customerId?: UuidFilter<"PosEventSale"> | string
    saleId?: UuidFilter<"PosEventSale"> | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    posEvent?: XOR<PosEventScalarRelationFilter, PosEventWhereInput>
    products?: PosEventSaleProductListRelationFilter
    movements?: PosEventSaleMovementListRelationFilter
  }

  export type PosEventSaleOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
    sale?: SaleOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    posEvent?: PosEventOrderByWithRelationInput
    products?: PosEventSaleProductOrderByRelationAggregateInput
    movements?: PosEventSaleMovementOrderByRelationAggregateInput
  }

  export type PosEventSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosEventSaleWhereInput | PosEventSaleWhereInput[]
    OR?: PosEventSaleWhereInput[]
    NOT?: PosEventSaleWhereInput | PosEventSaleWhereInput[]
    description?: StringFilter<"PosEventSale"> | string
    amount?: DecimalFilter<"PosEventSale"> | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFilter<"PosEventSale"> | $Enums.EDiscountVariant
    discountValue?: FloatFilter<"PosEventSale"> | number
    customerId?: UuidFilter<"PosEventSale"> | string
    saleId?: UuidFilter<"PosEventSale"> | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    posEvent?: XOR<PosEventScalarRelationFilter, PosEventWhereInput>
    products?: PosEventSaleProductListRelationFilter
    movements?: PosEventSaleMovementListRelationFilter
  }, "id">

  export type PosEventSaleOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
    _count?: PosEventSaleCountOrderByAggregateInput
    _avg?: PosEventSaleAvgOrderByAggregateInput
    _max?: PosEventSaleMaxOrderByAggregateInput
    _min?: PosEventSaleMinOrderByAggregateInput
    _sum?: PosEventSaleSumOrderByAggregateInput
  }

  export type PosEventSaleScalarWhereWithAggregatesInput = {
    AND?: PosEventSaleScalarWhereWithAggregatesInput | PosEventSaleScalarWhereWithAggregatesInput[]
    OR?: PosEventSaleScalarWhereWithAggregatesInput[]
    NOT?: PosEventSaleScalarWhereWithAggregatesInput | PosEventSaleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosEventSale"> | string
    description?: StringWithAggregatesFilter<"PosEventSale"> | string
    amount?: DecimalWithAggregatesFilter<"PosEventSale"> | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantWithAggregatesFilter<"PosEventSale"> | $Enums.EDiscountVariant
    discountValue?: FloatWithAggregatesFilter<"PosEventSale"> | number
    customerId?: UuidWithAggregatesFilter<"PosEventSale"> | string
    saleId?: UuidWithAggregatesFilter<"PosEventSale"> | string
  }

  export type PosEventSaleMovementWhereInput = {
    AND?: PosEventSaleMovementWhereInput | PosEventSaleMovementWhereInput[]
    OR?: PosEventSaleMovementWhereInput[]
    NOT?: PosEventSaleMovementWhereInput | PosEventSaleMovementWhereInput[]
    id?: UuidFilter<"PosEventSaleMovement"> | string
    type?: EnumESaleMovementTypeFilter<"PosEventSaleMovement"> | $Enums.ESaleMovementType
    createdAt?: DateTimeFilter<"PosEventSaleMovement"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovement"> | Date | string
    posEventSaleId?: UuidFilter<"PosEventSaleMovement"> | string
    posEventSale?: XOR<PosEventSaleScalarRelationFilter, PosEventSaleWhereInput>
    payments?: PosEventSaleMovementPaymentListRelationFilter
    changes?: PosEventSaleMovementChangeListRelationFilter
  }

  export type PosEventSaleMovementOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posEventSaleId?: SortOrder
    posEventSale?: PosEventSaleOrderByWithRelationInput
    payments?: PosEventSaleMovementPaymentOrderByRelationAggregateInput
    changes?: PosEventSaleMovementChangeOrderByRelationAggregateInput
  }

  export type PosEventSaleMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosEventSaleMovementWhereInput | PosEventSaleMovementWhereInput[]
    OR?: PosEventSaleMovementWhereInput[]
    NOT?: PosEventSaleMovementWhereInput | PosEventSaleMovementWhereInput[]
    type?: EnumESaleMovementTypeFilter<"PosEventSaleMovement"> | $Enums.ESaleMovementType
    createdAt?: DateTimeFilter<"PosEventSaleMovement"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovement"> | Date | string
    posEventSaleId?: UuidFilter<"PosEventSaleMovement"> | string
    posEventSale?: XOR<PosEventSaleScalarRelationFilter, PosEventSaleWhereInput>
    payments?: PosEventSaleMovementPaymentListRelationFilter
    changes?: PosEventSaleMovementChangeListRelationFilter
  }, "id">

  export type PosEventSaleMovementOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posEventSaleId?: SortOrder
    _count?: PosEventSaleMovementCountOrderByAggregateInput
    _max?: PosEventSaleMovementMaxOrderByAggregateInput
    _min?: PosEventSaleMovementMinOrderByAggregateInput
  }

  export type PosEventSaleMovementScalarWhereWithAggregatesInput = {
    AND?: PosEventSaleMovementScalarWhereWithAggregatesInput | PosEventSaleMovementScalarWhereWithAggregatesInput[]
    OR?: PosEventSaleMovementScalarWhereWithAggregatesInput[]
    NOT?: PosEventSaleMovementScalarWhereWithAggregatesInput | PosEventSaleMovementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosEventSaleMovement"> | string
    type?: EnumESaleMovementTypeWithAggregatesFilter<"PosEventSaleMovement"> | $Enums.ESaleMovementType
    createdAt?: DateTimeWithAggregatesFilter<"PosEventSaleMovement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PosEventSaleMovement"> | Date | string
    posEventSaleId?: UuidWithAggregatesFilter<"PosEventSaleMovement"> | string
  }

  export type PosEventSaleMovementPaymentWhereInput = {
    AND?: PosEventSaleMovementPaymentWhereInput | PosEventSaleMovementPaymentWhereInput[]
    OR?: PosEventSaleMovementPaymentWhereInput[]
    NOT?: PosEventSaleMovementPaymentWhereInput | PosEventSaleMovementPaymentWhereInput[]
    id?: UuidFilter<"PosEventSaleMovementPayment"> | string
    method?: EnumEPaymentMethodFilter<"PosEventSaleMovementPayment"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"PosEventSaleMovementPayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PosEventSaleMovementPayment"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovementPayment"> | Date | string
    posEventSaleMovement?: XOR<PosEventSaleMovementScalarRelationFilter, PosEventSaleMovementWhereInput>
  }

  export type PosEventSaleMovementPaymentOrderByWithRelationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posEventSaleMovement?: PosEventSaleMovementOrderByWithRelationInput
  }

  export type PosEventSaleMovementPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosEventSaleMovementPaymentWhereInput | PosEventSaleMovementPaymentWhereInput[]
    OR?: PosEventSaleMovementPaymentWhereInput[]
    NOT?: PosEventSaleMovementPaymentWhereInput | PosEventSaleMovementPaymentWhereInput[]
    method?: EnumEPaymentMethodFilter<"PosEventSaleMovementPayment"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"PosEventSaleMovementPayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PosEventSaleMovementPayment"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovementPayment"> | Date | string
    posEventSaleMovement?: XOR<PosEventSaleMovementScalarRelationFilter, PosEventSaleMovementWhereInput>
  }, "id">

  export type PosEventSaleMovementPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PosEventSaleMovementPaymentCountOrderByAggregateInput
    _avg?: PosEventSaleMovementPaymentAvgOrderByAggregateInput
    _max?: PosEventSaleMovementPaymentMaxOrderByAggregateInput
    _min?: PosEventSaleMovementPaymentMinOrderByAggregateInput
    _sum?: PosEventSaleMovementPaymentSumOrderByAggregateInput
  }

  export type PosEventSaleMovementPaymentScalarWhereWithAggregatesInput = {
    AND?: PosEventSaleMovementPaymentScalarWhereWithAggregatesInput | PosEventSaleMovementPaymentScalarWhereWithAggregatesInput[]
    OR?: PosEventSaleMovementPaymentScalarWhereWithAggregatesInput[]
    NOT?: PosEventSaleMovementPaymentScalarWhereWithAggregatesInput | PosEventSaleMovementPaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosEventSaleMovementPayment"> | string
    method?: EnumEPaymentMethodWithAggregatesFilter<"PosEventSaleMovementPayment"> | $Enums.EPaymentMethod
    amount?: DecimalWithAggregatesFilter<"PosEventSaleMovementPayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PosEventSaleMovementPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PosEventSaleMovementPayment"> | Date | string
  }

  export type PosEventSaleMovementChangeWhereInput = {
    AND?: PosEventSaleMovementChangeWhereInput | PosEventSaleMovementChangeWhereInput[]
    OR?: PosEventSaleMovementChangeWhereInput[]
    NOT?: PosEventSaleMovementChangeWhereInput | PosEventSaleMovementChangeWhereInput[]
    id?: UuidFilter<"PosEventSaleMovementChange"> | string
    method?: EnumEPaymentMethodFilter<"PosEventSaleMovementChange"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"PosEventSaleMovementChange"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PosEventSaleMovementChange"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovementChange"> | Date | string
    posEventSaleMovement?: XOR<PosEventSaleMovementScalarRelationFilter, PosEventSaleMovementWhereInput>
  }

  export type PosEventSaleMovementChangeOrderByWithRelationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posEventSaleMovement?: PosEventSaleMovementOrderByWithRelationInput
  }

  export type PosEventSaleMovementChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosEventSaleMovementChangeWhereInput | PosEventSaleMovementChangeWhereInput[]
    OR?: PosEventSaleMovementChangeWhereInput[]
    NOT?: PosEventSaleMovementChangeWhereInput | PosEventSaleMovementChangeWhereInput[]
    method?: EnumEPaymentMethodFilter<"PosEventSaleMovementChange"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"PosEventSaleMovementChange"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PosEventSaleMovementChange"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovementChange"> | Date | string
    posEventSaleMovement?: XOR<PosEventSaleMovementScalarRelationFilter, PosEventSaleMovementWhereInput>
  }, "id">

  export type PosEventSaleMovementChangeOrderByWithAggregationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PosEventSaleMovementChangeCountOrderByAggregateInput
    _avg?: PosEventSaleMovementChangeAvgOrderByAggregateInput
    _max?: PosEventSaleMovementChangeMaxOrderByAggregateInput
    _min?: PosEventSaleMovementChangeMinOrderByAggregateInput
    _sum?: PosEventSaleMovementChangeSumOrderByAggregateInput
  }

  export type PosEventSaleMovementChangeScalarWhereWithAggregatesInput = {
    AND?: PosEventSaleMovementChangeScalarWhereWithAggregatesInput | PosEventSaleMovementChangeScalarWhereWithAggregatesInput[]
    OR?: PosEventSaleMovementChangeScalarWhereWithAggregatesInput[]
    NOT?: PosEventSaleMovementChangeScalarWhereWithAggregatesInput | PosEventSaleMovementChangeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosEventSaleMovementChange"> | string
    method?: EnumEPaymentMethodWithAggregatesFilter<"PosEventSaleMovementChange"> | $Enums.EPaymentMethod
    amount?: DecimalWithAggregatesFilter<"PosEventSaleMovementChange"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PosEventSaleMovementChange"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PosEventSaleMovementChange"> | Date | string
  }

  export type PosEventSaleProductWhereInput = {
    AND?: PosEventSaleProductWhereInput | PosEventSaleProductWhereInput[]
    OR?: PosEventSaleProductWhereInput[]
    NOT?: PosEventSaleProductWhereInput | PosEventSaleProductWhereInput[]
    id?: UuidFilter<"PosEventSaleProduct"> | string
    name?: StringFilter<"PosEventSaleProduct"> | string
    description?: StringFilter<"PosEventSaleProduct"> | string
    costPrice?: DecimalFilter<"PosEventSaleProduct"> | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFilter<"PosEventSaleProduct"> | Decimal | DecimalJsLike | number | string
    totalQty?: IntFilter<"PosEventSaleProduct"> | number
    createdAt?: DateTimeFilter<"PosEventSaleProduct"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleProduct"> | Date | string
    productId?: UuidFilter<"PosEventSaleProduct"> | string
    posEventSale?: XOR<PosEventSaleScalarRelationFilter, PosEventSaleWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type PosEventSaleProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    posEventSale?: PosEventSaleOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PosEventSaleProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PosEventSaleProductWhereInput | PosEventSaleProductWhereInput[]
    OR?: PosEventSaleProductWhereInput[]
    NOT?: PosEventSaleProductWhereInput | PosEventSaleProductWhereInput[]
    name?: StringFilter<"PosEventSaleProduct"> | string
    description?: StringFilter<"PosEventSaleProduct"> | string
    costPrice?: DecimalFilter<"PosEventSaleProduct"> | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFilter<"PosEventSaleProduct"> | Decimal | DecimalJsLike | number | string
    totalQty?: IntFilter<"PosEventSaleProduct"> | number
    createdAt?: DateTimeFilter<"PosEventSaleProduct"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleProduct"> | Date | string
    productId?: UuidFilter<"PosEventSaleProduct"> | string
    posEventSale?: XOR<PosEventSaleScalarRelationFilter, PosEventSaleWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type PosEventSaleProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
    _count?: PosEventSaleProductCountOrderByAggregateInput
    _avg?: PosEventSaleProductAvgOrderByAggregateInput
    _max?: PosEventSaleProductMaxOrderByAggregateInput
    _min?: PosEventSaleProductMinOrderByAggregateInput
    _sum?: PosEventSaleProductSumOrderByAggregateInput
  }

  export type PosEventSaleProductScalarWhereWithAggregatesInput = {
    AND?: PosEventSaleProductScalarWhereWithAggregatesInput | PosEventSaleProductScalarWhereWithAggregatesInput[]
    OR?: PosEventSaleProductScalarWhereWithAggregatesInput[]
    NOT?: PosEventSaleProductScalarWhereWithAggregatesInput | PosEventSaleProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PosEventSaleProduct"> | string
    name?: StringWithAggregatesFilter<"PosEventSaleProduct"> | string
    description?: StringWithAggregatesFilter<"PosEventSaleProduct"> | string
    costPrice?: DecimalWithAggregatesFilter<"PosEventSaleProduct"> | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalWithAggregatesFilter<"PosEventSaleProduct"> | Decimal | DecimalJsLike | number | string
    totalQty?: IntWithAggregatesFilter<"PosEventSaleProduct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PosEventSaleProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PosEventSaleProduct"> | Date | string
    productId?: UuidWithAggregatesFilter<"PosEventSaleProduct"> | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    barCode?: StringFilter<"Product"> | string
    internalCode?: StringFilter<"Product"> | string
    active?: BoolFilter<"Product"> | boolean
    skuCode?: StringFilter<"Product"> | string
    tenantId?: UuidFilter<"Product"> | string
    salePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    stock?: XOR<StockNullableScalarRelationFilter, StockWhereInput> | null
    Tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    saleProducts?: SaleProductListRelationFilter
    specifications?: ProductSpecificationListRelationFilter
    PosEventSaleProduct?: PosEventSaleProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barCode?: SortOrder
    internalCode?: SortOrder
    active?: SortOrder
    skuCode?: SortOrder
    tenantId?: SortOrder
    salePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    stock?: StockOrderByWithRelationInput
    Tenant?: TenantOrderByWithRelationInput
    saleProducts?: SaleProductOrderByRelationAggregateInput
    specifications?: ProductSpecificationOrderByRelationAggregateInput
    PosEventSaleProduct?: PosEventSaleProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    barCode?: string
    internalCode?: string
    skuCode?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    active?: BoolFilter<"Product"> | boolean
    tenantId?: UuidFilter<"Product"> | string
    salePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    stock?: XOR<StockNullableScalarRelationFilter, StockWhereInput> | null
    Tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    saleProducts?: SaleProductListRelationFilter
    specifications?: ProductSpecificationListRelationFilter
    PosEventSaleProduct?: PosEventSaleProductListRelationFilter
  }, "id" | "barCode" | "internalCode" | "skuCode">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barCode?: SortOrder
    internalCode?: SortOrder
    active?: SortOrder
    skuCode?: SortOrder
    tenantId?: SortOrder
    salePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    barCode?: StringWithAggregatesFilter<"Product"> | string
    internalCode?: StringWithAggregatesFilter<"Product"> | string
    active?: BoolWithAggregatesFilter<"Product"> | boolean
    skuCode?: StringWithAggregatesFilter<"Product"> | string
    tenantId?: UuidWithAggregatesFilter<"Product"> | string
    salePrice?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
  }

  export type ProductSpecificationWhereInput = {
    AND?: ProductSpecificationWhereInput | ProductSpecificationWhereInput[]
    OR?: ProductSpecificationWhereInput[]
    NOT?: ProductSpecificationWhereInput | ProductSpecificationWhereInput[]
    id?: UuidFilter<"ProductSpecification"> | string
    label?: StringFilter<"ProductSpecification"> | string
    value?: StringFilter<"ProductSpecification"> | string
    productId?: UuidFilter<"ProductSpecification"> | string
    createdAt?: DateTimeFilter<"ProductSpecification"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSpecification"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductSpecificationOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductSpecificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductSpecificationWhereInput | ProductSpecificationWhereInput[]
    OR?: ProductSpecificationWhereInput[]
    NOT?: ProductSpecificationWhereInput | ProductSpecificationWhereInput[]
    label?: StringFilter<"ProductSpecification"> | string
    value?: StringFilter<"ProductSpecification"> | string
    productId?: UuidFilter<"ProductSpecification"> | string
    createdAt?: DateTimeFilter<"ProductSpecification"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSpecification"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductSpecificationOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductSpecificationCountOrderByAggregateInput
    _max?: ProductSpecificationMaxOrderByAggregateInput
    _min?: ProductSpecificationMinOrderByAggregateInput
  }

  export type ProductSpecificationScalarWhereWithAggregatesInput = {
    AND?: ProductSpecificationScalarWhereWithAggregatesInput | ProductSpecificationScalarWhereWithAggregatesInput[]
    OR?: ProductSpecificationScalarWhereWithAggregatesInput[]
    NOT?: ProductSpecificationScalarWhereWithAggregatesInput | ProductSpecificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductSpecification"> | string
    label?: StringWithAggregatesFilter<"ProductSpecification"> | string
    value?: StringWithAggregatesFilter<"ProductSpecification"> | string
    productId?: UuidWithAggregatesFilter<"ProductSpecification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductSpecification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductSpecification"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: UuidFilter<"Sale"> | string
    status?: EnumESaleStatusFilter<"Sale"> | $Enums.ESaleStatus
    internalCode?: StringFilter<"Sale"> | string
    customerId?: UuidFilter<"Sale"> | string
    tenantId?: UuidFilter<"Sale"> | string
    discountVariant?: EnumEDiscountVariantFilter<"Sale"> | $Enums.EDiscountVariant
    discountValue?: FloatFilter<"Sale"> | number
    paidTotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Sale"> | Date | string | null
    products?: SaleProductListRelationFilter
    movements?: SaleMovementListRelationFilter
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    PosEventSale?: PosEventSaleListRelationFilter
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    internalCode?: SortOrder
    customerId?: SortOrder
    tenantId?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    paidTotal?: SortOrder
    estimatedTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    products?: SaleProductOrderByRelationAggregateInput
    movements?: SaleMovementOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    PosEventSale?: PosEventSaleOrderByRelationAggregateInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    internalCode?: string
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    status?: EnumESaleStatusFilter<"Sale"> | $Enums.ESaleStatus
    customerId?: UuidFilter<"Sale"> | string
    tenantId?: UuidFilter<"Sale"> | string
    discountVariant?: EnumEDiscountVariantFilter<"Sale"> | $Enums.EDiscountVariant
    discountValue?: FloatFilter<"Sale"> | number
    paidTotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Sale"> | Date | string | null
    products?: SaleProductListRelationFilter
    movements?: SaleMovementListRelationFilter
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    PosEventSale?: PosEventSaleListRelationFilter
  }, "id" | "internalCode">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    internalCode?: SortOrder
    customerId?: SortOrder
    tenantId?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    paidTotal?: SortOrder
    estimatedTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Sale"> | string
    status?: EnumESaleStatusWithAggregatesFilter<"Sale"> | $Enums.ESaleStatus
    internalCode?: StringWithAggregatesFilter<"Sale"> | string
    customerId?: UuidWithAggregatesFilter<"Sale"> | string
    tenantId?: UuidWithAggregatesFilter<"Sale"> | string
    discountVariant?: EnumEDiscountVariantWithAggregatesFilter<"Sale"> | $Enums.EDiscountVariant
    discountValue?: FloatWithAggregatesFilter<"Sale"> | number
    paidTotal?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalWithAggregatesFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Sale"> | Date | string | null
  }

  export type SaleMovementWhereInput = {
    AND?: SaleMovementWhereInput | SaleMovementWhereInput[]
    OR?: SaleMovementWhereInput[]
    NOT?: SaleMovementWhereInput | SaleMovementWhereInput[]
    id?: UuidFilter<"SaleMovement"> | string
    type?: EnumESaleMovementTypeFilter<"SaleMovement"> | $Enums.ESaleMovementType
    createdAt?: DateTimeFilter<"SaleMovement"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovement"> | Date | string
    saleId?: UuidFilter<"SaleMovement"> | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    payments?: SaleMovementPaymentListRelationFilter
    changes?: SaleMovementChangeListRelationFilter
  }

  export type SaleMovementOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
    sale?: SaleOrderByWithRelationInput
    payments?: SaleMovementPaymentOrderByRelationAggregateInput
    changes?: SaleMovementChangeOrderByRelationAggregateInput
  }

  export type SaleMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleMovementWhereInput | SaleMovementWhereInput[]
    OR?: SaleMovementWhereInput[]
    NOT?: SaleMovementWhereInput | SaleMovementWhereInput[]
    type?: EnumESaleMovementTypeFilter<"SaleMovement"> | $Enums.ESaleMovementType
    createdAt?: DateTimeFilter<"SaleMovement"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovement"> | Date | string
    saleId?: UuidFilter<"SaleMovement"> | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    payments?: SaleMovementPaymentListRelationFilter
    changes?: SaleMovementChangeListRelationFilter
  }, "id">

  export type SaleMovementOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
    _count?: SaleMovementCountOrderByAggregateInput
    _max?: SaleMovementMaxOrderByAggregateInput
    _min?: SaleMovementMinOrderByAggregateInput
  }

  export type SaleMovementScalarWhereWithAggregatesInput = {
    AND?: SaleMovementScalarWhereWithAggregatesInput | SaleMovementScalarWhereWithAggregatesInput[]
    OR?: SaleMovementScalarWhereWithAggregatesInput[]
    NOT?: SaleMovementScalarWhereWithAggregatesInput | SaleMovementScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SaleMovement"> | string
    type?: EnumESaleMovementTypeWithAggregatesFilter<"SaleMovement"> | $Enums.ESaleMovementType
    createdAt?: DateTimeWithAggregatesFilter<"SaleMovement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaleMovement"> | Date | string
    saleId?: UuidWithAggregatesFilter<"SaleMovement"> | string
  }

  export type SaleMovementPaymentWhereInput = {
    AND?: SaleMovementPaymentWhereInput | SaleMovementPaymentWhereInput[]
    OR?: SaleMovementPaymentWhereInput[]
    NOT?: SaleMovementPaymentWhereInput | SaleMovementPaymentWhereInput[]
    id?: UuidFilter<"SaleMovementPayment"> | string
    method?: EnumEPaymentMethodFilter<"SaleMovementPayment"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"SaleMovementPayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleMovementPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovementPayment"> | Date | string
    saleMovement?: XOR<SaleMovementScalarRelationFilter, SaleMovementWhereInput>
  }

  export type SaleMovementPaymentOrderByWithRelationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleMovement?: SaleMovementOrderByWithRelationInput
  }

  export type SaleMovementPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleMovementPaymentWhereInput | SaleMovementPaymentWhereInput[]
    OR?: SaleMovementPaymentWhereInput[]
    NOT?: SaleMovementPaymentWhereInput | SaleMovementPaymentWhereInput[]
    method?: EnumEPaymentMethodFilter<"SaleMovementPayment"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"SaleMovementPayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleMovementPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovementPayment"> | Date | string
    saleMovement?: XOR<SaleMovementScalarRelationFilter, SaleMovementWhereInput>
  }, "id">

  export type SaleMovementPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleMovementPaymentCountOrderByAggregateInput
    _avg?: SaleMovementPaymentAvgOrderByAggregateInput
    _max?: SaleMovementPaymentMaxOrderByAggregateInput
    _min?: SaleMovementPaymentMinOrderByAggregateInput
    _sum?: SaleMovementPaymentSumOrderByAggregateInput
  }

  export type SaleMovementPaymentScalarWhereWithAggregatesInput = {
    AND?: SaleMovementPaymentScalarWhereWithAggregatesInput | SaleMovementPaymentScalarWhereWithAggregatesInput[]
    OR?: SaleMovementPaymentScalarWhereWithAggregatesInput[]
    NOT?: SaleMovementPaymentScalarWhereWithAggregatesInput | SaleMovementPaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SaleMovementPayment"> | string
    method?: EnumEPaymentMethodWithAggregatesFilter<"SaleMovementPayment"> | $Enums.EPaymentMethod
    amount?: DecimalWithAggregatesFilter<"SaleMovementPayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SaleMovementPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaleMovementPayment"> | Date | string
  }

  export type SaleMovementChangeWhereInput = {
    AND?: SaleMovementChangeWhereInput | SaleMovementChangeWhereInput[]
    OR?: SaleMovementChangeWhereInput[]
    NOT?: SaleMovementChangeWhereInput | SaleMovementChangeWhereInput[]
    id?: UuidFilter<"SaleMovementChange"> | string
    method?: EnumEPaymentMethodFilter<"SaleMovementChange"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"SaleMovementChange"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleMovementChange"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovementChange"> | Date | string
    saleMovement?: XOR<SaleMovementScalarRelationFilter, SaleMovementWhereInput>
  }

  export type SaleMovementChangeOrderByWithRelationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleMovement?: SaleMovementOrderByWithRelationInput
  }

  export type SaleMovementChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleMovementChangeWhereInput | SaleMovementChangeWhereInput[]
    OR?: SaleMovementChangeWhereInput[]
    NOT?: SaleMovementChangeWhereInput | SaleMovementChangeWhereInput[]
    method?: EnumEPaymentMethodFilter<"SaleMovementChange"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"SaleMovementChange"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleMovementChange"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovementChange"> | Date | string
    saleMovement?: XOR<SaleMovementScalarRelationFilter, SaleMovementWhereInput>
  }, "id">

  export type SaleMovementChangeOrderByWithAggregationInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleMovementChangeCountOrderByAggregateInput
    _avg?: SaleMovementChangeAvgOrderByAggregateInput
    _max?: SaleMovementChangeMaxOrderByAggregateInput
    _min?: SaleMovementChangeMinOrderByAggregateInput
    _sum?: SaleMovementChangeSumOrderByAggregateInput
  }

  export type SaleMovementChangeScalarWhereWithAggregatesInput = {
    AND?: SaleMovementChangeScalarWhereWithAggregatesInput | SaleMovementChangeScalarWhereWithAggregatesInput[]
    OR?: SaleMovementChangeScalarWhereWithAggregatesInput[]
    NOT?: SaleMovementChangeScalarWhereWithAggregatesInput | SaleMovementChangeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SaleMovementChange"> | string
    method?: EnumEPaymentMethodWithAggregatesFilter<"SaleMovementChange"> | $Enums.EPaymentMethod
    amount?: DecimalWithAggregatesFilter<"SaleMovementChange"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"SaleMovementChange"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaleMovementChange"> | Date | string
  }

  export type SaleProductWhereInput = {
    AND?: SaleProductWhereInput | SaleProductWhereInput[]
    OR?: SaleProductWhereInput[]
    NOT?: SaleProductWhereInput | SaleProductWhereInput[]
    id?: UuidFilter<"SaleProduct"> | string
    name?: StringFilter<"SaleProduct"> | string
    description?: StringFilter<"SaleProduct"> | string
    costPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    totalQty?: IntFilter<"SaleProduct"> | number
    createdAt?: DateTimeFilter<"SaleProduct"> | Date | string
    updatedAt?: DateTimeFilter<"SaleProduct"> | Date | string
    saleId?: UuidFilter<"SaleProduct"> | string
    productId?: UuidFilter<"SaleProduct"> | string
    stockLotId?: UuidFilter<"SaleProduct"> | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    stockLot?: XOR<StockLotScalarRelationFilter, StockLotWhereInput>
  }

  export type SaleProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    stockLotId?: SortOrder
    sale?: SaleOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    stockLot?: StockLotOrderByWithRelationInput
  }

  export type SaleProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    saleId_productId?: SaleProductSaleIdProductIdCompoundUniqueInput
    AND?: SaleProductWhereInput | SaleProductWhereInput[]
    OR?: SaleProductWhereInput[]
    NOT?: SaleProductWhereInput | SaleProductWhereInput[]
    name?: StringFilter<"SaleProduct"> | string
    description?: StringFilter<"SaleProduct"> | string
    costPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    totalQty?: IntFilter<"SaleProduct"> | number
    createdAt?: DateTimeFilter<"SaleProduct"> | Date | string
    updatedAt?: DateTimeFilter<"SaleProduct"> | Date | string
    saleId?: UuidFilter<"SaleProduct"> | string
    productId?: UuidFilter<"SaleProduct"> | string
    stockLotId?: UuidFilter<"SaleProduct"> | string
    sale?: XOR<SaleScalarRelationFilter, SaleWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    stockLot?: XOR<StockLotScalarRelationFilter, StockLotWhereInput>
  }, "id" | "saleId_productId">

  export type SaleProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    stockLotId?: SortOrder
    _count?: SaleProductCountOrderByAggregateInput
    _avg?: SaleProductAvgOrderByAggregateInput
    _max?: SaleProductMaxOrderByAggregateInput
    _min?: SaleProductMinOrderByAggregateInput
    _sum?: SaleProductSumOrderByAggregateInput
  }

  export type SaleProductScalarWhereWithAggregatesInput = {
    AND?: SaleProductScalarWhereWithAggregatesInput | SaleProductScalarWhereWithAggregatesInput[]
    OR?: SaleProductScalarWhereWithAggregatesInput[]
    NOT?: SaleProductScalarWhereWithAggregatesInput | SaleProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SaleProduct"> | string
    name?: StringWithAggregatesFilter<"SaleProduct"> | string
    description?: StringWithAggregatesFilter<"SaleProduct"> | string
    costPrice?: DecimalWithAggregatesFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalWithAggregatesFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    totalQty?: IntWithAggregatesFilter<"SaleProduct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SaleProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaleProduct"> | Date | string
    saleId?: UuidWithAggregatesFilter<"SaleProduct"> | string
    productId?: UuidWithAggregatesFilter<"SaleProduct"> | string
    stockLotId?: UuidWithAggregatesFilter<"SaleProduct"> | string
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    id?: UuidFilter<"Stock"> | string
    strategy?: EnumEStockStrategyFilter<"Stock"> | $Enums.EStockStrategy
    productId?: UuidFilter<"Stock"> | string
    totalQty?: IntFilter<"Stock"> | number
    availableQty?: IntFilter<"Stock"> | number
    tenantId?: UuidFilter<"Stock"> | string
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    lots?: StockLotListRelationFilter
    StockEvent?: StockEventListRelationFilter
  }

  export type StockOrderByWithRelationInput = {
    id?: SortOrder
    strategy?: SortOrder
    productId?: SortOrder
    totalQty?: SortOrder
    availableQty?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    lots?: StockLotOrderByRelationAggregateInput
    StockEvent?: StockEventOrderByRelationAggregateInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    strategy?: EnumEStockStrategyFilter<"Stock"> | $Enums.EStockStrategy
    totalQty?: IntFilter<"Stock"> | number
    availableQty?: IntFilter<"Stock"> | number
    tenantId?: UuidFilter<"Stock"> | string
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    lots?: StockLotListRelationFilter
    StockEvent?: StockEventListRelationFilter
  }, "id" | "productId">

  export type StockOrderByWithAggregationInput = {
    id?: SortOrder
    strategy?: SortOrder
    productId?: SortOrder
    totalQty?: SortOrder
    availableQty?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Stock"> | string
    strategy?: EnumEStockStrategyWithAggregatesFilter<"Stock"> | $Enums.EStockStrategy
    productId?: UuidWithAggregatesFilter<"Stock"> | string
    totalQty?: IntWithAggregatesFilter<"Stock"> | number
    availableQty?: IntWithAggregatesFilter<"Stock"> | number
    tenantId?: UuidWithAggregatesFilter<"Stock"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
  }

  export type StockEventWhereInput = {
    AND?: StockEventWhereInput | StockEventWhereInput[]
    OR?: StockEventWhereInput[]
    NOT?: StockEventWhereInput | StockEventWhereInput[]
    id?: UuidFilter<"StockEvent"> | string
    type?: EnumEStockEventTypeFilter<"StockEvent"> | $Enums.EStockEventType
    stockId?: UuidFilter<"StockEvent"> | string
    tenantId?: UuidFilter<"StockEvent"> | string
    description?: StringFilter<"StockEvent"> | string
    createdAt?: DateTimeFilter<"StockEvent"> | Date | string
    updatedAt?: DateTimeFilter<"StockEvent"> | Date | string
    stockLotId?: UuidNullableFilter<"StockEvent"> | string | null
    stock?: XOR<StockScalarRelationFilter, StockWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    entry?: XOR<StockEventEntryNullableScalarRelationFilter, StockEventEntryWhereInput> | null
    output?: XOR<StockEventOutputNullableScalarRelationFilter, StockEventOutputWhereInput> | null
    StockLot?: XOR<StockLotNullableScalarRelationFilter, StockLotWhereInput> | null
  }

  export type StockEventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockLotId?: SortOrderInput | SortOrder
    stock?: StockOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    entry?: StockEventEntryOrderByWithRelationInput
    output?: StockEventOutputOrderByWithRelationInput
    StockLot?: StockLotOrderByWithRelationInput
  }

  export type StockEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockEventWhereInput | StockEventWhereInput[]
    OR?: StockEventWhereInput[]
    NOT?: StockEventWhereInput | StockEventWhereInput[]
    type?: EnumEStockEventTypeFilter<"StockEvent"> | $Enums.EStockEventType
    stockId?: UuidFilter<"StockEvent"> | string
    tenantId?: UuidFilter<"StockEvent"> | string
    description?: StringFilter<"StockEvent"> | string
    createdAt?: DateTimeFilter<"StockEvent"> | Date | string
    updatedAt?: DateTimeFilter<"StockEvent"> | Date | string
    stockLotId?: UuidNullableFilter<"StockEvent"> | string | null
    stock?: XOR<StockScalarRelationFilter, StockWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    entry?: XOR<StockEventEntryNullableScalarRelationFilter, StockEventEntryWhereInput> | null
    output?: XOR<StockEventOutputNullableScalarRelationFilter, StockEventOutputWhereInput> | null
    StockLot?: XOR<StockLotNullableScalarRelationFilter, StockLotWhereInput> | null
  }, "id">

  export type StockEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockLotId?: SortOrderInput | SortOrder
    _count?: StockEventCountOrderByAggregateInput
    _max?: StockEventMaxOrderByAggregateInput
    _min?: StockEventMinOrderByAggregateInput
  }

  export type StockEventScalarWhereWithAggregatesInput = {
    AND?: StockEventScalarWhereWithAggregatesInput | StockEventScalarWhereWithAggregatesInput[]
    OR?: StockEventScalarWhereWithAggregatesInput[]
    NOT?: StockEventScalarWhereWithAggregatesInput | StockEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StockEvent"> | string
    type?: EnumEStockEventTypeWithAggregatesFilter<"StockEvent"> | $Enums.EStockEventType
    stockId?: UuidWithAggregatesFilter<"StockEvent"> | string
    tenantId?: UuidWithAggregatesFilter<"StockEvent"> | string
    description?: StringWithAggregatesFilter<"StockEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StockEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockEvent"> | Date | string
    stockLotId?: UuidNullableWithAggregatesFilter<"StockEvent"> | string | null
  }

  export type StockEventEntryWhereInput = {
    AND?: StockEventEntryWhereInput | StockEventEntryWhereInput[]
    OR?: StockEventEntryWhereInput[]
    NOT?: StockEventEntryWhereInput | StockEventEntryWhereInput[]
    id?: UuidFilter<"StockEventEntry"> | string
    quantity?: IntFilter<"StockEventEntry"> | number
    description?: StringFilter<"StockEventEntry"> | string
    stockEvent?: XOR<StockEventScalarRelationFilter, StockEventWhereInput>
  }

  export type StockEventEntryOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    stockEvent?: StockEventOrderByWithRelationInput
  }

  export type StockEventEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockEventEntryWhereInput | StockEventEntryWhereInput[]
    OR?: StockEventEntryWhereInput[]
    NOT?: StockEventEntryWhereInput | StockEventEntryWhereInput[]
    quantity?: IntFilter<"StockEventEntry"> | number
    description?: StringFilter<"StockEventEntry"> | string
    stockEvent?: XOR<StockEventScalarRelationFilter, StockEventWhereInput>
  }, "id">

  export type StockEventEntryOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    _count?: StockEventEntryCountOrderByAggregateInput
    _avg?: StockEventEntryAvgOrderByAggregateInput
    _max?: StockEventEntryMaxOrderByAggregateInput
    _min?: StockEventEntryMinOrderByAggregateInput
    _sum?: StockEventEntrySumOrderByAggregateInput
  }

  export type StockEventEntryScalarWhereWithAggregatesInput = {
    AND?: StockEventEntryScalarWhereWithAggregatesInput | StockEventEntryScalarWhereWithAggregatesInput[]
    OR?: StockEventEntryScalarWhereWithAggregatesInput[]
    NOT?: StockEventEntryScalarWhereWithAggregatesInput | StockEventEntryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StockEventEntry"> | string
    quantity?: IntWithAggregatesFilter<"StockEventEntry"> | number
    description?: StringWithAggregatesFilter<"StockEventEntry"> | string
  }

  export type StockEventOutputWhereInput = {
    AND?: StockEventOutputWhereInput | StockEventOutputWhereInput[]
    OR?: StockEventOutputWhereInput[]
    NOT?: StockEventOutputWhereInput | StockEventOutputWhereInput[]
    id?: UuidFilter<"StockEventOutput"> | string
    quantity?: IntFilter<"StockEventOutput"> | number
    description?: StringFilter<"StockEventOutput"> | string
    stockEvent?: XOR<StockEventScalarRelationFilter, StockEventWhereInput>
  }

  export type StockEventOutputOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    stockEvent?: StockEventOrderByWithRelationInput
  }

  export type StockEventOutputWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockEventOutputWhereInput | StockEventOutputWhereInput[]
    OR?: StockEventOutputWhereInput[]
    NOT?: StockEventOutputWhereInput | StockEventOutputWhereInput[]
    quantity?: IntFilter<"StockEventOutput"> | number
    description?: StringFilter<"StockEventOutput"> | string
    stockEvent?: XOR<StockEventScalarRelationFilter, StockEventWhereInput>
  }, "id">

  export type StockEventOutputOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
    _count?: StockEventOutputCountOrderByAggregateInput
    _avg?: StockEventOutputAvgOrderByAggregateInput
    _max?: StockEventOutputMaxOrderByAggregateInput
    _min?: StockEventOutputMinOrderByAggregateInput
    _sum?: StockEventOutputSumOrderByAggregateInput
  }

  export type StockEventOutputScalarWhereWithAggregatesInput = {
    AND?: StockEventOutputScalarWhereWithAggregatesInput | StockEventOutputScalarWhereWithAggregatesInput[]
    OR?: StockEventOutputScalarWhereWithAggregatesInput[]
    NOT?: StockEventOutputScalarWhereWithAggregatesInput | StockEventOutputScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StockEventOutput"> | string
    quantity?: IntWithAggregatesFilter<"StockEventOutput"> | number
    description?: StringWithAggregatesFilter<"StockEventOutput"> | string
  }

  export type StockLotWhereInput = {
    AND?: StockLotWhereInput | StockLotWhereInput[]
    OR?: StockLotWhereInput[]
    NOT?: StockLotWhereInput | StockLotWhereInput[]
    id?: UuidFilter<"StockLot"> | string
    lotNumber?: StringFilter<"StockLot"> | string
    totalQty?: IntFilter<"StockLot"> | number
    costPrice?: DecimalFilter<"StockLot"> | Decimal | DecimalJsLike | number | string
    stockId?: UuidFilter<"StockLot"> | string
    tenantId?: UuidFilter<"StockLot"> | string
    expiresAt?: DateTimeNullableFilter<"StockLot"> | Date | string | null
    createdAt?: DateTimeFilter<"StockLot"> | Date | string
    updatedAt?: DateTimeFilter<"StockLot"> | Date | string
    stock?: XOR<StockScalarRelationFilter, StockWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    stockEvents?: StockEventListRelationFilter
    saleProduct?: SaleProductListRelationFilter
  }

  export type StockLotOrderByWithRelationInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    totalQty?: SortOrder
    costPrice?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stock?: StockOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
    stockEvents?: StockEventOrderByRelationAggregateInput
    saleProduct?: SaleProductOrderByRelationAggregateInput
  }

  export type StockLotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lotNumber?: string
    AND?: StockLotWhereInput | StockLotWhereInput[]
    OR?: StockLotWhereInput[]
    NOT?: StockLotWhereInput | StockLotWhereInput[]
    totalQty?: IntFilter<"StockLot"> | number
    costPrice?: DecimalFilter<"StockLot"> | Decimal | DecimalJsLike | number | string
    stockId?: UuidFilter<"StockLot"> | string
    tenantId?: UuidFilter<"StockLot"> | string
    expiresAt?: DateTimeNullableFilter<"StockLot"> | Date | string | null
    createdAt?: DateTimeFilter<"StockLot"> | Date | string
    updatedAt?: DateTimeFilter<"StockLot"> | Date | string
    stock?: XOR<StockScalarRelationFilter, StockWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    stockEvents?: StockEventListRelationFilter
    saleProduct?: SaleProductListRelationFilter
  }, "id" | "lotNumber">

  export type StockLotOrderByWithAggregationInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    totalQty?: SortOrder
    costPrice?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockLotCountOrderByAggregateInput
    _avg?: StockLotAvgOrderByAggregateInput
    _max?: StockLotMaxOrderByAggregateInput
    _min?: StockLotMinOrderByAggregateInput
    _sum?: StockLotSumOrderByAggregateInput
  }

  export type StockLotScalarWhereWithAggregatesInput = {
    AND?: StockLotScalarWhereWithAggregatesInput | StockLotScalarWhereWithAggregatesInput[]
    OR?: StockLotScalarWhereWithAggregatesInput[]
    NOT?: StockLotScalarWhereWithAggregatesInput | StockLotScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StockLot"> | string
    lotNumber?: StringWithAggregatesFilter<"StockLot"> | string
    totalQty?: IntWithAggregatesFilter<"StockLot"> | number
    costPrice?: DecimalWithAggregatesFilter<"StockLot"> | Decimal | DecimalJsLike | number | string
    stockId?: UuidWithAggregatesFilter<"StockLot"> | string
    tenantId?: UuidWithAggregatesFilter<"StockLot"> | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"StockLot"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockLot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockLot"> | Date | string
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: UuidFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    description?: StringNullableFilter<"Tenant"> | string | null
    active?: BoolNullableFilter<"Tenant"> | boolean | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    memberships?: TenantMembershipListRelationFilter
    customers?: CustomerListRelationFilter
    products?: ProductListRelationFilter
    sales?: SaleListRelationFilter
    stocks?: StockListRelationFilter
    stockLots?: StockLotListRelationFilter
    StockEvent?: StockEventListRelationFilter
    NotificationTarget?: NotificationTargetListRelationFilter
    UserTenantSettings?: UserTenantSettingsListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    memberships?: TenantMembershipOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    stocks?: StockOrderByRelationAggregateInput
    stockLots?: StockLotOrderByRelationAggregateInput
    StockEvent?: StockEventOrderByRelationAggregateInput
    NotificationTarget?: NotificationTargetOrderByRelationAggregateInput
    UserTenantSettings?: UserTenantSettingsOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    description?: StringNullableFilter<"Tenant"> | string | null
    active?: BoolNullableFilter<"Tenant"> | boolean | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    memberships?: TenantMembershipListRelationFilter
    customers?: CustomerListRelationFilter
    products?: ProductListRelationFilter
    sales?: SaleListRelationFilter
    stocks?: StockListRelationFilter
    stockLots?: StockLotListRelationFilter
    StockEvent?: StockEventListRelationFilter
    NotificationTarget?: NotificationTargetListRelationFilter
    UserTenantSettings?: UserTenantSettingsListRelationFilter
  }, "id">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    description?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    active?: BoolNullableWithAggregatesFilter<"Tenant"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type TenantMembershipWhereInput = {
    AND?: TenantMembershipWhereInput | TenantMembershipWhereInput[]
    OR?: TenantMembershipWhereInput[]
    NOT?: TenantMembershipWhereInput | TenantMembershipWhereInput[]
    membershipId?: UuidFilter<"TenantMembership"> | string
    tenantId?: UuidFilter<"TenantMembership"> | string
    membership?: XOR<MembershipScalarRelationFilter, MembershipWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type TenantMembershipOrderByWithRelationInput = {
    membershipId?: SortOrder
    tenantId?: SortOrder
    membership?: MembershipOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type TenantMembershipWhereUniqueInput = Prisma.AtLeast<{
    membershipId_tenantId?: TenantMembershipMembershipIdTenantIdCompoundUniqueInput
    AND?: TenantMembershipWhereInput | TenantMembershipWhereInput[]
    OR?: TenantMembershipWhereInput[]
    NOT?: TenantMembershipWhereInput | TenantMembershipWhereInput[]
    membershipId?: UuidFilter<"TenantMembership"> | string
    tenantId?: UuidFilter<"TenantMembership"> | string
    membership?: XOR<MembershipScalarRelationFilter, MembershipWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "membershipId_tenantId">

  export type TenantMembershipOrderByWithAggregationInput = {
    membershipId?: SortOrder
    tenantId?: SortOrder
    _count?: TenantMembershipCountOrderByAggregateInput
    _max?: TenantMembershipMaxOrderByAggregateInput
    _min?: TenantMembershipMinOrderByAggregateInput
  }

  export type TenantMembershipScalarWhereWithAggregatesInput = {
    AND?: TenantMembershipScalarWhereWithAggregatesInput | TenantMembershipScalarWhereWithAggregatesInput[]
    OR?: TenantMembershipScalarWhereWithAggregatesInput[]
    NOT?: TenantMembershipScalarWhereWithAggregatesInput | TenantMembershipScalarWhereWithAggregatesInput[]
    membershipId?: UuidWithAggregatesFilter<"TenantMembership"> | string
    tenantId?: UuidWithAggregatesFilter<"TenantMembership"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    active?: BoolFilter<"User"> | boolean
    firstAccess?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenantSettings?: UserTenantSettingsListRelationFilter
    NotificationTarget?: NotificationTargetListRelationFilter
    memberships?: MembershipListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    firstAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenantSettings?: UserTenantSettingsOrderByRelationAggregateInput
    NotificationTarget?: NotificationTargetOrderByRelationAggregateInput
    memberships?: MembershipOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    active?: BoolFilter<"User"> | boolean
    firstAccess?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenantSettings?: UserTenantSettingsListRelationFilter
    NotificationTarget?: NotificationTargetListRelationFilter
    memberships?: MembershipListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    firstAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    active?: BoolWithAggregatesFilter<"User"> | boolean
    firstAccess?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserTenantSettingsWhereInput = {
    AND?: UserTenantSettingsWhereInput | UserTenantSettingsWhereInput[]
    OR?: UserTenantSettingsWhereInput[]
    NOT?: UserTenantSettingsWhereInput | UserTenantSettingsWhereInput[]
    doNotDisturb?: BoolFilter<"UserTenantSettings"> | boolean
    userId?: UuidFilter<"UserTenantSettings"> | string
    tenantId?: UuidFilter<"UserTenantSettings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type UserTenantSettingsOrderByWithRelationInput = {
    doNotDisturb?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type UserTenantSettingsWhereUniqueInput = Prisma.AtLeast<{
    userId_tenantId?: UserTenantSettingsUserIdTenantIdCompoundUniqueInput
    AND?: UserTenantSettingsWhereInput | UserTenantSettingsWhereInput[]
    OR?: UserTenantSettingsWhereInput[]
    NOT?: UserTenantSettingsWhereInput | UserTenantSettingsWhereInput[]
    doNotDisturb?: BoolFilter<"UserTenantSettings"> | boolean
    userId?: UuidFilter<"UserTenantSettings"> | string
    tenantId?: UuidFilter<"UserTenantSettings"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "userId_tenantId">

  export type UserTenantSettingsOrderByWithAggregationInput = {
    doNotDisturb?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    _count?: UserTenantSettingsCountOrderByAggregateInput
    _max?: UserTenantSettingsMaxOrderByAggregateInput
    _min?: UserTenantSettingsMinOrderByAggregateInput
  }

  export type UserTenantSettingsScalarWhereWithAggregatesInput = {
    AND?: UserTenantSettingsScalarWhereWithAggregatesInput | UserTenantSettingsScalarWhereWithAggregatesInput[]
    OR?: UserTenantSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserTenantSettingsScalarWhereWithAggregatesInput | UserTenantSettingsScalarWhereWithAggregatesInput[]
    doNotDisturb?: BoolWithAggregatesFilter<"UserTenantSettings"> | boolean
    userId?: UuidWithAggregatesFilter<"UserTenantSettings"> | string
    tenantId?: UuidWithAggregatesFilter<"UserTenantSettings"> | string
  }

  export type AddressCreateInput = {
    id?: string
    street: string
    houseNumber: string
    neighborhood: string
    zipCode: string
    city: string
    state: string
    complement: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    street: string
    houseNumber: string
    neighborhood: string
    zipCode: string
    city: string
    state: string
    complement: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: string
    street: string
    houseNumber: string
    neighborhood: string
    zipCode: string
    city: string
    state: string
    complement: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    houseNumber?: StringFieldUpdateOperationsInput | string
    neighborhood?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    complement?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCustomersInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
    posEventSales?: PosEventSaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    posEventSales?: PosEventSaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    posEventSales?: PosEventSaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    posEventSales?: PosEventSaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipCreateInput = {
    id?: string
    role: $Enums.EMembershipRole
    permissions?: MembershipCreatepermissionsInput | string[]
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    tenant_memberships?: TenantMembershipCreateNestedManyWithoutMembershipInput
  }

  export type MembershipUncheckedCreateInput = {
    id?: string
    role: $Enums.EMembershipRole
    permissions?: MembershipCreatepermissionsInput | string[]
    active?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant_memberships?: TenantMembershipUncheckedCreateNestedManyWithoutMembershipInput
  }

  export type MembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    tenant_memberships?: TenantMembershipUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant_memberships?: TenantMembershipUncheckedUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipCreateManyInput = {
    id?: string
    role: $Enums.EMembershipRole
    permissions?: MembershipCreatepermissionsInput | string[]
    active?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type?: $Enums.ENotificationType
    subject: string
    body: string
    href?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string
    targets?: NotificationTargetCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type?: $Enums.ENotificationType
    subject: string
    body: string
    href?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string
    targets?: NotificationTargetUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumENotificationTypeFieldUpdateOperationsInput | $Enums.ENotificationType
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targets?: NotificationTargetUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumENotificationTypeFieldUpdateOperationsInput | $Enums.ENotificationType
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targets?: NotificationTargetUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    type?: $Enums.ENotificationType
    subject: string
    body: string
    href?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumENotificationTypeFieldUpdateOperationsInput | $Enums.ENotificationType
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumENotificationTypeFieldUpdateOperationsInput | $Enums.ENotificationType
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTargetCreateInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notification: NotificationCreateNestedOneWithoutTargetsInput
    user: UserCreateNestedOneWithoutNotificationTargetInput
    tenant: TenantCreateNestedOneWithoutNotificationTargetInput
  }

  export type NotificationTargetUncheckedCreateInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notificationId: string
    userId: string
    tenantId: string
  }

  export type NotificationTargetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notification?: NotificationUpdateOneRequiredWithoutTargetsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationTargetNestedInput
    tenant?: TenantUpdateOneRequiredWithoutNotificationTargetNestedInput
  }

  export type NotificationTargetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationTargetCreateManyInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notificationId: string
    userId: string
    tenantId: string
  }

  export type NotificationTargetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
  }

  export type NotificationTargetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PosCreateInput = {
    id?: string
    name: string
    description?: string
    status?: $Enums.EPosStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PosUncheckedCreateInput = {
    id?: string
    name: string
    description?: string
    status?: $Enums.EPosStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumEPosStatusFieldUpdateOperationsInput | $Enums.EPosStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumEPosStatusFieldUpdateOperationsInput | $Enums.EPosStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PosCreateManyInput = {
    id?: string
    name: string
    description?: string
    status?: $Enums.EPosStatus
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumEPosStatusFieldUpdateOperationsInput | $Enums.EPosStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumEPosStatusFieldUpdateOperationsInput | $Enums.EPosStatus
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PosEventCreateInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    entry?: PosEventEntryCreateNestedOneWithoutPosEventInput
    output?: PosEventOutputCreateNestedOneWithoutPosEventInput
    sale?: PosEventSaleCreateNestedOneWithoutPosEventInput
  }

  export type PosEventUncheckedCreateInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    entry?: PosEventEntryUncheckedCreateNestedOneWithoutPosEventInput
    output?: PosEventOutputUncheckedCreateNestedOneWithoutPosEventInput
    sale?: PosEventSaleUncheckedCreateNestedOneWithoutPosEventInput
  }

  export type PosEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entry?: PosEventEntryUpdateOneWithoutPosEventNestedInput
    output?: PosEventOutputUpdateOneWithoutPosEventNestedInput
    sale?: PosEventSaleUpdateOneWithoutPosEventNestedInput
  }

  export type PosEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entry?: PosEventEntryUncheckedUpdateOneWithoutPosEventNestedInput
    output?: PosEventOutputUncheckedUpdateOneWithoutPosEventNestedInput
    sale?: PosEventSaleUncheckedUpdateOneWithoutPosEventNestedInput
  }

  export type PosEventCreateManyInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PosEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PosEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PosEventEntryCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    description?: string
    posEvent: PosEventCreateNestedOneWithoutEntryInput
  }

  export type PosEventEntryUncheckedCreateInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string
  }

  export type PosEventEntryUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    posEvent?: PosEventUpdateOneRequiredWithoutEntryNestedInput
  }

  export type PosEventEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventEntryCreateManyInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string
  }

  export type PosEventEntryUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventOutputCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    description?: string
    posEvent: PosEventCreateNestedOneWithoutOutputInput
  }

  export type PosEventOutputUncheckedCreateInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string
  }

  export type PosEventOutputUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
    posEvent?: PosEventUpdateOneRequiredWithoutOutputNestedInput
  }

  export type PosEventOutputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventOutputCreateManyInput = {
    id: string
    amount: Decimal | DecimalJsLike | number | string
    description?: string
  }

  export type PosEventOutputUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventOutputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventSaleCreateInput = {
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    sale: SaleCreateNestedOneWithoutPosEventSaleInput
    customer: CustomerCreateNestedOneWithoutPosEventSalesInput
    posEvent: PosEventCreateNestedOneWithoutSaleInput
    products?: PosEventSaleProductCreateNestedManyWithoutPosEventSaleInput
    movements?: PosEventSaleMovementCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleUncheckedCreateInput = {
    id: string
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    customerId: string
    saleId: string
    products?: PosEventSaleProductUncheckedCreateNestedManyWithoutPosEventSaleInput
    movements?: PosEventSaleMovementUncheckedCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    sale?: SaleUpdateOneRequiredWithoutPosEventSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPosEventSalesNestedInput
    posEvent?: PosEventUpdateOneRequiredWithoutSaleNestedInput
    products?: PosEventSaleProductUpdateManyWithoutPosEventSaleNestedInput
    movements?: PosEventSaleMovementUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    products?: PosEventSaleProductUncheckedUpdateManyWithoutPosEventSaleNestedInput
    movements?: PosEventSaleMovementUncheckedUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleCreateManyInput = {
    id: string
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    customerId: string
    saleId: string
  }

  export type PosEventSaleUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
  }

  export type PosEventSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventSaleMovementCreateInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSale: PosEventSaleCreateNestedOneWithoutMovementsInput
    payments?: PosEventSaleMovementPaymentCreateNestedManyWithoutPosEventSaleMovementInput
    changes?: PosEventSaleMovementChangeCreateNestedManyWithoutPosEventSaleMovementInput
  }

  export type PosEventSaleMovementUncheckedCreateInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSaleId: string
    payments?: PosEventSaleMovementPaymentUncheckedCreateNestedManyWithoutPosEventSaleMovementInput
    changes?: PosEventSaleMovementChangeUncheckedCreateNestedManyWithoutPosEventSaleMovementInput
  }

  export type PosEventSaleMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSale?: PosEventSaleUpdateOneRequiredWithoutMovementsNestedInput
    payments?: PosEventSaleMovementPaymentUpdateManyWithoutPosEventSaleMovementNestedInput
    changes?: PosEventSaleMovementChangeUpdateManyWithoutPosEventSaleMovementNestedInput
  }

  export type PosEventSaleMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSaleId?: StringFieldUpdateOperationsInput | string
    payments?: PosEventSaleMovementPaymentUncheckedUpdateManyWithoutPosEventSaleMovementNestedInput
    changes?: PosEventSaleMovementChangeUncheckedUpdateManyWithoutPosEventSaleMovementNestedInput
  }

  export type PosEventSaleMovementCreateManyInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSaleId: string
  }

  export type PosEventSaleMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSaleId?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventSaleMovementPaymentCreateInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSaleMovement: PosEventSaleMovementCreateNestedOneWithoutPaymentsInput
  }

  export type PosEventSaleMovementPaymentUncheckedCreateInput = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementPaymentUpdateInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSaleMovement?: PosEventSaleMovementUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PosEventSaleMovementPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementPaymentCreateManyInput = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementPaymentUpdateManyMutationInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementChangeCreateInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSaleMovement: PosEventSaleMovementCreateNestedOneWithoutChangesInput
  }

  export type PosEventSaleMovementChangeUncheckedCreateInput = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementChangeUpdateInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSaleMovement?: PosEventSaleMovementUpdateOneRequiredWithoutChangesNestedInput
  }

  export type PosEventSaleMovementChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementChangeCreateManyInput = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementChangeUpdateManyMutationInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleProductCreateInput = {
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSale?: PosEventSaleCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutPosEventSaleProductInput
  }

  export type PosEventSaleProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type PosEventSaleProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSale?: PosEventSaleUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutPosEventSaleProductNestedInput
  }

  export type PosEventSaleProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventSaleProductCreateManyInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type PosEventSaleProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockCreateNestedOneWithoutProductInput
    Tenant: TenantCreateNestedOneWithoutProductsInput
    saleProducts?: SaleProductCreateNestedManyWithoutProductInput
    specifications?: ProductSpecificationCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    tenantId: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    saleProducts?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    specifications?: ProductSpecificationUncheckedCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUpdateOneWithoutProductNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    saleProducts?: SaleProductUpdateManyWithoutProductNestedInput
    specifications?: ProductSpecificationUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    saleProducts?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    specifications?: ProductSpecificationUncheckedUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    tenantId: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductSpecificationCreateInput = {
    id?: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSpecificationsInput
  }

  export type ProductSpecificationUncheckedCreateInput = {
    id?: string
    label: string
    value: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSpecificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSpecificationsNestedInput
  }

  export type ProductSpecificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSpecificationCreateManyInput = {
    id?: string
    label: string
    value: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSpecificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSpecificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductCreateNestedManyWithoutSaleInput
    movements?: SaleMovementCreateNestedManyWithoutSaleInput
    customer: CustomerCreateNestedOneWithoutSalesInput
    tenant: TenantCreateNestedOneWithoutSalesInput
    PosEventSale?: PosEventSaleCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    customerId: string
    tenantId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    movements?: SaleMovementUncheckedCreateNestedManyWithoutSaleInput
    PosEventSale?: PosEventSaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    movements?: SaleMovementUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSalesNestedInput
    PosEventSale?: PosEventSaleUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    movements?: SaleMovementUncheckedUpdateManyWithoutSaleNestedInput
    PosEventSale?: PosEventSaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    customerId: string
    tenantId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SaleMovementCreateInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutMovementsInput
    payments?: SaleMovementPaymentCreateNestedManyWithoutSaleMovementInput
    changes?: SaleMovementChangeCreateNestedManyWithoutSaleMovementInput
  }

  export type SaleMovementUncheckedCreateInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    payments?: SaleMovementPaymentUncheckedCreateNestedManyWithoutSaleMovementInput
    changes?: SaleMovementChangeUncheckedCreateNestedManyWithoutSaleMovementInput
  }

  export type SaleMovementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutMovementsNestedInput
    payments?: SaleMovementPaymentUpdateManyWithoutSaleMovementNestedInput
    changes?: SaleMovementChangeUpdateManyWithoutSaleMovementNestedInput
  }

  export type SaleMovementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    payments?: SaleMovementPaymentUncheckedUpdateManyWithoutSaleMovementNestedInput
    changes?: SaleMovementChangeUncheckedUpdateManyWithoutSaleMovementNestedInput
  }

  export type SaleMovementCreateManyInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
  }

  export type SaleMovementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
  }

  export type SaleMovementPaymentCreateInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    saleMovement: SaleMovementCreateNestedOneWithoutPaymentsInput
  }

  export type SaleMovementPaymentUncheckedCreateInput = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementPaymentUpdateInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleMovement?: SaleMovementUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type SaleMovementPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementPaymentCreateManyInput = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementPaymentUpdateManyMutationInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementChangeCreateInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    saleMovement: SaleMovementCreateNestedOneWithoutChangesInput
  }

  export type SaleMovementChangeUncheckedCreateInput = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementChangeUpdateInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleMovement?: SaleMovementUpdateOneRequiredWithoutChangesNestedInput
  }

  export type SaleMovementChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementChangeCreateManyInput = {
    id: string
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementChangeUpdateManyMutationInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutSaleProductsInput
    stockLot: StockLotCreateNestedOneWithoutSaleProductInput
  }

  export type SaleProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    productId: string
    stockLotId: string
  }

  export type SaleProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleProductsNestedInput
    stockLot?: StockLotUpdateOneRequiredWithoutSaleProductNestedInput
  }

  export type SaleProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    stockLotId?: StringFieldUpdateOperationsInput | string
  }

  export type SaleProductCreateManyInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    productId: string
    stockLotId: string
  }

  export type SaleProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    stockLotId?: StringFieldUpdateOperationsInput | string
  }

  export type StockCreateInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    totalQty?: number
    availableQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStocksInput
    product: ProductCreateNestedOneWithoutStockInput
    lots?: StockLotCreateNestedManyWithoutStockInput
    StockEvent?: StockEventCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    productId: string
    totalQty?: number
    availableQty?: number
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: StockLotUncheckedCreateNestedManyWithoutStockInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStocksNestedInput
    product?: ProductUpdateOneRequiredWithoutStockNestedInput
    lots?: StockLotUpdateManyWithoutStockNestedInput
    StockEvent?: StockEventUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    productId?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: StockLotUncheckedUpdateManyWithoutStockNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockCreateManyInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    productId: string
    totalQty?: number
    availableQty?: number
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    productId?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockEventCreateInput = {
    id?: string
    type: $Enums.EStockEventType
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutStockEventInput
    tenant: TenantCreateNestedOneWithoutStockEventInput
    entry?: StockEventEntryCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputCreateNestedOneWithoutStockEventInput
    StockLot?: StockLotCreateNestedOneWithoutStockEventsInput
  }

  export type StockEventUncheckedCreateInput = {
    id?: string
    type: $Enums.EStockEventType
    stockId: string
    tenantId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLotId?: string | null
    entry?: StockEventEntryUncheckedCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputUncheckedCreateNestedOneWithoutStockEventInput
  }

  export type StockEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutStockEventNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStockEventNestedInput
    entry?: StockEventEntryUpdateOneWithoutStockEventNestedInput
    output?: StockEventOutputUpdateOneWithoutStockEventNestedInput
    StockLot?: StockLotUpdateOneWithoutStockEventsNestedInput
  }

  export type StockEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLotId?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: StockEventEntryUncheckedUpdateOneWithoutStockEventNestedInput
    output?: StockEventOutputUncheckedUpdateOneWithoutStockEventNestedInput
  }

  export type StockEventCreateManyInput = {
    id?: string
    type: $Enums.EStockEventType
    stockId: string
    tenantId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLotId?: string | null
  }

  export type StockEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLotId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockEventEntryCreateInput = {
    quantity: number
    description?: string
    stockEvent?: StockEventCreateNestedOneWithoutEntryInput
  }

  export type StockEventEntryUncheckedCreateInput = {
    id?: string
    quantity: number
    description?: string
  }

  export type StockEventEntryUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stockEvent?: StockEventUpdateOneRequiredWithoutEntryNestedInput
  }

  export type StockEventEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockEventEntryCreateManyInput = {
    id?: string
    quantity: number
    description?: string
  }

  export type StockEventEntryUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockEventEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockEventOutputCreateInput = {
    quantity: number
    description?: string
    stockEvent?: StockEventCreateNestedOneWithoutOutputInput
  }

  export type StockEventOutputUncheckedCreateInput = {
    id?: string
    quantity: number
    description?: string
  }

  export type StockEventOutputUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    stockEvent?: StockEventUpdateOneRequiredWithoutOutputNestedInput
  }

  export type StockEventOutputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockEventOutputCreateManyInput = {
    id?: string
    quantity: number
    description?: string
  }

  export type StockEventOutputUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockEventOutputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockLotCreateInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutLotsInput
    tenant: TenantCreateNestedOneWithoutStockLotsInput
    stockEvents?: StockEventCreateNestedManyWithoutStockLotInput
    saleProduct?: SaleProductCreateNestedManyWithoutStockLotInput
  }

  export type StockLotUncheckedCreateInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    stockId: string
    tenantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockEvents?: StockEventUncheckedCreateNestedManyWithoutStockLotInput
    saleProduct?: SaleProductUncheckedCreateNestedManyWithoutStockLotInput
  }

  export type StockLotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutLotsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStockLotsNestedInput
    stockEvents?: StockEventUpdateManyWithoutStockLotNestedInput
    saleProduct?: SaleProductUpdateManyWithoutStockLotNestedInput
  }

  export type StockLotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockEvents?: StockEventUncheckedUpdateManyWithoutStockLotNestedInput
    saleProduct?: SaleProductUncheckedUpdateManyWithoutStockLotNestedInput
  }

  export type StockLotCreateManyInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    stockId: string
    tenantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantMembershipCreateInput = {
    membership: MembershipCreateNestedOneWithoutTenant_membershipsInput
    tenant: TenantCreateNestedOneWithoutMembershipsInput
  }

  export type TenantMembershipUncheckedCreateInput = {
    membershipId: string
    tenantId: string
  }

  export type TenantMembershipUpdateInput = {
    membership?: MembershipUpdateOneRequiredWithoutTenant_membershipsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type TenantMembershipUncheckedUpdateInput = {
    membershipId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantMembershipCreateManyInput = {
    membershipId: string
    tenantId: string
  }

  export type TenantMembershipUpdateManyMutationInput = {

  }

  export type TenantMembershipUncheckedUpdateManyInput = {
    membershipId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantSettings?: UserTenantSettingsCreateNestedManyWithoutUserInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutUserInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantSettings?: UserTenantSettingsUpdateManyWithoutUserNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutUserNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTenantSettingsCreateInput = {
    doNotDisturb?: boolean
    user: UserCreateNestedOneWithoutTenantSettingsInput
    tenant: TenantCreateNestedOneWithoutUserTenantSettingsInput
  }

  export type UserTenantSettingsUncheckedCreateInput = {
    doNotDisturb?: boolean
    userId: string
    tenantId: string
  }

  export type UserTenantSettingsUpdateInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTenantSettingsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutUserTenantSettingsNestedInput
  }

  export type UserTenantSettingsUncheckedUpdateInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type UserTenantSettingsCreateManyInput = {
    doNotDisturb?: boolean
    userId: string
    tenantId: string
  }

  export type UserTenantSettingsUpdateManyMutationInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserTenantSettingsUncheckedUpdateManyInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    houseNumber?: SortOrder
    neighborhood?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    houseNumber?: SortOrder
    neighborhood?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    houseNumber?: SortOrder
    neighborhood?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type PosEventSaleListRelationFilter = {
    every?: PosEventSaleWhereInput
    some?: PosEventSaleWhereInput
    none?: PosEventSaleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosEventSaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    active?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    active?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    active?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumEMembershipRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.EMembershipRole | EnumEMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EMembershipRole[] | ListEnumEMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EMembershipRole[] | ListEnumEMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEMembershipRoleFilter<$PrismaModel> | $Enums.EMembershipRole
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TenantMembershipListRelationFilter = {
    every?: TenantMembershipWhereInput
    some?: TenantMembershipWhereInput
    none?: TenantMembershipWhereInput
  }

  export type TenantMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MembershipCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    active?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    active?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    active?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEMembershipRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EMembershipRole | EnumEMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EMembershipRole[] | ListEnumEMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EMembershipRole[] | ListEnumEMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEMembershipRoleWithAggregatesFilter<$PrismaModel> | $Enums.EMembershipRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEMembershipRoleFilter<$PrismaModel>
    _max?: NestedEnumEMembershipRoleFilter<$PrismaModel>
  }

  export type EnumENotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ENotificationType | EnumENotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ENotificationType[] | ListEnumENotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ENotificationType[] | ListEnumENotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumENotificationTypeFilter<$PrismaModel> | $Enums.ENotificationType
  }

  export type NotificationTargetListRelationFilter = {
    every?: NotificationTargetWhereInput
    some?: NotificationTargetWhereInput
    none?: NotificationTargetWhereInput
  }

  export type NotificationTargetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    href?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    href?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    href?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumENotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ENotificationType | EnumENotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ENotificationType[] | ListEnumENotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ENotificationType[] | ListEnumENotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumENotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ENotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumENotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumENotificationTypeFilter<$PrismaModel>
  }

  export type EnumENotificationTargetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ENotificationTargetStatus | EnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ENotificationTargetStatus[] | ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ENotificationTargetStatus[] | ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumENotificationTargetStatusFilter<$PrismaModel> | $Enums.ENotificationTargetStatus
  }

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type NotificationTargetNotificationIdUserIdTenantIdCompoundUniqueInput = {
    notificationId: string
    userId: string
    tenantId: string
  }

  export type NotificationTargetCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
  }

  export type NotificationTargetMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
  }

  export type NotificationTargetMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
  }

  export type EnumENotificationTargetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ENotificationTargetStatus | EnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ENotificationTargetStatus[] | ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ENotificationTargetStatus[] | ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumENotificationTargetStatusWithAggregatesFilter<$PrismaModel> | $Enums.ENotificationTargetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumENotificationTargetStatusFilter<$PrismaModel>
    _max?: NestedEnumENotificationTargetStatusFilter<$PrismaModel>
  }

  export type EnumEPosStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosStatus | EnumEPosStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EPosStatus[] | ListEnumEPosStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosStatus[] | ListEnumEPosStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosStatusFilter<$PrismaModel> | $Enums.EPosStatus
  }

  export type PosCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PosMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PosMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumEPosStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosStatus | EnumEPosStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EPosStatus[] | ListEnumEPosStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosStatus[] | ListEnumEPosStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosStatusWithAggregatesFilter<$PrismaModel> | $Enums.EPosStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEPosStatusFilter<$PrismaModel>
    _max?: NestedEnumEPosStatusFilter<$PrismaModel>
  }

  export type EnumEPosEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosEventType | EnumEPosEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EPosEventType[] | ListEnumEPosEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosEventType[] | ListEnumEPosEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosEventTypeFilter<$PrismaModel> | $Enums.EPosEventType
  }

  export type EnumEPosEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosEventStatus | EnumEPosEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EPosEventStatus[] | ListEnumEPosEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosEventStatus[] | ListEnumEPosEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosEventStatusFilter<$PrismaModel> | $Enums.EPosEventStatus
  }

  export type PosEventEntryNullableScalarRelationFilter = {
    is?: PosEventEntryWhereInput | null
    isNot?: PosEventEntryWhereInput | null
  }

  export type PosEventOutputNullableScalarRelationFilter = {
    is?: PosEventOutputWhereInput | null
    isNot?: PosEventOutputWhereInput | null
  }

  export type PosEventSaleNullableScalarRelationFilter = {
    is?: PosEventSaleWhereInput | null
    isNot?: PosEventSaleWhereInput | null
  }

  export type PosEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    posId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PosEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    posId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PosEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    posId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumEPosEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosEventType | EnumEPosEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EPosEventType[] | ListEnumEPosEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosEventType[] | ListEnumEPosEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EPosEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEPosEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEPosEventTypeFilter<$PrismaModel>
  }

  export type EnumEPosEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosEventStatus | EnumEPosEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EPosEventStatus[] | ListEnumEPosEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosEventStatus[] | ListEnumEPosEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EPosEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEPosEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEPosEventStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PosEventScalarRelationFilter = {
    is?: PosEventWhereInput
    isNot?: PosEventWhereInput
  }

  export type PosEventEntryCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
  }

  export type PosEventEntryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PosEventEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
  }

  export type PosEventEntryMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
  }

  export type PosEventEntrySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PosEventOutputCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
  }

  export type PosEventOutputAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PosEventOutputMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
  }

  export type PosEventOutputMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    description?: SortOrder
  }

  export type PosEventOutputSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumEDiscountVariantFilter<$PrismaModel = never> = {
    equals?: $Enums.EDiscountVariant | EnumEDiscountVariantFieldRefInput<$PrismaModel>
    in?: $Enums.EDiscountVariant[] | ListEnumEDiscountVariantFieldRefInput<$PrismaModel>
    notIn?: $Enums.EDiscountVariant[] | ListEnumEDiscountVariantFieldRefInput<$PrismaModel>
    not?: NestedEnumEDiscountVariantFilter<$PrismaModel> | $Enums.EDiscountVariant
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SaleScalarRelationFilter = {
    is?: SaleWhereInput
    isNot?: SaleWhereInput
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type PosEventSaleProductListRelationFilter = {
    every?: PosEventSaleProductWhereInput
    some?: PosEventSaleProductWhereInput
    none?: PosEventSaleProductWhereInput
  }

  export type PosEventSaleMovementListRelationFilter = {
    every?: PosEventSaleMovementWhereInput
    some?: PosEventSaleMovementWhereInput
    none?: PosEventSaleMovementWhereInput
  }

  export type PosEventSaleProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosEventSaleMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosEventSaleCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
  }

  export type PosEventSaleAvgOrderByAggregateInput = {
    amount?: SortOrder
    discountValue?: SortOrder
  }

  export type PosEventSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
  }

  export type PosEventSaleMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    customerId?: SortOrder
    saleId?: SortOrder
  }

  export type PosEventSaleSumOrderByAggregateInput = {
    amount?: SortOrder
    discountValue?: SortOrder
  }

  export type EnumEDiscountVariantWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EDiscountVariant | EnumEDiscountVariantFieldRefInput<$PrismaModel>
    in?: $Enums.EDiscountVariant[] | ListEnumEDiscountVariantFieldRefInput<$PrismaModel>
    notIn?: $Enums.EDiscountVariant[] | ListEnumEDiscountVariantFieldRefInput<$PrismaModel>
    not?: NestedEnumEDiscountVariantWithAggregatesFilter<$PrismaModel> | $Enums.EDiscountVariant
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEDiscountVariantFilter<$PrismaModel>
    _max?: NestedEnumEDiscountVariantFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumESaleMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ESaleMovementType | EnumESaleMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ESaleMovementType[] | ListEnumESaleMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ESaleMovementType[] | ListEnumESaleMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumESaleMovementTypeFilter<$PrismaModel> | $Enums.ESaleMovementType
  }

  export type PosEventSaleScalarRelationFilter = {
    is?: PosEventSaleWhereInput
    isNot?: PosEventSaleWhereInput
  }

  export type PosEventSaleMovementPaymentListRelationFilter = {
    every?: PosEventSaleMovementPaymentWhereInput
    some?: PosEventSaleMovementPaymentWhereInput
    none?: PosEventSaleMovementPaymentWhereInput
  }

  export type PosEventSaleMovementChangeListRelationFilter = {
    every?: PosEventSaleMovementChangeWhereInput
    some?: PosEventSaleMovementChangeWhereInput
    none?: PosEventSaleMovementChangeWhereInput
  }

  export type PosEventSaleMovementPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosEventSaleMovementChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PosEventSaleMovementCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posEventSaleId?: SortOrder
  }

  export type PosEventSaleMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posEventSaleId?: SortOrder
  }

  export type PosEventSaleMovementMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posEventSaleId?: SortOrder
  }

  export type EnumESaleMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ESaleMovementType | EnumESaleMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ESaleMovementType[] | ListEnumESaleMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ESaleMovementType[] | ListEnumESaleMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumESaleMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ESaleMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumESaleMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumESaleMovementTypeFilter<$PrismaModel>
  }

  export type EnumEPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.EPaymentMethod | EnumEPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.EPaymentMethod[] | ListEnumEPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPaymentMethod[] | ListEnumEPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumEPaymentMethodFilter<$PrismaModel> | $Enums.EPaymentMethod
  }

  export type PosEventSaleMovementScalarRelationFilter = {
    is?: PosEventSaleMovementWhereInput
    isNot?: PosEventSaleMovementWhereInput
  }

  export type PosEventSaleMovementPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosEventSaleMovementPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PosEventSaleMovementPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosEventSaleMovementPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosEventSaleMovementPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumEPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EPaymentMethod | EnumEPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.EPaymentMethod[] | ListEnumEPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPaymentMethod[] | ListEnumEPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumEPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.EPaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumEPaymentMethodFilter<$PrismaModel>
  }

  export type PosEventSaleMovementChangeCountOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosEventSaleMovementChangeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PosEventSaleMovementChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosEventSaleMovementChangeMinOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PosEventSaleMovementChangeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type PosEventSaleProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type PosEventSaleProductAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
  }

  export type PosEventSaleProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type PosEventSaleProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productId?: SortOrder
  }

  export type PosEventSaleProductSumOrderByAggregateInput = {
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StockNullableScalarRelationFilter = {
    is?: StockWhereInput | null
    isNot?: StockWhereInput | null
  }

  export type SaleProductListRelationFilter = {
    every?: SaleProductWhereInput
    some?: SaleProductWhereInput
    none?: SaleProductWhereInput
  }

  export type ProductSpecificationListRelationFilter = {
    every?: ProductSpecificationWhereInput
    some?: ProductSpecificationWhereInput
    none?: ProductSpecificationWhereInput
  }

  export type SaleProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductSpecificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barCode?: SortOrder
    internalCode?: SortOrder
    active?: SortOrder
    skuCode?: SortOrder
    tenantId?: SortOrder
    salePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    salePrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barCode?: SortOrder
    internalCode?: SortOrder
    active?: SortOrder
    skuCode?: SortOrder
    tenantId?: SortOrder
    salePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    barCode?: SortOrder
    internalCode?: SortOrder
    active?: SortOrder
    skuCode?: SortOrder
    tenantId?: SortOrder
    salePrice?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    salePrice?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProductSpecificationCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSpecificationMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSpecificationMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    value?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumESaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ESaleStatus | EnumESaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ESaleStatus[] | ListEnumESaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ESaleStatus[] | ListEnumESaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumESaleStatusFilter<$PrismaModel> | $Enums.ESaleStatus
  }

  export type SaleMovementListRelationFilter = {
    every?: SaleMovementWhereInput
    some?: SaleMovementWhereInput
    none?: SaleMovementWhereInput
  }

  export type SaleMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    internalCode?: SortOrder
    customerId?: SortOrder
    tenantId?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    paidTotal?: SortOrder
    estimatedTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    paidTotal?: SortOrder
    estimatedTotal?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    internalCode?: SortOrder
    customerId?: SortOrder
    tenantId?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    paidTotal?: SortOrder
    estimatedTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    internalCode?: SortOrder
    customerId?: SortOrder
    tenantId?: SortOrder
    discountVariant?: SortOrder
    discountValue?: SortOrder
    paidTotal?: SortOrder
    estimatedTotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    discountValue?: SortOrder
    paidTotal?: SortOrder
    estimatedTotal?: SortOrder
  }

  export type EnumESaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ESaleStatus | EnumESaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ESaleStatus[] | ListEnumESaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ESaleStatus[] | ListEnumESaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumESaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ESaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumESaleStatusFilter<$PrismaModel>
    _max?: NestedEnumESaleStatusFilter<$PrismaModel>
  }

  export type SaleMovementPaymentListRelationFilter = {
    every?: SaleMovementPaymentWhereInput
    some?: SaleMovementPaymentWhereInput
    none?: SaleMovementPaymentWhereInput
  }

  export type SaleMovementChangeListRelationFilter = {
    every?: SaleMovementChangeWhereInput
    some?: SaleMovementChangeWhereInput
    none?: SaleMovementChangeWhereInput
  }

  export type SaleMovementPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleMovementChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleMovementCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
  }

  export type SaleMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
  }

  export type SaleMovementMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
  }

  export type SaleMovementScalarRelationFilter = {
    is?: SaleMovementWhereInput
    isNot?: SaleMovementWhereInput
  }

  export type SaleMovementPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMovementPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SaleMovementPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMovementPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMovementPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SaleMovementChangeCountOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMovementChangeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SaleMovementChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMovementChangeMinOrderByAggregateInput = {
    id?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMovementChangeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StockLotScalarRelationFilter = {
    is?: StockLotWhereInput
    isNot?: StockLotWhereInput
  }

  export type SaleProductSaleIdProductIdCompoundUniqueInput = {
    saleId: string
    productId: string
  }

  export type SaleProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    stockLotId?: SortOrder
  }

  export type SaleProductAvgOrderByAggregateInput = {
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
  }

  export type SaleProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    stockLotId?: SortOrder
  }

  export type SaleProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleId?: SortOrder
    productId?: SortOrder
    stockLotId?: SortOrder
  }

  export type SaleProductSumOrderByAggregateInput = {
    costPrice?: SortOrder
    salePrice?: SortOrder
    totalQty?: SortOrder
  }

  export type EnumEStockStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.EStockStrategy | EnumEStockStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.EStockStrategy[] | ListEnumEStockStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.EStockStrategy[] | ListEnumEStockStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumEStockStrategyFilter<$PrismaModel> | $Enums.EStockStrategy
  }

  export type StockLotListRelationFilter = {
    every?: StockLotWhereInput
    some?: StockLotWhereInput
    none?: StockLotWhereInput
  }

  export type StockEventListRelationFilter = {
    every?: StockEventWhereInput
    some?: StockEventWhereInput
    none?: StockEventWhereInput
  }

  export type StockLotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockCountOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    productId?: SortOrder
    totalQty?: SortOrder
    availableQty?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    totalQty?: SortOrder
    availableQty?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    productId?: SortOrder
    totalQty?: SortOrder
    availableQty?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    id?: SortOrder
    strategy?: SortOrder
    productId?: SortOrder
    totalQty?: SortOrder
    availableQty?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    totalQty?: SortOrder
    availableQty?: SortOrder
  }

  export type EnumEStockStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EStockStrategy | EnumEStockStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.EStockStrategy[] | ListEnumEStockStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.EStockStrategy[] | ListEnumEStockStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumEStockStrategyWithAggregatesFilter<$PrismaModel> | $Enums.EStockStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEStockStrategyFilter<$PrismaModel>
    _max?: NestedEnumEStockStrategyFilter<$PrismaModel>
  }

  export type EnumEStockEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EStockEventType | EnumEStockEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EStockEventType[] | ListEnumEStockEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EStockEventType[] | ListEnumEStockEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEStockEventTypeFilter<$PrismaModel> | $Enums.EStockEventType
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type StockScalarRelationFilter = {
    is?: StockWhereInput
    isNot?: StockWhereInput
  }

  export type StockEventEntryNullableScalarRelationFilter = {
    is?: StockEventEntryWhereInput | null
    isNot?: StockEventEntryWhereInput | null
  }

  export type StockEventOutputNullableScalarRelationFilter = {
    is?: StockEventOutputWhereInput | null
    isNot?: StockEventOutputWhereInput | null
  }

  export type StockLotNullableScalarRelationFilter = {
    is?: StockLotWhereInput | null
    isNot?: StockLotWhereInput | null
  }

  export type StockEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockLotId?: SortOrder
  }

  export type StockEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockLotId?: SortOrder
  }

  export type StockEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stockLotId?: SortOrder
  }

  export type EnumEStockEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EStockEventType | EnumEStockEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EStockEventType[] | ListEnumEStockEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EStockEventType[] | ListEnumEStockEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEStockEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EStockEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEStockEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEStockEventTypeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StockEventScalarRelationFilter = {
    is?: StockEventWhereInput
    isNot?: StockEventWhereInput
  }

  export type StockEventEntryCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
  }

  export type StockEventEntryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockEventEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
  }

  export type StockEventEntryMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
  }

  export type StockEventEntrySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockEventOutputCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
  }

  export type StockEventOutputAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockEventOutputMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
  }

  export type StockEventOutputMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    description?: SortOrder
  }

  export type StockEventOutputSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockLotCountOrderByAggregateInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    totalQty?: SortOrder
    costPrice?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockLotAvgOrderByAggregateInput = {
    totalQty?: SortOrder
    costPrice?: SortOrder
  }

  export type StockLotMaxOrderByAggregateInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    totalQty?: SortOrder
    costPrice?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockLotMinOrderByAggregateInput = {
    id?: SortOrder
    lotNumber?: SortOrder
    totalQty?: SortOrder
    costPrice?: SortOrder
    stockId?: SortOrder
    tenantId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockLotSumOrderByAggregateInput = {
    totalQty?: SortOrder
    costPrice?: SortOrder
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type StockListRelationFilter = {
    every?: StockWhereInput
    some?: StockWhereInput
    none?: StockWhereInput
  }

  export type UserTenantSettingsListRelationFilter = {
    every?: UserTenantSettingsWhereInput
    some?: UserTenantSettingsWhereInput
    none?: UserTenantSettingsWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTenantSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MembershipScalarRelationFilter = {
    is?: MembershipWhereInput
    isNot?: MembershipWhereInput
  }

  export type TenantMembershipMembershipIdTenantIdCompoundUniqueInput = {
    membershipId: string
    tenantId: string
  }

  export type TenantMembershipCountOrderByAggregateInput = {
    membershipId?: SortOrder
    tenantId?: SortOrder
  }

  export type TenantMembershipMaxOrderByAggregateInput = {
    membershipId?: SortOrder
    tenantId?: SortOrder
  }

  export type TenantMembershipMinOrderByAggregateInput = {
    membershipId?: SortOrder
    tenantId?: SortOrder
  }

  export type MembershipListRelationFilter = {
    every?: MembershipWhereInput
    some?: MembershipWhereInput
    none?: MembershipWhereInput
  }

  export type MembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    firstAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    firstAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    active?: SortOrder
    firstAccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTenantSettingsUserIdTenantIdCompoundUniqueInput = {
    userId: string
    tenantId: string
  }

  export type UserTenantSettingsCountOrderByAggregateInput = {
    doNotDisturb?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
  }

  export type UserTenantSettingsMaxOrderByAggregateInput = {
    doNotDisturb?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
  }

  export type UserTenantSettingsMinOrderByAggregateInput = {
    doNotDisturb?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TenantCreateNestedOneWithoutCustomersInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    connect?: TenantWhereUniqueInput
  }

  export type SaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type PosEventSaleCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PosEventSaleCreateWithoutCustomerInput, PosEventSaleUncheckedCreateWithoutCustomerInput> | PosEventSaleCreateWithoutCustomerInput[] | PosEventSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutCustomerInput | PosEventSaleCreateOrConnectWithoutCustomerInput[]
    createMany?: PosEventSaleCreateManyCustomerInputEnvelope
    connect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type PosEventSaleUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PosEventSaleCreateWithoutCustomerInput, PosEventSaleUncheckedCreateWithoutCustomerInput> | PosEventSaleCreateWithoutCustomerInput[] | PosEventSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutCustomerInput | PosEventSaleCreateOrConnectWithoutCustomerInput[]
    createMany?: PosEventSaleCreateManyCustomerInputEnvelope
    connect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCustomersInput
    upsert?: TenantUpsertWithoutCustomersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCustomersInput, TenantUpdateWithoutCustomersInput>, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type SaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type PosEventSaleUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PosEventSaleCreateWithoutCustomerInput, PosEventSaleUncheckedCreateWithoutCustomerInput> | PosEventSaleCreateWithoutCustomerInput[] | PosEventSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutCustomerInput | PosEventSaleCreateOrConnectWithoutCustomerInput[]
    upsert?: PosEventSaleUpsertWithWhereUniqueWithoutCustomerInput | PosEventSaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PosEventSaleCreateManyCustomerInputEnvelope
    set?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    disconnect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    delete?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    connect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    update?: PosEventSaleUpdateWithWhereUniqueWithoutCustomerInput | PosEventSaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PosEventSaleUpdateManyWithWhereWithoutCustomerInput | PosEventSaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PosEventSaleScalarWhereInput | PosEventSaleScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput> | SaleCreateWithoutCustomerInput[] | SaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutCustomerInput | SaleCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutCustomerInput | SaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleCreateManyCustomerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutCustomerInput | SaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutCustomerInput | SaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type PosEventSaleUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PosEventSaleCreateWithoutCustomerInput, PosEventSaleUncheckedCreateWithoutCustomerInput> | PosEventSaleCreateWithoutCustomerInput[] | PosEventSaleUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutCustomerInput | PosEventSaleCreateOrConnectWithoutCustomerInput[]
    upsert?: PosEventSaleUpsertWithWhereUniqueWithoutCustomerInput | PosEventSaleUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PosEventSaleCreateManyCustomerInputEnvelope
    set?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    disconnect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    delete?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    connect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    update?: PosEventSaleUpdateWithWhereUniqueWithoutCustomerInput | PosEventSaleUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PosEventSaleUpdateManyWithWhereWithoutCustomerInput | PosEventSaleUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PosEventSaleScalarWhereInput | PosEventSaleScalarWhereInput[]
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type MembershipCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantMembershipCreateNestedManyWithoutMembershipInput = {
    create?: XOR<TenantMembershipCreateWithoutMembershipInput, TenantMembershipUncheckedCreateWithoutMembershipInput> | TenantMembershipCreateWithoutMembershipInput[] | TenantMembershipUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: TenantMembershipCreateOrConnectWithoutMembershipInput | TenantMembershipCreateOrConnectWithoutMembershipInput[]
    createMany?: TenantMembershipCreateManyMembershipInputEnvelope
    connect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
  }

  export type TenantMembershipUncheckedCreateNestedManyWithoutMembershipInput = {
    create?: XOR<TenantMembershipCreateWithoutMembershipInput, TenantMembershipUncheckedCreateWithoutMembershipInput> | TenantMembershipCreateWithoutMembershipInput[] | TenantMembershipUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: TenantMembershipCreateOrConnectWithoutMembershipInput | TenantMembershipCreateOrConnectWithoutMembershipInput[]
    createMany?: TenantMembershipCreateManyMembershipInputEnvelope
    connect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
  }

  export type EnumEMembershipRoleFieldUpdateOperationsInput = {
    set?: $Enums.EMembershipRole
  }

  export type MembershipUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type TenantMembershipUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<TenantMembershipCreateWithoutMembershipInput, TenantMembershipUncheckedCreateWithoutMembershipInput> | TenantMembershipCreateWithoutMembershipInput[] | TenantMembershipUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: TenantMembershipCreateOrConnectWithoutMembershipInput | TenantMembershipCreateOrConnectWithoutMembershipInput[]
    upsert?: TenantMembershipUpsertWithWhereUniqueWithoutMembershipInput | TenantMembershipUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: TenantMembershipCreateManyMembershipInputEnvelope
    set?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    disconnect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    delete?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    connect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    update?: TenantMembershipUpdateWithWhereUniqueWithoutMembershipInput | TenantMembershipUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: TenantMembershipUpdateManyWithWhereWithoutMembershipInput | TenantMembershipUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: TenantMembershipScalarWhereInput | TenantMembershipScalarWhereInput[]
  }

  export type TenantMembershipUncheckedUpdateManyWithoutMembershipNestedInput = {
    create?: XOR<TenantMembershipCreateWithoutMembershipInput, TenantMembershipUncheckedCreateWithoutMembershipInput> | TenantMembershipCreateWithoutMembershipInput[] | TenantMembershipUncheckedCreateWithoutMembershipInput[]
    connectOrCreate?: TenantMembershipCreateOrConnectWithoutMembershipInput | TenantMembershipCreateOrConnectWithoutMembershipInput[]
    upsert?: TenantMembershipUpsertWithWhereUniqueWithoutMembershipInput | TenantMembershipUpsertWithWhereUniqueWithoutMembershipInput[]
    createMany?: TenantMembershipCreateManyMembershipInputEnvelope
    set?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    disconnect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    delete?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    connect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    update?: TenantMembershipUpdateWithWhereUniqueWithoutMembershipInput | TenantMembershipUpdateWithWhereUniqueWithoutMembershipInput[]
    updateMany?: TenantMembershipUpdateManyWithWhereWithoutMembershipInput | TenantMembershipUpdateManyWithWhereWithoutMembershipInput[]
    deleteMany?: TenantMembershipScalarWhereInput | TenantMembershipScalarWhereInput[]
  }

  export type NotificationTargetCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationTargetCreateWithoutNotificationInput, NotificationTargetUncheckedCreateWithoutNotificationInput> | NotificationTargetCreateWithoutNotificationInput[] | NotificationTargetUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutNotificationInput | NotificationTargetCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationTargetCreateManyNotificationInputEnvelope
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
  }

  export type NotificationTargetUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationTargetCreateWithoutNotificationInput, NotificationTargetUncheckedCreateWithoutNotificationInput> | NotificationTargetCreateWithoutNotificationInput[] | NotificationTargetUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutNotificationInput | NotificationTargetCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationTargetCreateManyNotificationInputEnvelope
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
  }

  export type EnumENotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ENotificationType
  }

  export type NotificationTargetUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationTargetCreateWithoutNotificationInput, NotificationTargetUncheckedCreateWithoutNotificationInput> | NotificationTargetCreateWithoutNotificationInput[] | NotificationTargetUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutNotificationInput | NotificationTargetCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationTargetUpsertWithWhereUniqueWithoutNotificationInput | NotificationTargetUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationTargetCreateManyNotificationInputEnvelope
    set?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    disconnect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    delete?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    update?: NotificationTargetUpdateWithWhereUniqueWithoutNotificationInput | NotificationTargetUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationTargetUpdateManyWithWhereWithoutNotificationInput | NotificationTargetUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationTargetScalarWhereInput | NotificationTargetScalarWhereInput[]
  }

  export type NotificationTargetUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationTargetCreateWithoutNotificationInput, NotificationTargetUncheckedCreateWithoutNotificationInput> | NotificationTargetCreateWithoutNotificationInput[] | NotificationTargetUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutNotificationInput | NotificationTargetCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationTargetUpsertWithWhereUniqueWithoutNotificationInput | NotificationTargetUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationTargetCreateManyNotificationInputEnvelope
    set?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    disconnect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    delete?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    update?: NotificationTargetUpdateWithWhereUniqueWithoutNotificationInput | NotificationTargetUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationTargetUpdateManyWithWhereWithoutNotificationInput | NotificationTargetUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationTargetScalarWhereInput | NotificationTargetScalarWhereInput[]
  }

  export type NotificationCreateNestedOneWithoutTargetsInput = {
    create?: XOR<NotificationCreateWithoutTargetsInput, NotificationUncheckedCreateWithoutTargetsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutTargetsInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationTargetInput = {
    create?: XOR<UserCreateWithoutNotificationTargetInput, UserUncheckedCreateWithoutNotificationTargetInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationTargetInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutNotificationTargetInput = {
    create?: XOR<TenantCreateWithoutNotificationTargetInput, TenantUncheckedCreateWithoutNotificationTargetInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationTargetInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumENotificationTargetStatusFieldUpdateOperationsInput = {
    set?: $Enums.ENotificationTargetStatus
  }

  export type NotificationUpdateOneRequiredWithoutTargetsNestedInput = {
    create?: XOR<NotificationCreateWithoutTargetsInput, NotificationUncheckedCreateWithoutTargetsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutTargetsInput
    upsert?: NotificationUpsertWithoutTargetsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutTargetsInput, NotificationUpdateWithoutTargetsInput>, NotificationUncheckedUpdateWithoutTargetsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationTargetNestedInput = {
    create?: XOR<UserCreateWithoutNotificationTargetInput, UserUncheckedCreateWithoutNotificationTargetInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationTargetInput
    upsert?: UserUpsertWithoutNotificationTargetInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationTargetInput, UserUpdateWithoutNotificationTargetInput>, UserUncheckedUpdateWithoutNotificationTargetInput>
  }

  export type TenantUpdateOneRequiredWithoutNotificationTargetNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationTargetInput, TenantUncheckedCreateWithoutNotificationTargetInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationTargetInput
    upsert?: TenantUpsertWithoutNotificationTargetInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationTargetInput, TenantUpdateWithoutNotificationTargetInput>, TenantUncheckedUpdateWithoutNotificationTargetInput>
  }

  export type EnumEPosStatusFieldUpdateOperationsInput = {
    set?: $Enums.EPosStatus
  }

  export type PosEventEntryCreateNestedOneWithoutPosEventInput = {
    create?: XOR<PosEventEntryCreateWithoutPosEventInput, PosEventEntryUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventEntryCreateOrConnectWithoutPosEventInput
    connect?: PosEventEntryWhereUniqueInput
  }

  export type PosEventOutputCreateNestedOneWithoutPosEventInput = {
    create?: XOR<PosEventOutputCreateWithoutPosEventInput, PosEventOutputUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventOutputCreateOrConnectWithoutPosEventInput
    connect?: PosEventOutputWhereUniqueInput
  }

  export type PosEventSaleCreateNestedOneWithoutPosEventInput = {
    create?: XOR<PosEventSaleCreateWithoutPosEventInput, PosEventSaleUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutPosEventInput
    connect?: PosEventSaleWhereUniqueInput
  }

  export type PosEventEntryUncheckedCreateNestedOneWithoutPosEventInput = {
    create?: XOR<PosEventEntryCreateWithoutPosEventInput, PosEventEntryUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventEntryCreateOrConnectWithoutPosEventInput
    connect?: PosEventEntryWhereUniqueInput
  }

  export type PosEventOutputUncheckedCreateNestedOneWithoutPosEventInput = {
    create?: XOR<PosEventOutputCreateWithoutPosEventInput, PosEventOutputUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventOutputCreateOrConnectWithoutPosEventInput
    connect?: PosEventOutputWhereUniqueInput
  }

  export type PosEventSaleUncheckedCreateNestedOneWithoutPosEventInput = {
    create?: XOR<PosEventSaleCreateWithoutPosEventInput, PosEventSaleUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutPosEventInput
    connect?: PosEventSaleWhereUniqueInput
  }

  export type EnumEPosEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EPosEventType
  }

  export type EnumEPosEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.EPosEventStatus
  }

  export type PosEventEntryUpdateOneWithoutPosEventNestedInput = {
    create?: XOR<PosEventEntryCreateWithoutPosEventInput, PosEventEntryUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventEntryCreateOrConnectWithoutPosEventInput
    upsert?: PosEventEntryUpsertWithoutPosEventInput
    disconnect?: PosEventEntryWhereInput | boolean
    delete?: PosEventEntryWhereInput | boolean
    connect?: PosEventEntryWhereUniqueInput
    update?: XOR<XOR<PosEventEntryUpdateToOneWithWhereWithoutPosEventInput, PosEventEntryUpdateWithoutPosEventInput>, PosEventEntryUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventOutputUpdateOneWithoutPosEventNestedInput = {
    create?: XOR<PosEventOutputCreateWithoutPosEventInput, PosEventOutputUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventOutputCreateOrConnectWithoutPosEventInput
    upsert?: PosEventOutputUpsertWithoutPosEventInput
    disconnect?: PosEventOutputWhereInput | boolean
    delete?: PosEventOutputWhereInput | boolean
    connect?: PosEventOutputWhereUniqueInput
    update?: XOR<XOR<PosEventOutputUpdateToOneWithWhereWithoutPosEventInput, PosEventOutputUpdateWithoutPosEventInput>, PosEventOutputUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventSaleUpdateOneWithoutPosEventNestedInput = {
    create?: XOR<PosEventSaleCreateWithoutPosEventInput, PosEventSaleUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutPosEventInput
    upsert?: PosEventSaleUpsertWithoutPosEventInput
    disconnect?: PosEventSaleWhereInput | boolean
    delete?: PosEventSaleWhereInput | boolean
    connect?: PosEventSaleWhereUniqueInput
    update?: XOR<XOR<PosEventSaleUpdateToOneWithWhereWithoutPosEventInput, PosEventSaleUpdateWithoutPosEventInput>, PosEventSaleUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventEntryUncheckedUpdateOneWithoutPosEventNestedInput = {
    create?: XOR<PosEventEntryCreateWithoutPosEventInput, PosEventEntryUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventEntryCreateOrConnectWithoutPosEventInput
    upsert?: PosEventEntryUpsertWithoutPosEventInput
    disconnect?: PosEventEntryWhereInput | boolean
    delete?: PosEventEntryWhereInput | boolean
    connect?: PosEventEntryWhereUniqueInput
    update?: XOR<XOR<PosEventEntryUpdateToOneWithWhereWithoutPosEventInput, PosEventEntryUpdateWithoutPosEventInput>, PosEventEntryUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventOutputUncheckedUpdateOneWithoutPosEventNestedInput = {
    create?: XOR<PosEventOutputCreateWithoutPosEventInput, PosEventOutputUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventOutputCreateOrConnectWithoutPosEventInput
    upsert?: PosEventOutputUpsertWithoutPosEventInput
    disconnect?: PosEventOutputWhereInput | boolean
    delete?: PosEventOutputWhereInput | boolean
    connect?: PosEventOutputWhereUniqueInput
    update?: XOR<XOR<PosEventOutputUpdateToOneWithWhereWithoutPosEventInput, PosEventOutputUpdateWithoutPosEventInput>, PosEventOutputUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventSaleUncheckedUpdateOneWithoutPosEventNestedInput = {
    create?: XOR<PosEventSaleCreateWithoutPosEventInput, PosEventSaleUncheckedCreateWithoutPosEventInput>
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutPosEventInput
    upsert?: PosEventSaleUpsertWithoutPosEventInput
    disconnect?: PosEventSaleWhereInput | boolean
    delete?: PosEventSaleWhereInput | boolean
    connect?: PosEventSaleWhereUniqueInput
    update?: XOR<XOR<PosEventSaleUpdateToOneWithWhereWithoutPosEventInput, PosEventSaleUpdateWithoutPosEventInput>, PosEventSaleUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventCreateNestedOneWithoutEntryInput = {
    create?: XOR<PosEventCreateWithoutEntryInput, PosEventUncheckedCreateWithoutEntryInput>
    connectOrCreate?: PosEventCreateOrConnectWithoutEntryInput
    connect?: PosEventWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PosEventUpdateOneRequiredWithoutEntryNestedInput = {
    create?: XOR<PosEventCreateWithoutEntryInput, PosEventUncheckedCreateWithoutEntryInput>
    connectOrCreate?: PosEventCreateOrConnectWithoutEntryInput
    upsert?: PosEventUpsertWithoutEntryInput
    connect?: PosEventWhereUniqueInput
    update?: XOR<XOR<PosEventUpdateToOneWithWhereWithoutEntryInput, PosEventUpdateWithoutEntryInput>, PosEventUncheckedUpdateWithoutEntryInput>
  }

  export type PosEventCreateNestedOneWithoutOutputInput = {
    create?: XOR<PosEventCreateWithoutOutputInput, PosEventUncheckedCreateWithoutOutputInput>
    connectOrCreate?: PosEventCreateOrConnectWithoutOutputInput
    connect?: PosEventWhereUniqueInput
  }

  export type PosEventUpdateOneRequiredWithoutOutputNestedInput = {
    create?: XOR<PosEventCreateWithoutOutputInput, PosEventUncheckedCreateWithoutOutputInput>
    connectOrCreate?: PosEventCreateOrConnectWithoutOutputInput
    upsert?: PosEventUpsertWithoutOutputInput
    connect?: PosEventWhereUniqueInput
    update?: XOR<XOR<PosEventUpdateToOneWithWhereWithoutOutputInput, PosEventUpdateWithoutOutputInput>, PosEventUncheckedUpdateWithoutOutputInput>
  }

  export type SaleCreateNestedOneWithoutPosEventSaleInput = {
    create?: XOR<SaleCreateWithoutPosEventSaleInput, SaleUncheckedCreateWithoutPosEventSaleInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPosEventSaleInput
    connect?: SaleWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutPosEventSalesInput = {
    create?: XOR<CustomerCreateWithoutPosEventSalesInput, CustomerUncheckedCreateWithoutPosEventSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPosEventSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type PosEventCreateNestedOneWithoutSaleInput = {
    create?: XOR<PosEventCreateWithoutSaleInput, PosEventUncheckedCreateWithoutSaleInput>
    connectOrCreate?: PosEventCreateOrConnectWithoutSaleInput
    connect?: PosEventWhereUniqueInput
  }

  export type PosEventSaleProductCreateNestedManyWithoutPosEventSaleInput = {
    create?: XOR<PosEventSaleProductCreateWithoutPosEventSaleInput, PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput> | PosEventSaleProductCreateWithoutPosEventSaleInput[] | PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput[]
    connectOrCreate?: PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput | PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput[]
    createMany?: PosEventSaleProductCreateManyPosEventSaleInputEnvelope
    connect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
  }

  export type PosEventSaleMovementCreateNestedManyWithoutPosEventSaleInput = {
    create?: XOR<PosEventSaleMovementCreateWithoutPosEventSaleInput, PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput> | PosEventSaleMovementCreateWithoutPosEventSaleInput[] | PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput[]
    connectOrCreate?: PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput | PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput[]
    createMany?: PosEventSaleMovementCreateManyPosEventSaleInputEnvelope
    connect?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
  }

  export type PosEventSaleProductUncheckedCreateNestedManyWithoutPosEventSaleInput = {
    create?: XOR<PosEventSaleProductCreateWithoutPosEventSaleInput, PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput> | PosEventSaleProductCreateWithoutPosEventSaleInput[] | PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput[]
    connectOrCreate?: PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput | PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput[]
    createMany?: PosEventSaleProductCreateManyPosEventSaleInputEnvelope
    connect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
  }

  export type PosEventSaleMovementUncheckedCreateNestedManyWithoutPosEventSaleInput = {
    create?: XOR<PosEventSaleMovementCreateWithoutPosEventSaleInput, PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput> | PosEventSaleMovementCreateWithoutPosEventSaleInput[] | PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput[]
    connectOrCreate?: PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput | PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput[]
    createMany?: PosEventSaleMovementCreateManyPosEventSaleInputEnvelope
    connect?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
  }

  export type EnumEDiscountVariantFieldUpdateOperationsInput = {
    set?: $Enums.EDiscountVariant
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SaleUpdateOneRequiredWithoutPosEventSaleNestedInput = {
    create?: XOR<SaleCreateWithoutPosEventSaleInput, SaleUncheckedCreateWithoutPosEventSaleInput>
    connectOrCreate?: SaleCreateOrConnectWithoutPosEventSaleInput
    upsert?: SaleUpsertWithoutPosEventSaleInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutPosEventSaleInput, SaleUpdateWithoutPosEventSaleInput>, SaleUncheckedUpdateWithoutPosEventSaleInput>
  }

  export type CustomerUpdateOneRequiredWithoutPosEventSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutPosEventSalesInput, CustomerUncheckedCreateWithoutPosEventSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPosEventSalesInput
    upsert?: CustomerUpsertWithoutPosEventSalesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPosEventSalesInput, CustomerUpdateWithoutPosEventSalesInput>, CustomerUncheckedUpdateWithoutPosEventSalesInput>
  }

  export type PosEventUpdateOneRequiredWithoutSaleNestedInput = {
    create?: XOR<PosEventCreateWithoutSaleInput, PosEventUncheckedCreateWithoutSaleInput>
    connectOrCreate?: PosEventCreateOrConnectWithoutSaleInput
    upsert?: PosEventUpsertWithoutSaleInput
    connect?: PosEventWhereUniqueInput
    update?: XOR<XOR<PosEventUpdateToOneWithWhereWithoutSaleInput, PosEventUpdateWithoutSaleInput>, PosEventUncheckedUpdateWithoutSaleInput>
  }

  export type PosEventSaleProductUpdateManyWithoutPosEventSaleNestedInput = {
    create?: XOR<PosEventSaleProductCreateWithoutPosEventSaleInput, PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput> | PosEventSaleProductCreateWithoutPosEventSaleInput[] | PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput[]
    connectOrCreate?: PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput | PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput[]
    upsert?: PosEventSaleProductUpsertWithWhereUniqueWithoutPosEventSaleInput | PosEventSaleProductUpsertWithWhereUniqueWithoutPosEventSaleInput[]
    createMany?: PosEventSaleProductCreateManyPosEventSaleInputEnvelope
    set?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    disconnect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    delete?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    connect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    update?: PosEventSaleProductUpdateWithWhereUniqueWithoutPosEventSaleInput | PosEventSaleProductUpdateWithWhereUniqueWithoutPosEventSaleInput[]
    updateMany?: PosEventSaleProductUpdateManyWithWhereWithoutPosEventSaleInput | PosEventSaleProductUpdateManyWithWhereWithoutPosEventSaleInput[]
    deleteMany?: PosEventSaleProductScalarWhereInput | PosEventSaleProductScalarWhereInput[]
  }

  export type PosEventSaleMovementUpdateManyWithoutPosEventSaleNestedInput = {
    create?: XOR<PosEventSaleMovementCreateWithoutPosEventSaleInput, PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput> | PosEventSaleMovementCreateWithoutPosEventSaleInput[] | PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput[]
    connectOrCreate?: PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput | PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput[]
    upsert?: PosEventSaleMovementUpsertWithWhereUniqueWithoutPosEventSaleInput | PosEventSaleMovementUpsertWithWhereUniqueWithoutPosEventSaleInput[]
    createMany?: PosEventSaleMovementCreateManyPosEventSaleInputEnvelope
    set?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
    disconnect?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
    delete?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
    connect?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
    update?: PosEventSaleMovementUpdateWithWhereUniqueWithoutPosEventSaleInput | PosEventSaleMovementUpdateWithWhereUniqueWithoutPosEventSaleInput[]
    updateMany?: PosEventSaleMovementUpdateManyWithWhereWithoutPosEventSaleInput | PosEventSaleMovementUpdateManyWithWhereWithoutPosEventSaleInput[]
    deleteMany?: PosEventSaleMovementScalarWhereInput | PosEventSaleMovementScalarWhereInput[]
  }

  export type PosEventSaleProductUncheckedUpdateManyWithoutPosEventSaleNestedInput = {
    create?: XOR<PosEventSaleProductCreateWithoutPosEventSaleInput, PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput> | PosEventSaleProductCreateWithoutPosEventSaleInput[] | PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput[]
    connectOrCreate?: PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput | PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput[]
    upsert?: PosEventSaleProductUpsertWithWhereUniqueWithoutPosEventSaleInput | PosEventSaleProductUpsertWithWhereUniqueWithoutPosEventSaleInput[]
    createMany?: PosEventSaleProductCreateManyPosEventSaleInputEnvelope
    set?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    disconnect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    delete?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    connect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    update?: PosEventSaleProductUpdateWithWhereUniqueWithoutPosEventSaleInput | PosEventSaleProductUpdateWithWhereUniqueWithoutPosEventSaleInput[]
    updateMany?: PosEventSaleProductUpdateManyWithWhereWithoutPosEventSaleInput | PosEventSaleProductUpdateManyWithWhereWithoutPosEventSaleInput[]
    deleteMany?: PosEventSaleProductScalarWhereInput | PosEventSaleProductScalarWhereInput[]
  }

  export type PosEventSaleMovementUncheckedUpdateManyWithoutPosEventSaleNestedInput = {
    create?: XOR<PosEventSaleMovementCreateWithoutPosEventSaleInput, PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput> | PosEventSaleMovementCreateWithoutPosEventSaleInput[] | PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput[]
    connectOrCreate?: PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput | PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput[]
    upsert?: PosEventSaleMovementUpsertWithWhereUniqueWithoutPosEventSaleInput | PosEventSaleMovementUpsertWithWhereUniqueWithoutPosEventSaleInput[]
    createMany?: PosEventSaleMovementCreateManyPosEventSaleInputEnvelope
    set?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
    disconnect?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
    delete?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
    connect?: PosEventSaleMovementWhereUniqueInput | PosEventSaleMovementWhereUniqueInput[]
    update?: PosEventSaleMovementUpdateWithWhereUniqueWithoutPosEventSaleInput | PosEventSaleMovementUpdateWithWhereUniqueWithoutPosEventSaleInput[]
    updateMany?: PosEventSaleMovementUpdateManyWithWhereWithoutPosEventSaleInput | PosEventSaleMovementUpdateManyWithWhereWithoutPosEventSaleInput[]
    deleteMany?: PosEventSaleMovementScalarWhereInput | PosEventSaleMovementScalarWhereInput[]
  }

  export type PosEventSaleCreateNestedOneWithoutMovementsInput = {
    create?: XOR<PosEventSaleCreateWithoutMovementsInput, PosEventSaleUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutMovementsInput
    connect?: PosEventSaleWhereUniqueInput
  }

  export type PosEventSaleMovementPaymentCreateNestedManyWithoutPosEventSaleMovementInput = {
    create?: XOR<PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput> | PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput[] | PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput[]
    connectOrCreate?: PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput[]
    createMany?: PosEventSaleMovementPaymentCreateManyPosEventSaleMovementInputEnvelope
    connect?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
  }

  export type PosEventSaleMovementChangeCreateNestedManyWithoutPosEventSaleMovementInput = {
    create?: XOR<PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput> | PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput[] | PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput[]
    connectOrCreate?: PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput[]
    createMany?: PosEventSaleMovementChangeCreateManyPosEventSaleMovementInputEnvelope
    connect?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
  }

  export type PosEventSaleMovementPaymentUncheckedCreateNestedManyWithoutPosEventSaleMovementInput = {
    create?: XOR<PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput> | PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput[] | PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput[]
    connectOrCreate?: PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput[]
    createMany?: PosEventSaleMovementPaymentCreateManyPosEventSaleMovementInputEnvelope
    connect?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
  }

  export type PosEventSaleMovementChangeUncheckedCreateNestedManyWithoutPosEventSaleMovementInput = {
    create?: XOR<PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput> | PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput[] | PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput[]
    connectOrCreate?: PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput[]
    createMany?: PosEventSaleMovementChangeCreateManyPosEventSaleMovementInputEnvelope
    connect?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
  }

  export type EnumESaleMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.ESaleMovementType
  }

  export type PosEventSaleUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<PosEventSaleCreateWithoutMovementsInput, PosEventSaleUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutMovementsInput
    upsert?: PosEventSaleUpsertWithoutMovementsInput
    connect?: PosEventSaleWhereUniqueInput
    update?: XOR<XOR<PosEventSaleUpdateToOneWithWhereWithoutMovementsInput, PosEventSaleUpdateWithoutMovementsInput>, PosEventSaleUncheckedUpdateWithoutMovementsInput>
  }

  export type PosEventSaleMovementPaymentUpdateManyWithoutPosEventSaleMovementNestedInput = {
    create?: XOR<PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput> | PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput[] | PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput[]
    connectOrCreate?: PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput[]
    upsert?: PosEventSaleMovementPaymentUpsertWithWhereUniqueWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentUpsertWithWhereUniqueWithoutPosEventSaleMovementInput[]
    createMany?: PosEventSaleMovementPaymentCreateManyPosEventSaleMovementInputEnvelope
    set?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
    disconnect?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
    delete?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
    connect?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
    update?: PosEventSaleMovementPaymentUpdateWithWhereUniqueWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentUpdateWithWhereUniqueWithoutPosEventSaleMovementInput[]
    updateMany?: PosEventSaleMovementPaymentUpdateManyWithWhereWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentUpdateManyWithWhereWithoutPosEventSaleMovementInput[]
    deleteMany?: PosEventSaleMovementPaymentScalarWhereInput | PosEventSaleMovementPaymentScalarWhereInput[]
  }

  export type PosEventSaleMovementChangeUpdateManyWithoutPosEventSaleMovementNestedInput = {
    create?: XOR<PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput> | PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput[] | PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput[]
    connectOrCreate?: PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput[]
    upsert?: PosEventSaleMovementChangeUpsertWithWhereUniqueWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeUpsertWithWhereUniqueWithoutPosEventSaleMovementInput[]
    createMany?: PosEventSaleMovementChangeCreateManyPosEventSaleMovementInputEnvelope
    set?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
    disconnect?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
    delete?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
    connect?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
    update?: PosEventSaleMovementChangeUpdateWithWhereUniqueWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeUpdateWithWhereUniqueWithoutPosEventSaleMovementInput[]
    updateMany?: PosEventSaleMovementChangeUpdateManyWithWhereWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeUpdateManyWithWhereWithoutPosEventSaleMovementInput[]
    deleteMany?: PosEventSaleMovementChangeScalarWhereInput | PosEventSaleMovementChangeScalarWhereInput[]
  }

  export type PosEventSaleMovementPaymentUncheckedUpdateManyWithoutPosEventSaleMovementNestedInput = {
    create?: XOR<PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput> | PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput[] | PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput[]
    connectOrCreate?: PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput[]
    upsert?: PosEventSaleMovementPaymentUpsertWithWhereUniqueWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentUpsertWithWhereUniqueWithoutPosEventSaleMovementInput[]
    createMany?: PosEventSaleMovementPaymentCreateManyPosEventSaleMovementInputEnvelope
    set?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
    disconnect?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
    delete?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
    connect?: PosEventSaleMovementPaymentWhereUniqueInput | PosEventSaleMovementPaymentWhereUniqueInput[]
    update?: PosEventSaleMovementPaymentUpdateWithWhereUniqueWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentUpdateWithWhereUniqueWithoutPosEventSaleMovementInput[]
    updateMany?: PosEventSaleMovementPaymentUpdateManyWithWhereWithoutPosEventSaleMovementInput | PosEventSaleMovementPaymentUpdateManyWithWhereWithoutPosEventSaleMovementInput[]
    deleteMany?: PosEventSaleMovementPaymentScalarWhereInput | PosEventSaleMovementPaymentScalarWhereInput[]
  }

  export type PosEventSaleMovementChangeUncheckedUpdateManyWithoutPosEventSaleMovementNestedInput = {
    create?: XOR<PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput> | PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput[] | PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput[]
    connectOrCreate?: PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput[]
    upsert?: PosEventSaleMovementChangeUpsertWithWhereUniqueWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeUpsertWithWhereUniqueWithoutPosEventSaleMovementInput[]
    createMany?: PosEventSaleMovementChangeCreateManyPosEventSaleMovementInputEnvelope
    set?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
    disconnect?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
    delete?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
    connect?: PosEventSaleMovementChangeWhereUniqueInput | PosEventSaleMovementChangeWhereUniqueInput[]
    update?: PosEventSaleMovementChangeUpdateWithWhereUniqueWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeUpdateWithWhereUniqueWithoutPosEventSaleMovementInput[]
    updateMany?: PosEventSaleMovementChangeUpdateManyWithWhereWithoutPosEventSaleMovementInput | PosEventSaleMovementChangeUpdateManyWithWhereWithoutPosEventSaleMovementInput[]
    deleteMany?: PosEventSaleMovementChangeScalarWhereInput | PosEventSaleMovementChangeScalarWhereInput[]
  }

  export type PosEventSaleMovementCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PosEventSaleMovementCreateWithoutPaymentsInput, PosEventSaleMovementUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PosEventSaleMovementCreateOrConnectWithoutPaymentsInput
    connect?: PosEventSaleMovementWhereUniqueInput
  }

  export type EnumEPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.EPaymentMethod
  }

  export type PosEventSaleMovementUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PosEventSaleMovementCreateWithoutPaymentsInput, PosEventSaleMovementUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PosEventSaleMovementCreateOrConnectWithoutPaymentsInput
    upsert?: PosEventSaleMovementUpsertWithoutPaymentsInput
    connect?: PosEventSaleMovementWhereUniqueInput
    update?: XOR<XOR<PosEventSaleMovementUpdateToOneWithWhereWithoutPaymentsInput, PosEventSaleMovementUpdateWithoutPaymentsInput>, PosEventSaleMovementUncheckedUpdateWithoutPaymentsInput>
  }

  export type PosEventSaleMovementCreateNestedOneWithoutChangesInput = {
    create?: XOR<PosEventSaleMovementCreateWithoutChangesInput, PosEventSaleMovementUncheckedCreateWithoutChangesInput>
    connectOrCreate?: PosEventSaleMovementCreateOrConnectWithoutChangesInput
    connect?: PosEventSaleMovementWhereUniqueInput
  }

  export type PosEventSaleMovementUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<PosEventSaleMovementCreateWithoutChangesInput, PosEventSaleMovementUncheckedCreateWithoutChangesInput>
    connectOrCreate?: PosEventSaleMovementCreateOrConnectWithoutChangesInput
    upsert?: PosEventSaleMovementUpsertWithoutChangesInput
    connect?: PosEventSaleMovementWhereUniqueInput
    update?: XOR<XOR<PosEventSaleMovementUpdateToOneWithWhereWithoutChangesInput, PosEventSaleMovementUpdateWithoutChangesInput>, PosEventSaleMovementUncheckedUpdateWithoutChangesInput>
  }

  export type PosEventSaleCreateNestedOneWithoutProductsInput = {
    create?: XOR<PosEventSaleCreateWithoutProductsInput, PosEventSaleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutProductsInput
    connect?: PosEventSaleWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPosEventSaleProductInput = {
    create?: XOR<ProductCreateWithoutPosEventSaleProductInput, ProductUncheckedCreateWithoutPosEventSaleProductInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPosEventSaleProductInput
    connect?: ProductWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PosEventSaleUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<PosEventSaleCreateWithoutProductsInput, PosEventSaleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutProductsInput
    upsert?: PosEventSaleUpsertWithoutProductsInput
    connect?: PosEventSaleWhereUniqueInput
    update?: XOR<XOR<PosEventSaleUpdateToOneWithWhereWithoutProductsInput, PosEventSaleUpdateWithoutProductsInput>, PosEventSaleUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutPosEventSaleProductNestedInput = {
    create?: XOR<ProductCreateWithoutPosEventSaleProductInput, ProductUncheckedCreateWithoutPosEventSaleProductInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPosEventSaleProductInput
    upsert?: ProductUpsertWithoutPosEventSaleProductInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPosEventSaleProductInput, ProductUpdateWithoutPosEventSaleProductInput>, ProductUncheckedUpdateWithoutPosEventSaleProductInput>
  }

  export type StockCreateNestedOneWithoutProductInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    connect?: StockWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutProductsInput = {
    create?: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductsInput
    connect?: TenantWhereUniqueInput
  }

  export type SaleProductCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type ProductSpecificationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductSpecificationCreateWithoutProductInput, ProductSpecificationUncheckedCreateWithoutProductInput> | ProductSpecificationCreateWithoutProductInput[] | ProductSpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSpecificationCreateOrConnectWithoutProductInput | ProductSpecificationCreateOrConnectWithoutProductInput[]
    createMany?: ProductSpecificationCreateManyProductInputEnvelope
    connect?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
  }

  export type PosEventSaleProductCreateNestedManyWithoutProductInput = {
    create?: XOR<PosEventSaleProductCreateWithoutProductInput, PosEventSaleProductUncheckedCreateWithoutProductInput> | PosEventSaleProductCreateWithoutProductInput[] | PosEventSaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PosEventSaleProductCreateOrConnectWithoutProductInput | PosEventSaleProductCreateOrConnectWithoutProductInput[]
    createMany?: PosEventSaleProductCreateManyProductInputEnvelope
    connect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    connect?: StockWhereUniqueInput
  }

  export type SaleProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type ProductSpecificationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductSpecificationCreateWithoutProductInput, ProductSpecificationUncheckedCreateWithoutProductInput> | ProductSpecificationCreateWithoutProductInput[] | ProductSpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSpecificationCreateOrConnectWithoutProductInput | ProductSpecificationCreateOrConnectWithoutProductInput[]
    createMany?: ProductSpecificationCreateManyProductInputEnvelope
    connect?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
  }

  export type PosEventSaleProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PosEventSaleProductCreateWithoutProductInput, PosEventSaleProductUncheckedCreateWithoutProductInput> | PosEventSaleProductCreateWithoutProductInput[] | PosEventSaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PosEventSaleProductCreateOrConnectWithoutProductInput | PosEventSaleProductCreateOrConnectWithoutProductInput[]
    createMany?: PosEventSaleProductCreateManyProductInputEnvelope
    connect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StockUpdateOneWithoutProductNestedInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    upsert?: StockUpsertWithoutProductInput
    disconnect?: StockWhereInput | boolean
    delete?: StockWhereInput | boolean
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProductInput, StockUpdateWithoutProductInput>, StockUncheckedUpdateWithoutProductInput>
  }

  export type TenantUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProductsInput
    upsert?: TenantUpsertWithoutProductsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutProductsInput, TenantUpdateWithoutProductsInput>, TenantUncheckedUpdateWithoutProductsInput>
  }

  export type SaleProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutProductInput | SaleProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutProductInput | SaleProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutProductInput | SaleProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type ProductSpecificationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductSpecificationCreateWithoutProductInput, ProductSpecificationUncheckedCreateWithoutProductInput> | ProductSpecificationCreateWithoutProductInput[] | ProductSpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSpecificationCreateOrConnectWithoutProductInput | ProductSpecificationCreateOrConnectWithoutProductInput[]
    upsert?: ProductSpecificationUpsertWithWhereUniqueWithoutProductInput | ProductSpecificationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductSpecificationCreateManyProductInputEnvelope
    set?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
    disconnect?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
    delete?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
    connect?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
    update?: ProductSpecificationUpdateWithWhereUniqueWithoutProductInput | ProductSpecificationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductSpecificationUpdateManyWithWhereWithoutProductInput | ProductSpecificationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductSpecificationScalarWhereInput | ProductSpecificationScalarWhereInput[]
  }

  export type PosEventSaleProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<PosEventSaleProductCreateWithoutProductInput, PosEventSaleProductUncheckedCreateWithoutProductInput> | PosEventSaleProductCreateWithoutProductInput[] | PosEventSaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PosEventSaleProductCreateOrConnectWithoutProductInput | PosEventSaleProductCreateOrConnectWithoutProductInput[]
    upsert?: PosEventSaleProductUpsertWithWhereUniqueWithoutProductInput | PosEventSaleProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PosEventSaleProductCreateManyProductInputEnvelope
    set?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    disconnect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    delete?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    connect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    update?: PosEventSaleProductUpdateWithWhereUniqueWithoutProductInput | PosEventSaleProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PosEventSaleProductUpdateManyWithWhereWithoutProductInput | PosEventSaleProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PosEventSaleProductScalarWhereInput | PosEventSaleProductScalarWhereInput[]
  }

  export type StockUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    connectOrCreate?: StockCreateOrConnectWithoutProductInput
    upsert?: StockUpsertWithoutProductInput
    disconnect?: StockWhereInput | boolean
    delete?: StockWhereInput | boolean
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutProductInput, StockUpdateWithoutProductInput>, StockUncheckedUpdateWithoutProductInput>
  }

  export type SaleProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput> | SaleProductCreateWithoutProductInput[] | SaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutProductInput | SaleProductCreateOrConnectWithoutProductInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutProductInput | SaleProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleProductCreateManyProductInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutProductInput | SaleProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutProductInput | SaleProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type ProductSpecificationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductSpecificationCreateWithoutProductInput, ProductSpecificationUncheckedCreateWithoutProductInput> | ProductSpecificationCreateWithoutProductInput[] | ProductSpecificationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductSpecificationCreateOrConnectWithoutProductInput | ProductSpecificationCreateOrConnectWithoutProductInput[]
    upsert?: ProductSpecificationUpsertWithWhereUniqueWithoutProductInput | ProductSpecificationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductSpecificationCreateManyProductInputEnvelope
    set?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
    disconnect?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
    delete?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
    connect?: ProductSpecificationWhereUniqueInput | ProductSpecificationWhereUniqueInput[]
    update?: ProductSpecificationUpdateWithWhereUniqueWithoutProductInput | ProductSpecificationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductSpecificationUpdateManyWithWhereWithoutProductInput | ProductSpecificationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductSpecificationScalarWhereInput | ProductSpecificationScalarWhereInput[]
  }

  export type PosEventSaleProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PosEventSaleProductCreateWithoutProductInput, PosEventSaleProductUncheckedCreateWithoutProductInput> | PosEventSaleProductCreateWithoutProductInput[] | PosEventSaleProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PosEventSaleProductCreateOrConnectWithoutProductInput | PosEventSaleProductCreateOrConnectWithoutProductInput[]
    upsert?: PosEventSaleProductUpsertWithWhereUniqueWithoutProductInput | PosEventSaleProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PosEventSaleProductCreateManyProductInputEnvelope
    set?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    disconnect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    delete?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    connect?: PosEventSaleProductWhereUniqueInput | PosEventSaleProductWhereUniqueInput[]
    update?: PosEventSaleProductUpdateWithWhereUniqueWithoutProductInput | PosEventSaleProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PosEventSaleProductUpdateManyWithWhereWithoutProductInput | PosEventSaleProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PosEventSaleProductScalarWhereInput | PosEventSaleProductScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutSpecificationsInput = {
    create?: XOR<ProductCreateWithoutSpecificationsInput, ProductUncheckedCreateWithoutSpecificationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSpecificationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutSpecificationsNestedInput = {
    create?: XOR<ProductCreateWithoutSpecificationsInput, ProductUncheckedCreateWithoutSpecificationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSpecificationsInput
    upsert?: ProductUpsertWithoutSpecificationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSpecificationsInput, ProductUpdateWithoutSpecificationsInput>, ProductUncheckedUpdateWithoutSpecificationsInput>
  }

  export type SaleProductCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type SaleMovementCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleMovementCreateWithoutSaleInput, SaleMovementUncheckedCreateWithoutSaleInput> | SaleMovementCreateWithoutSaleInput[] | SaleMovementUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleMovementCreateOrConnectWithoutSaleInput | SaleMovementCreateOrConnectWithoutSaleInput[]
    createMany?: SaleMovementCreateManySaleInputEnvelope
    connect?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutSalesInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    connect?: CustomerWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutSalesInput = {
    create?: XOR<TenantCreateWithoutSalesInput, TenantUncheckedCreateWithoutSalesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSalesInput
    connect?: TenantWhereUniqueInput
  }

  export type PosEventSaleCreateNestedManyWithoutSaleInput = {
    create?: XOR<PosEventSaleCreateWithoutSaleInput, PosEventSaleUncheckedCreateWithoutSaleInput> | PosEventSaleCreateWithoutSaleInput[] | PosEventSaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutSaleInput | PosEventSaleCreateOrConnectWithoutSaleInput[]
    createMany?: PosEventSaleCreateManySaleInputEnvelope
    connect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
  }

  export type SaleProductUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type SaleMovementUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<SaleMovementCreateWithoutSaleInput, SaleMovementUncheckedCreateWithoutSaleInput> | SaleMovementCreateWithoutSaleInput[] | SaleMovementUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleMovementCreateOrConnectWithoutSaleInput | SaleMovementCreateOrConnectWithoutSaleInput[]
    createMany?: SaleMovementCreateManySaleInputEnvelope
    connect?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
  }

  export type PosEventSaleUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<PosEventSaleCreateWithoutSaleInput, PosEventSaleUncheckedCreateWithoutSaleInput> | PosEventSaleCreateWithoutSaleInput[] | PosEventSaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutSaleInput | PosEventSaleCreateOrConnectWithoutSaleInput[]
    createMany?: PosEventSaleCreateManySaleInputEnvelope
    connect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
  }

  export type EnumESaleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ESaleStatus
  }

  export type SaleProductUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutSaleInput | SaleProductUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutSaleInput | SaleProductUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutSaleInput | SaleProductUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type SaleMovementUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleMovementCreateWithoutSaleInput, SaleMovementUncheckedCreateWithoutSaleInput> | SaleMovementCreateWithoutSaleInput[] | SaleMovementUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleMovementCreateOrConnectWithoutSaleInput | SaleMovementCreateOrConnectWithoutSaleInput[]
    upsert?: SaleMovementUpsertWithWhereUniqueWithoutSaleInput | SaleMovementUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleMovementCreateManySaleInputEnvelope
    set?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
    disconnect?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
    delete?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
    connect?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
    update?: SaleMovementUpdateWithWhereUniqueWithoutSaleInput | SaleMovementUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleMovementUpdateManyWithWhereWithoutSaleInput | SaleMovementUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleMovementScalarWhereInput | SaleMovementScalarWhereInput[]
  }

  export type CustomerUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSalesInput
    upsert?: CustomerUpsertWithoutSalesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSalesInput, CustomerUpdateWithoutSalesInput>, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type TenantUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<TenantCreateWithoutSalesInput, TenantUncheckedCreateWithoutSalesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSalesInput
    upsert?: TenantUpsertWithoutSalesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSalesInput, TenantUpdateWithoutSalesInput>, TenantUncheckedUpdateWithoutSalesInput>
  }

  export type PosEventSaleUpdateManyWithoutSaleNestedInput = {
    create?: XOR<PosEventSaleCreateWithoutSaleInput, PosEventSaleUncheckedCreateWithoutSaleInput> | PosEventSaleCreateWithoutSaleInput[] | PosEventSaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutSaleInput | PosEventSaleCreateOrConnectWithoutSaleInput[]
    upsert?: PosEventSaleUpsertWithWhereUniqueWithoutSaleInput | PosEventSaleUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: PosEventSaleCreateManySaleInputEnvelope
    set?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    disconnect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    delete?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    connect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    update?: PosEventSaleUpdateWithWhereUniqueWithoutSaleInput | PosEventSaleUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: PosEventSaleUpdateManyWithWhereWithoutSaleInput | PosEventSaleUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: PosEventSaleScalarWhereInput | PosEventSaleScalarWhereInput[]
  }

  export type SaleProductUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput> | SaleProductCreateWithoutSaleInput[] | SaleProductUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutSaleInput | SaleProductCreateOrConnectWithoutSaleInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutSaleInput | SaleProductUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleProductCreateManySaleInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutSaleInput | SaleProductUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutSaleInput | SaleProductUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type SaleMovementUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<SaleMovementCreateWithoutSaleInput, SaleMovementUncheckedCreateWithoutSaleInput> | SaleMovementCreateWithoutSaleInput[] | SaleMovementUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: SaleMovementCreateOrConnectWithoutSaleInput | SaleMovementCreateOrConnectWithoutSaleInput[]
    upsert?: SaleMovementUpsertWithWhereUniqueWithoutSaleInput | SaleMovementUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: SaleMovementCreateManySaleInputEnvelope
    set?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
    disconnect?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
    delete?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
    connect?: SaleMovementWhereUniqueInput | SaleMovementWhereUniqueInput[]
    update?: SaleMovementUpdateWithWhereUniqueWithoutSaleInput | SaleMovementUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: SaleMovementUpdateManyWithWhereWithoutSaleInput | SaleMovementUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: SaleMovementScalarWhereInput | SaleMovementScalarWhereInput[]
  }

  export type PosEventSaleUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<PosEventSaleCreateWithoutSaleInput, PosEventSaleUncheckedCreateWithoutSaleInput> | PosEventSaleCreateWithoutSaleInput[] | PosEventSaleUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: PosEventSaleCreateOrConnectWithoutSaleInput | PosEventSaleCreateOrConnectWithoutSaleInput[]
    upsert?: PosEventSaleUpsertWithWhereUniqueWithoutSaleInput | PosEventSaleUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: PosEventSaleCreateManySaleInputEnvelope
    set?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    disconnect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    delete?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    connect?: PosEventSaleWhereUniqueInput | PosEventSaleWhereUniqueInput[]
    update?: PosEventSaleUpdateWithWhereUniqueWithoutSaleInput | PosEventSaleUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: PosEventSaleUpdateManyWithWhereWithoutSaleInput | PosEventSaleUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: PosEventSaleScalarWhereInput | PosEventSaleScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutMovementsInput = {
    create?: XOR<SaleCreateWithoutMovementsInput, SaleUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutMovementsInput
    connect?: SaleWhereUniqueInput
  }

  export type SaleMovementPaymentCreateNestedManyWithoutSaleMovementInput = {
    create?: XOR<SaleMovementPaymentCreateWithoutSaleMovementInput, SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput> | SaleMovementPaymentCreateWithoutSaleMovementInput[] | SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput[]
    connectOrCreate?: SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput | SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput[]
    createMany?: SaleMovementPaymentCreateManySaleMovementInputEnvelope
    connect?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
  }

  export type SaleMovementChangeCreateNestedManyWithoutSaleMovementInput = {
    create?: XOR<SaleMovementChangeCreateWithoutSaleMovementInput, SaleMovementChangeUncheckedCreateWithoutSaleMovementInput> | SaleMovementChangeCreateWithoutSaleMovementInput[] | SaleMovementChangeUncheckedCreateWithoutSaleMovementInput[]
    connectOrCreate?: SaleMovementChangeCreateOrConnectWithoutSaleMovementInput | SaleMovementChangeCreateOrConnectWithoutSaleMovementInput[]
    createMany?: SaleMovementChangeCreateManySaleMovementInputEnvelope
    connect?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
  }

  export type SaleMovementPaymentUncheckedCreateNestedManyWithoutSaleMovementInput = {
    create?: XOR<SaleMovementPaymentCreateWithoutSaleMovementInput, SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput> | SaleMovementPaymentCreateWithoutSaleMovementInput[] | SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput[]
    connectOrCreate?: SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput | SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput[]
    createMany?: SaleMovementPaymentCreateManySaleMovementInputEnvelope
    connect?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
  }

  export type SaleMovementChangeUncheckedCreateNestedManyWithoutSaleMovementInput = {
    create?: XOR<SaleMovementChangeCreateWithoutSaleMovementInput, SaleMovementChangeUncheckedCreateWithoutSaleMovementInput> | SaleMovementChangeCreateWithoutSaleMovementInput[] | SaleMovementChangeUncheckedCreateWithoutSaleMovementInput[]
    connectOrCreate?: SaleMovementChangeCreateOrConnectWithoutSaleMovementInput | SaleMovementChangeCreateOrConnectWithoutSaleMovementInput[]
    createMany?: SaleMovementChangeCreateManySaleMovementInputEnvelope
    connect?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
  }

  export type SaleUpdateOneRequiredWithoutMovementsNestedInput = {
    create?: XOR<SaleCreateWithoutMovementsInput, SaleUncheckedCreateWithoutMovementsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutMovementsInput
    upsert?: SaleUpsertWithoutMovementsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutMovementsInput, SaleUpdateWithoutMovementsInput>, SaleUncheckedUpdateWithoutMovementsInput>
  }

  export type SaleMovementPaymentUpdateManyWithoutSaleMovementNestedInput = {
    create?: XOR<SaleMovementPaymentCreateWithoutSaleMovementInput, SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput> | SaleMovementPaymentCreateWithoutSaleMovementInput[] | SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput[]
    connectOrCreate?: SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput | SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput[]
    upsert?: SaleMovementPaymentUpsertWithWhereUniqueWithoutSaleMovementInput | SaleMovementPaymentUpsertWithWhereUniqueWithoutSaleMovementInput[]
    createMany?: SaleMovementPaymentCreateManySaleMovementInputEnvelope
    set?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
    disconnect?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
    delete?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
    connect?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
    update?: SaleMovementPaymentUpdateWithWhereUniqueWithoutSaleMovementInput | SaleMovementPaymentUpdateWithWhereUniqueWithoutSaleMovementInput[]
    updateMany?: SaleMovementPaymentUpdateManyWithWhereWithoutSaleMovementInput | SaleMovementPaymentUpdateManyWithWhereWithoutSaleMovementInput[]
    deleteMany?: SaleMovementPaymentScalarWhereInput | SaleMovementPaymentScalarWhereInput[]
  }

  export type SaleMovementChangeUpdateManyWithoutSaleMovementNestedInput = {
    create?: XOR<SaleMovementChangeCreateWithoutSaleMovementInput, SaleMovementChangeUncheckedCreateWithoutSaleMovementInput> | SaleMovementChangeCreateWithoutSaleMovementInput[] | SaleMovementChangeUncheckedCreateWithoutSaleMovementInput[]
    connectOrCreate?: SaleMovementChangeCreateOrConnectWithoutSaleMovementInput | SaleMovementChangeCreateOrConnectWithoutSaleMovementInput[]
    upsert?: SaleMovementChangeUpsertWithWhereUniqueWithoutSaleMovementInput | SaleMovementChangeUpsertWithWhereUniqueWithoutSaleMovementInput[]
    createMany?: SaleMovementChangeCreateManySaleMovementInputEnvelope
    set?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
    disconnect?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
    delete?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
    connect?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
    update?: SaleMovementChangeUpdateWithWhereUniqueWithoutSaleMovementInput | SaleMovementChangeUpdateWithWhereUniqueWithoutSaleMovementInput[]
    updateMany?: SaleMovementChangeUpdateManyWithWhereWithoutSaleMovementInput | SaleMovementChangeUpdateManyWithWhereWithoutSaleMovementInput[]
    deleteMany?: SaleMovementChangeScalarWhereInput | SaleMovementChangeScalarWhereInput[]
  }

  export type SaleMovementPaymentUncheckedUpdateManyWithoutSaleMovementNestedInput = {
    create?: XOR<SaleMovementPaymentCreateWithoutSaleMovementInput, SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput> | SaleMovementPaymentCreateWithoutSaleMovementInput[] | SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput[]
    connectOrCreate?: SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput | SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput[]
    upsert?: SaleMovementPaymentUpsertWithWhereUniqueWithoutSaleMovementInput | SaleMovementPaymentUpsertWithWhereUniqueWithoutSaleMovementInput[]
    createMany?: SaleMovementPaymentCreateManySaleMovementInputEnvelope
    set?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
    disconnect?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
    delete?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
    connect?: SaleMovementPaymentWhereUniqueInput | SaleMovementPaymentWhereUniqueInput[]
    update?: SaleMovementPaymentUpdateWithWhereUniqueWithoutSaleMovementInput | SaleMovementPaymentUpdateWithWhereUniqueWithoutSaleMovementInput[]
    updateMany?: SaleMovementPaymentUpdateManyWithWhereWithoutSaleMovementInput | SaleMovementPaymentUpdateManyWithWhereWithoutSaleMovementInput[]
    deleteMany?: SaleMovementPaymentScalarWhereInput | SaleMovementPaymentScalarWhereInput[]
  }

  export type SaleMovementChangeUncheckedUpdateManyWithoutSaleMovementNestedInput = {
    create?: XOR<SaleMovementChangeCreateWithoutSaleMovementInput, SaleMovementChangeUncheckedCreateWithoutSaleMovementInput> | SaleMovementChangeCreateWithoutSaleMovementInput[] | SaleMovementChangeUncheckedCreateWithoutSaleMovementInput[]
    connectOrCreate?: SaleMovementChangeCreateOrConnectWithoutSaleMovementInput | SaleMovementChangeCreateOrConnectWithoutSaleMovementInput[]
    upsert?: SaleMovementChangeUpsertWithWhereUniqueWithoutSaleMovementInput | SaleMovementChangeUpsertWithWhereUniqueWithoutSaleMovementInput[]
    createMany?: SaleMovementChangeCreateManySaleMovementInputEnvelope
    set?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
    disconnect?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
    delete?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
    connect?: SaleMovementChangeWhereUniqueInput | SaleMovementChangeWhereUniqueInput[]
    update?: SaleMovementChangeUpdateWithWhereUniqueWithoutSaleMovementInput | SaleMovementChangeUpdateWithWhereUniqueWithoutSaleMovementInput[]
    updateMany?: SaleMovementChangeUpdateManyWithWhereWithoutSaleMovementInput | SaleMovementChangeUpdateManyWithWhereWithoutSaleMovementInput[]
    deleteMany?: SaleMovementChangeScalarWhereInput | SaleMovementChangeScalarWhereInput[]
  }

  export type SaleMovementCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SaleMovementCreateWithoutPaymentsInput, SaleMovementUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleMovementCreateOrConnectWithoutPaymentsInput
    connect?: SaleMovementWhereUniqueInput
  }

  export type SaleMovementUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SaleMovementCreateWithoutPaymentsInput, SaleMovementUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleMovementCreateOrConnectWithoutPaymentsInput
    upsert?: SaleMovementUpsertWithoutPaymentsInput
    connect?: SaleMovementWhereUniqueInput
    update?: XOR<XOR<SaleMovementUpdateToOneWithWhereWithoutPaymentsInput, SaleMovementUpdateWithoutPaymentsInput>, SaleMovementUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleMovementCreateNestedOneWithoutChangesInput = {
    create?: XOR<SaleMovementCreateWithoutChangesInput, SaleMovementUncheckedCreateWithoutChangesInput>
    connectOrCreate?: SaleMovementCreateOrConnectWithoutChangesInput
    connect?: SaleMovementWhereUniqueInput
  }

  export type SaleMovementUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<SaleMovementCreateWithoutChangesInput, SaleMovementUncheckedCreateWithoutChangesInput>
    connectOrCreate?: SaleMovementCreateOrConnectWithoutChangesInput
    upsert?: SaleMovementUpsertWithoutChangesInput
    connect?: SaleMovementWhereUniqueInput
    update?: XOR<XOR<SaleMovementUpdateToOneWithWhereWithoutChangesInput, SaleMovementUpdateWithoutChangesInput>, SaleMovementUncheckedUpdateWithoutChangesInput>
  }

  export type SaleCreateNestedOneWithoutProductsInput = {
    create?: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutProductsInput
    connect?: SaleWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSaleProductsInput = {
    create?: XOR<ProductCreateWithoutSaleProductsInput, ProductUncheckedCreateWithoutSaleProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type StockLotCreateNestedOneWithoutSaleProductInput = {
    create?: XOR<StockLotCreateWithoutSaleProductInput, StockLotUncheckedCreateWithoutSaleProductInput>
    connectOrCreate?: StockLotCreateOrConnectWithoutSaleProductInput
    connect?: StockLotWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    connectOrCreate?: SaleCreateOrConnectWithoutProductsInput
    upsert?: SaleUpsertWithoutProductsInput
    connect?: SaleWhereUniqueInput
    update?: XOR<XOR<SaleUpdateToOneWithWhereWithoutProductsInput, SaleUpdateWithoutProductsInput>, SaleUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutSaleProductsNestedInput = {
    create?: XOR<ProductCreateWithoutSaleProductsInput, ProductUncheckedCreateWithoutSaleProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSaleProductsInput
    upsert?: ProductUpsertWithoutSaleProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSaleProductsInput, ProductUpdateWithoutSaleProductsInput>, ProductUncheckedUpdateWithoutSaleProductsInput>
  }

  export type StockLotUpdateOneRequiredWithoutSaleProductNestedInput = {
    create?: XOR<StockLotCreateWithoutSaleProductInput, StockLotUncheckedCreateWithoutSaleProductInput>
    connectOrCreate?: StockLotCreateOrConnectWithoutSaleProductInput
    upsert?: StockLotUpsertWithoutSaleProductInput
    connect?: StockLotWhereUniqueInput
    update?: XOR<XOR<StockLotUpdateToOneWithWhereWithoutSaleProductInput, StockLotUpdateWithoutSaleProductInput>, StockLotUncheckedUpdateWithoutSaleProductInput>
  }

  export type TenantCreateNestedOneWithoutStocksInput = {
    create?: XOR<TenantCreateWithoutStocksInput, TenantUncheckedCreateWithoutStocksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStocksInput
    connect?: TenantWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutStockInput = {
    create?: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockInput
    connect?: ProductWhereUniqueInput
  }

  export type StockLotCreateNestedManyWithoutStockInput = {
    create?: XOR<StockLotCreateWithoutStockInput, StockLotUncheckedCreateWithoutStockInput> | StockLotCreateWithoutStockInput[] | StockLotUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockLotCreateOrConnectWithoutStockInput | StockLotCreateOrConnectWithoutStockInput[]
    createMany?: StockLotCreateManyStockInputEnvelope
    connect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
  }

  export type StockEventCreateNestedManyWithoutStockInput = {
    create?: XOR<StockEventCreateWithoutStockInput, StockEventUncheckedCreateWithoutStockInput> | StockEventCreateWithoutStockInput[] | StockEventUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutStockInput | StockEventCreateOrConnectWithoutStockInput[]
    createMany?: StockEventCreateManyStockInputEnvelope
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
  }

  export type StockLotUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<StockLotCreateWithoutStockInput, StockLotUncheckedCreateWithoutStockInput> | StockLotCreateWithoutStockInput[] | StockLotUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockLotCreateOrConnectWithoutStockInput | StockLotCreateOrConnectWithoutStockInput[]
    createMany?: StockLotCreateManyStockInputEnvelope
    connect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
  }

  export type StockEventUncheckedCreateNestedManyWithoutStockInput = {
    create?: XOR<StockEventCreateWithoutStockInput, StockEventUncheckedCreateWithoutStockInput> | StockEventCreateWithoutStockInput[] | StockEventUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutStockInput | StockEventCreateOrConnectWithoutStockInput[]
    createMany?: StockEventCreateManyStockInputEnvelope
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
  }

  export type EnumEStockStrategyFieldUpdateOperationsInput = {
    set?: $Enums.EStockStrategy
  }

  export type TenantUpdateOneRequiredWithoutStocksNestedInput = {
    create?: XOR<TenantCreateWithoutStocksInput, TenantUncheckedCreateWithoutStocksInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStocksInput
    upsert?: TenantUpsertWithoutStocksInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStocksInput, TenantUpdateWithoutStocksInput>, TenantUncheckedUpdateWithoutStocksInput>
  }

  export type ProductUpdateOneRequiredWithoutStockNestedInput = {
    create?: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStockInput
    upsert?: ProductUpsertWithoutStockInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStockInput, ProductUpdateWithoutStockInput>, ProductUncheckedUpdateWithoutStockInput>
  }

  export type StockLotUpdateManyWithoutStockNestedInput = {
    create?: XOR<StockLotCreateWithoutStockInput, StockLotUncheckedCreateWithoutStockInput> | StockLotCreateWithoutStockInput[] | StockLotUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockLotCreateOrConnectWithoutStockInput | StockLotCreateOrConnectWithoutStockInput[]
    upsert?: StockLotUpsertWithWhereUniqueWithoutStockInput | StockLotUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: StockLotCreateManyStockInputEnvelope
    set?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    disconnect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    delete?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    connect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    update?: StockLotUpdateWithWhereUniqueWithoutStockInput | StockLotUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: StockLotUpdateManyWithWhereWithoutStockInput | StockLotUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: StockLotScalarWhereInput | StockLotScalarWhereInput[]
  }

  export type StockEventUpdateManyWithoutStockNestedInput = {
    create?: XOR<StockEventCreateWithoutStockInput, StockEventUncheckedCreateWithoutStockInput> | StockEventCreateWithoutStockInput[] | StockEventUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutStockInput | StockEventCreateOrConnectWithoutStockInput[]
    upsert?: StockEventUpsertWithWhereUniqueWithoutStockInput | StockEventUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: StockEventCreateManyStockInputEnvelope
    set?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    disconnect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    delete?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    update?: StockEventUpdateWithWhereUniqueWithoutStockInput | StockEventUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: StockEventUpdateManyWithWhereWithoutStockInput | StockEventUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: StockEventScalarWhereInput | StockEventScalarWhereInput[]
  }

  export type StockLotUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<StockLotCreateWithoutStockInput, StockLotUncheckedCreateWithoutStockInput> | StockLotCreateWithoutStockInput[] | StockLotUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockLotCreateOrConnectWithoutStockInput | StockLotCreateOrConnectWithoutStockInput[]
    upsert?: StockLotUpsertWithWhereUniqueWithoutStockInput | StockLotUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: StockLotCreateManyStockInputEnvelope
    set?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    disconnect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    delete?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    connect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    update?: StockLotUpdateWithWhereUniqueWithoutStockInput | StockLotUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: StockLotUpdateManyWithWhereWithoutStockInput | StockLotUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: StockLotScalarWhereInput | StockLotScalarWhereInput[]
  }

  export type StockEventUncheckedUpdateManyWithoutStockNestedInput = {
    create?: XOR<StockEventCreateWithoutStockInput, StockEventUncheckedCreateWithoutStockInput> | StockEventCreateWithoutStockInput[] | StockEventUncheckedCreateWithoutStockInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutStockInput | StockEventCreateOrConnectWithoutStockInput[]
    upsert?: StockEventUpsertWithWhereUniqueWithoutStockInput | StockEventUpsertWithWhereUniqueWithoutStockInput[]
    createMany?: StockEventCreateManyStockInputEnvelope
    set?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    disconnect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    delete?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    update?: StockEventUpdateWithWhereUniqueWithoutStockInput | StockEventUpdateWithWhereUniqueWithoutStockInput[]
    updateMany?: StockEventUpdateManyWithWhereWithoutStockInput | StockEventUpdateManyWithWhereWithoutStockInput[]
    deleteMany?: StockEventScalarWhereInput | StockEventScalarWhereInput[]
  }

  export type StockCreateNestedOneWithoutStockEventInput = {
    create?: XOR<StockCreateWithoutStockEventInput, StockUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockCreateOrConnectWithoutStockEventInput
    connect?: StockWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutStockEventInput = {
    create?: XOR<TenantCreateWithoutStockEventInput, TenantUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockEventInput
    connect?: TenantWhereUniqueInput
  }

  export type StockEventEntryCreateNestedOneWithoutStockEventInput = {
    create?: XOR<StockEventEntryCreateWithoutStockEventInput, StockEventEntryUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockEventEntryCreateOrConnectWithoutStockEventInput
    connect?: StockEventEntryWhereUniqueInput
  }

  export type StockEventOutputCreateNestedOneWithoutStockEventInput = {
    create?: XOR<StockEventOutputCreateWithoutStockEventInput, StockEventOutputUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockEventOutputCreateOrConnectWithoutStockEventInput
    connect?: StockEventOutputWhereUniqueInput
  }

  export type StockLotCreateNestedOneWithoutStockEventsInput = {
    create?: XOR<StockLotCreateWithoutStockEventsInput, StockLotUncheckedCreateWithoutStockEventsInput>
    connectOrCreate?: StockLotCreateOrConnectWithoutStockEventsInput
    connect?: StockLotWhereUniqueInput
  }

  export type StockEventEntryUncheckedCreateNestedOneWithoutStockEventInput = {
    create?: XOR<StockEventEntryCreateWithoutStockEventInput, StockEventEntryUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockEventEntryCreateOrConnectWithoutStockEventInput
    connect?: StockEventEntryWhereUniqueInput
  }

  export type StockEventOutputUncheckedCreateNestedOneWithoutStockEventInput = {
    create?: XOR<StockEventOutputCreateWithoutStockEventInput, StockEventOutputUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockEventOutputCreateOrConnectWithoutStockEventInput
    connect?: StockEventOutputWhereUniqueInput
  }

  export type EnumEStockEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EStockEventType
  }

  export type StockUpdateOneRequiredWithoutStockEventNestedInput = {
    create?: XOR<StockCreateWithoutStockEventInput, StockUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockCreateOrConnectWithoutStockEventInput
    upsert?: StockUpsertWithoutStockEventInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutStockEventInput, StockUpdateWithoutStockEventInput>, StockUncheckedUpdateWithoutStockEventInput>
  }

  export type TenantUpdateOneRequiredWithoutStockEventNestedInput = {
    create?: XOR<TenantCreateWithoutStockEventInput, TenantUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockEventInput
    upsert?: TenantUpsertWithoutStockEventInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStockEventInput, TenantUpdateWithoutStockEventInput>, TenantUncheckedUpdateWithoutStockEventInput>
  }

  export type StockEventEntryUpdateOneWithoutStockEventNestedInput = {
    create?: XOR<StockEventEntryCreateWithoutStockEventInput, StockEventEntryUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockEventEntryCreateOrConnectWithoutStockEventInput
    upsert?: StockEventEntryUpsertWithoutStockEventInput
    disconnect?: StockEventEntryWhereInput | boolean
    delete?: StockEventEntryWhereInput | boolean
    connect?: StockEventEntryWhereUniqueInput
    update?: XOR<XOR<StockEventEntryUpdateToOneWithWhereWithoutStockEventInput, StockEventEntryUpdateWithoutStockEventInput>, StockEventEntryUncheckedUpdateWithoutStockEventInput>
  }

  export type StockEventOutputUpdateOneWithoutStockEventNestedInput = {
    create?: XOR<StockEventOutputCreateWithoutStockEventInput, StockEventOutputUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockEventOutputCreateOrConnectWithoutStockEventInput
    upsert?: StockEventOutputUpsertWithoutStockEventInput
    disconnect?: StockEventOutputWhereInput | boolean
    delete?: StockEventOutputWhereInput | boolean
    connect?: StockEventOutputWhereUniqueInput
    update?: XOR<XOR<StockEventOutputUpdateToOneWithWhereWithoutStockEventInput, StockEventOutputUpdateWithoutStockEventInput>, StockEventOutputUncheckedUpdateWithoutStockEventInput>
  }

  export type StockLotUpdateOneWithoutStockEventsNestedInput = {
    create?: XOR<StockLotCreateWithoutStockEventsInput, StockLotUncheckedCreateWithoutStockEventsInput>
    connectOrCreate?: StockLotCreateOrConnectWithoutStockEventsInput
    upsert?: StockLotUpsertWithoutStockEventsInput
    disconnect?: StockLotWhereInput | boolean
    delete?: StockLotWhereInput | boolean
    connect?: StockLotWhereUniqueInput
    update?: XOR<XOR<StockLotUpdateToOneWithWhereWithoutStockEventsInput, StockLotUpdateWithoutStockEventsInput>, StockLotUncheckedUpdateWithoutStockEventsInput>
  }

  export type StockEventEntryUncheckedUpdateOneWithoutStockEventNestedInput = {
    create?: XOR<StockEventEntryCreateWithoutStockEventInput, StockEventEntryUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockEventEntryCreateOrConnectWithoutStockEventInput
    upsert?: StockEventEntryUpsertWithoutStockEventInput
    disconnect?: StockEventEntryWhereInput | boolean
    delete?: StockEventEntryWhereInput | boolean
    connect?: StockEventEntryWhereUniqueInput
    update?: XOR<XOR<StockEventEntryUpdateToOneWithWhereWithoutStockEventInput, StockEventEntryUpdateWithoutStockEventInput>, StockEventEntryUncheckedUpdateWithoutStockEventInput>
  }

  export type StockEventOutputUncheckedUpdateOneWithoutStockEventNestedInput = {
    create?: XOR<StockEventOutputCreateWithoutStockEventInput, StockEventOutputUncheckedCreateWithoutStockEventInput>
    connectOrCreate?: StockEventOutputCreateOrConnectWithoutStockEventInput
    upsert?: StockEventOutputUpsertWithoutStockEventInput
    disconnect?: StockEventOutputWhereInput | boolean
    delete?: StockEventOutputWhereInput | boolean
    connect?: StockEventOutputWhereUniqueInput
    update?: XOR<XOR<StockEventOutputUpdateToOneWithWhereWithoutStockEventInput, StockEventOutputUpdateWithoutStockEventInput>, StockEventOutputUncheckedUpdateWithoutStockEventInput>
  }

  export type StockEventCreateNestedOneWithoutEntryInput = {
    create?: XOR<StockEventCreateWithoutEntryInput, StockEventUncheckedCreateWithoutEntryInput>
    connectOrCreate?: StockEventCreateOrConnectWithoutEntryInput
    connect?: StockEventWhereUniqueInput
  }

  export type StockEventUpdateOneRequiredWithoutEntryNestedInput = {
    create?: XOR<StockEventCreateWithoutEntryInput, StockEventUncheckedCreateWithoutEntryInput>
    connectOrCreate?: StockEventCreateOrConnectWithoutEntryInput
    upsert?: StockEventUpsertWithoutEntryInput
    connect?: StockEventWhereUniqueInput
    update?: XOR<XOR<StockEventUpdateToOneWithWhereWithoutEntryInput, StockEventUpdateWithoutEntryInput>, StockEventUncheckedUpdateWithoutEntryInput>
  }

  export type StockEventCreateNestedOneWithoutOutputInput = {
    create?: XOR<StockEventCreateWithoutOutputInput, StockEventUncheckedCreateWithoutOutputInput>
    connectOrCreate?: StockEventCreateOrConnectWithoutOutputInput
    connect?: StockEventWhereUniqueInput
  }

  export type StockEventUpdateOneRequiredWithoutOutputNestedInput = {
    create?: XOR<StockEventCreateWithoutOutputInput, StockEventUncheckedCreateWithoutOutputInput>
    connectOrCreate?: StockEventCreateOrConnectWithoutOutputInput
    upsert?: StockEventUpsertWithoutOutputInput
    connect?: StockEventWhereUniqueInput
    update?: XOR<XOR<StockEventUpdateToOneWithWhereWithoutOutputInput, StockEventUpdateWithoutOutputInput>, StockEventUncheckedUpdateWithoutOutputInput>
  }

  export type StockCreateNestedOneWithoutLotsInput = {
    create?: XOR<StockCreateWithoutLotsInput, StockUncheckedCreateWithoutLotsInput>
    connectOrCreate?: StockCreateOrConnectWithoutLotsInput
    connect?: StockWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutStockLotsInput = {
    create?: XOR<TenantCreateWithoutStockLotsInput, TenantUncheckedCreateWithoutStockLotsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockLotsInput
    connect?: TenantWhereUniqueInput
  }

  export type StockEventCreateNestedManyWithoutStockLotInput = {
    create?: XOR<StockEventCreateWithoutStockLotInput, StockEventUncheckedCreateWithoutStockLotInput> | StockEventCreateWithoutStockLotInput[] | StockEventUncheckedCreateWithoutStockLotInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutStockLotInput | StockEventCreateOrConnectWithoutStockLotInput[]
    createMany?: StockEventCreateManyStockLotInputEnvelope
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
  }

  export type SaleProductCreateNestedManyWithoutStockLotInput = {
    create?: XOR<SaleProductCreateWithoutStockLotInput, SaleProductUncheckedCreateWithoutStockLotInput> | SaleProductCreateWithoutStockLotInput[] | SaleProductUncheckedCreateWithoutStockLotInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutStockLotInput | SaleProductCreateOrConnectWithoutStockLotInput[]
    createMany?: SaleProductCreateManyStockLotInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type StockEventUncheckedCreateNestedManyWithoutStockLotInput = {
    create?: XOR<StockEventCreateWithoutStockLotInput, StockEventUncheckedCreateWithoutStockLotInput> | StockEventCreateWithoutStockLotInput[] | StockEventUncheckedCreateWithoutStockLotInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutStockLotInput | StockEventCreateOrConnectWithoutStockLotInput[]
    createMany?: StockEventCreateManyStockLotInputEnvelope
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
  }

  export type SaleProductUncheckedCreateNestedManyWithoutStockLotInput = {
    create?: XOR<SaleProductCreateWithoutStockLotInput, SaleProductUncheckedCreateWithoutStockLotInput> | SaleProductCreateWithoutStockLotInput[] | SaleProductUncheckedCreateWithoutStockLotInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutStockLotInput | SaleProductCreateOrConnectWithoutStockLotInput[]
    createMany?: SaleProductCreateManyStockLotInputEnvelope
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
  }

  export type StockUpdateOneRequiredWithoutLotsNestedInput = {
    create?: XOR<StockCreateWithoutLotsInput, StockUncheckedCreateWithoutLotsInput>
    connectOrCreate?: StockCreateOrConnectWithoutLotsInput
    upsert?: StockUpsertWithoutLotsInput
    connect?: StockWhereUniqueInput
    update?: XOR<XOR<StockUpdateToOneWithWhereWithoutLotsInput, StockUpdateWithoutLotsInput>, StockUncheckedUpdateWithoutLotsInput>
  }

  export type TenantUpdateOneRequiredWithoutStockLotsNestedInput = {
    create?: XOR<TenantCreateWithoutStockLotsInput, TenantUncheckedCreateWithoutStockLotsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStockLotsInput
    upsert?: TenantUpsertWithoutStockLotsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStockLotsInput, TenantUpdateWithoutStockLotsInput>, TenantUncheckedUpdateWithoutStockLotsInput>
  }

  export type StockEventUpdateManyWithoutStockLotNestedInput = {
    create?: XOR<StockEventCreateWithoutStockLotInput, StockEventUncheckedCreateWithoutStockLotInput> | StockEventCreateWithoutStockLotInput[] | StockEventUncheckedCreateWithoutStockLotInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutStockLotInput | StockEventCreateOrConnectWithoutStockLotInput[]
    upsert?: StockEventUpsertWithWhereUniqueWithoutStockLotInput | StockEventUpsertWithWhereUniqueWithoutStockLotInput[]
    createMany?: StockEventCreateManyStockLotInputEnvelope
    set?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    disconnect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    delete?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    update?: StockEventUpdateWithWhereUniqueWithoutStockLotInput | StockEventUpdateWithWhereUniqueWithoutStockLotInput[]
    updateMany?: StockEventUpdateManyWithWhereWithoutStockLotInput | StockEventUpdateManyWithWhereWithoutStockLotInput[]
    deleteMany?: StockEventScalarWhereInput | StockEventScalarWhereInput[]
  }

  export type SaleProductUpdateManyWithoutStockLotNestedInput = {
    create?: XOR<SaleProductCreateWithoutStockLotInput, SaleProductUncheckedCreateWithoutStockLotInput> | SaleProductCreateWithoutStockLotInput[] | SaleProductUncheckedCreateWithoutStockLotInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutStockLotInput | SaleProductCreateOrConnectWithoutStockLotInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutStockLotInput | SaleProductUpsertWithWhereUniqueWithoutStockLotInput[]
    createMany?: SaleProductCreateManyStockLotInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutStockLotInput | SaleProductUpdateWithWhereUniqueWithoutStockLotInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutStockLotInput | SaleProductUpdateManyWithWhereWithoutStockLotInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type StockEventUncheckedUpdateManyWithoutStockLotNestedInput = {
    create?: XOR<StockEventCreateWithoutStockLotInput, StockEventUncheckedCreateWithoutStockLotInput> | StockEventCreateWithoutStockLotInput[] | StockEventUncheckedCreateWithoutStockLotInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutStockLotInput | StockEventCreateOrConnectWithoutStockLotInput[]
    upsert?: StockEventUpsertWithWhereUniqueWithoutStockLotInput | StockEventUpsertWithWhereUniqueWithoutStockLotInput[]
    createMany?: StockEventCreateManyStockLotInputEnvelope
    set?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    disconnect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    delete?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    update?: StockEventUpdateWithWhereUniqueWithoutStockLotInput | StockEventUpdateWithWhereUniqueWithoutStockLotInput[]
    updateMany?: StockEventUpdateManyWithWhereWithoutStockLotInput | StockEventUpdateManyWithWhereWithoutStockLotInput[]
    deleteMany?: StockEventScalarWhereInput | StockEventScalarWhereInput[]
  }

  export type SaleProductUncheckedUpdateManyWithoutStockLotNestedInput = {
    create?: XOR<SaleProductCreateWithoutStockLotInput, SaleProductUncheckedCreateWithoutStockLotInput> | SaleProductCreateWithoutStockLotInput[] | SaleProductUncheckedCreateWithoutStockLotInput[]
    connectOrCreate?: SaleProductCreateOrConnectWithoutStockLotInput | SaleProductCreateOrConnectWithoutStockLotInput[]
    upsert?: SaleProductUpsertWithWhereUniqueWithoutStockLotInput | SaleProductUpsertWithWhereUniqueWithoutStockLotInput[]
    createMany?: SaleProductCreateManyStockLotInputEnvelope
    set?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    disconnect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    delete?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    connect?: SaleProductWhereUniqueInput | SaleProductWhereUniqueInput[]
    update?: SaleProductUpdateWithWhereUniqueWithoutStockLotInput | SaleProductUpdateWithWhereUniqueWithoutStockLotInput[]
    updateMany?: SaleProductUpdateManyWithWhereWithoutStockLotInput | SaleProductUpdateManyWithWhereWithoutStockLotInput[]
    deleteMany?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
  }

  export type TenantMembershipCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantMembershipCreateWithoutTenantInput, TenantMembershipUncheckedCreateWithoutTenantInput> | TenantMembershipCreateWithoutTenantInput[] | TenantMembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantMembershipCreateOrConnectWithoutTenantInput | TenantMembershipCreateOrConnectWithoutTenantInput[]
    createMany?: TenantMembershipCreateManyTenantInputEnvelope
    connect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutTenantInput = {
    create?: XOR<SaleCreateWithoutTenantInput, SaleUncheckedCreateWithoutTenantInput> | SaleCreateWithoutTenantInput[] | SaleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutTenantInput | SaleCreateOrConnectWithoutTenantInput[]
    createMany?: SaleCreateManyTenantInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StockCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockCreateWithoutTenantInput, StockUncheckedCreateWithoutTenantInput> | StockCreateWithoutTenantInput[] | StockUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockCreateOrConnectWithoutTenantInput | StockCreateOrConnectWithoutTenantInput[]
    createMany?: StockCreateManyTenantInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type StockLotCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockLotCreateWithoutTenantInput, StockLotUncheckedCreateWithoutTenantInput> | StockLotCreateWithoutTenantInput[] | StockLotUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockLotCreateOrConnectWithoutTenantInput | StockLotCreateOrConnectWithoutTenantInput[]
    createMany?: StockLotCreateManyTenantInputEnvelope
    connect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
  }

  export type StockEventCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockEventCreateWithoutTenantInput, StockEventUncheckedCreateWithoutTenantInput> | StockEventCreateWithoutTenantInput[] | StockEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutTenantInput | StockEventCreateOrConnectWithoutTenantInput[]
    createMany?: StockEventCreateManyTenantInputEnvelope
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
  }

  export type NotificationTargetCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationTargetCreateWithoutTenantInput, NotificationTargetUncheckedCreateWithoutTenantInput> | NotificationTargetCreateWithoutTenantInput[] | NotificationTargetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutTenantInput | NotificationTargetCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationTargetCreateManyTenantInputEnvelope
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
  }

  export type UserTenantSettingsCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserTenantSettingsCreateWithoutTenantInput, UserTenantSettingsUncheckedCreateWithoutTenantInput> | UserTenantSettingsCreateWithoutTenantInput[] | UserTenantSettingsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserTenantSettingsCreateOrConnectWithoutTenantInput | UserTenantSettingsCreateOrConnectWithoutTenantInput[]
    createMany?: UserTenantSettingsCreateManyTenantInputEnvelope
    connect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
  }

  export type TenantMembershipUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TenantMembershipCreateWithoutTenantInput, TenantMembershipUncheckedCreateWithoutTenantInput> | TenantMembershipCreateWithoutTenantInput[] | TenantMembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantMembershipCreateOrConnectWithoutTenantInput | TenantMembershipCreateOrConnectWithoutTenantInput[]
    createMany?: TenantMembershipCreateManyTenantInputEnvelope
    connect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SaleCreateWithoutTenantInput, SaleUncheckedCreateWithoutTenantInput> | SaleCreateWithoutTenantInput[] | SaleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutTenantInput | SaleCreateOrConnectWithoutTenantInput[]
    createMany?: SaleCreateManyTenantInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockCreateWithoutTenantInput, StockUncheckedCreateWithoutTenantInput> | StockCreateWithoutTenantInput[] | StockUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockCreateOrConnectWithoutTenantInput | StockCreateOrConnectWithoutTenantInput[]
    createMany?: StockCreateManyTenantInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type StockLotUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockLotCreateWithoutTenantInput, StockLotUncheckedCreateWithoutTenantInput> | StockLotCreateWithoutTenantInput[] | StockLotUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockLotCreateOrConnectWithoutTenantInput | StockLotCreateOrConnectWithoutTenantInput[]
    createMany?: StockLotCreateManyTenantInputEnvelope
    connect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
  }

  export type StockEventUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StockEventCreateWithoutTenantInput, StockEventUncheckedCreateWithoutTenantInput> | StockEventCreateWithoutTenantInput[] | StockEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutTenantInput | StockEventCreateOrConnectWithoutTenantInput[]
    createMany?: StockEventCreateManyTenantInputEnvelope
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
  }

  export type NotificationTargetUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationTargetCreateWithoutTenantInput, NotificationTargetUncheckedCreateWithoutTenantInput> | NotificationTargetCreateWithoutTenantInput[] | NotificationTargetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutTenantInput | NotificationTargetCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationTargetCreateManyTenantInputEnvelope
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
  }

  export type UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserTenantSettingsCreateWithoutTenantInput, UserTenantSettingsUncheckedCreateWithoutTenantInput> | UserTenantSettingsCreateWithoutTenantInput[] | UserTenantSettingsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserTenantSettingsCreateOrConnectWithoutTenantInput | UserTenantSettingsCreateOrConnectWithoutTenantInput[]
    createMany?: UserTenantSettingsCreateManyTenantInputEnvelope
    connect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
  }

  export type TenantMembershipUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantMembershipCreateWithoutTenantInput, TenantMembershipUncheckedCreateWithoutTenantInput> | TenantMembershipCreateWithoutTenantInput[] | TenantMembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantMembershipCreateOrConnectWithoutTenantInput | TenantMembershipCreateOrConnectWithoutTenantInput[]
    upsert?: TenantMembershipUpsertWithWhereUniqueWithoutTenantInput | TenantMembershipUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantMembershipCreateManyTenantInputEnvelope
    set?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    disconnect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    delete?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    connect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    update?: TenantMembershipUpdateWithWhereUniqueWithoutTenantInput | TenantMembershipUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantMembershipUpdateManyWithWhereWithoutTenantInput | TenantMembershipUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantMembershipScalarWhereInput | TenantMembershipScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTenantInput | ProductUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTenantInput | ProductUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTenantInput | ProductUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SaleCreateWithoutTenantInput, SaleUncheckedCreateWithoutTenantInput> | SaleCreateWithoutTenantInput[] | SaleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutTenantInput | SaleCreateOrConnectWithoutTenantInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutTenantInput | SaleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SaleCreateManyTenantInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutTenantInput | SaleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutTenantInput | SaleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StockUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockCreateWithoutTenantInput, StockUncheckedCreateWithoutTenantInput> | StockCreateWithoutTenantInput[] | StockUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockCreateOrConnectWithoutTenantInput | StockCreateOrConnectWithoutTenantInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutTenantInput | StockUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockCreateManyTenantInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutTenantInput | StockUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockUpdateManyWithWhereWithoutTenantInput | StockUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type StockLotUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockLotCreateWithoutTenantInput, StockLotUncheckedCreateWithoutTenantInput> | StockLotCreateWithoutTenantInput[] | StockLotUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockLotCreateOrConnectWithoutTenantInput | StockLotCreateOrConnectWithoutTenantInput[]
    upsert?: StockLotUpsertWithWhereUniqueWithoutTenantInput | StockLotUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockLotCreateManyTenantInputEnvelope
    set?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    disconnect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    delete?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    connect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    update?: StockLotUpdateWithWhereUniqueWithoutTenantInput | StockLotUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockLotUpdateManyWithWhereWithoutTenantInput | StockLotUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockLotScalarWhereInput | StockLotScalarWhereInput[]
  }

  export type StockEventUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockEventCreateWithoutTenantInput, StockEventUncheckedCreateWithoutTenantInput> | StockEventCreateWithoutTenantInput[] | StockEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutTenantInput | StockEventCreateOrConnectWithoutTenantInput[]
    upsert?: StockEventUpsertWithWhereUniqueWithoutTenantInput | StockEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockEventCreateManyTenantInputEnvelope
    set?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    disconnect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    delete?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    update?: StockEventUpdateWithWhereUniqueWithoutTenantInput | StockEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockEventUpdateManyWithWhereWithoutTenantInput | StockEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockEventScalarWhereInput | StockEventScalarWhereInput[]
  }

  export type NotificationTargetUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationTargetCreateWithoutTenantInput, NotificationTargetUncheckedCreateWithoutTenantInput> | NotificationTargetCreateWithoutTenantInput[] | NotificationTargetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutTenantInput | NotificationTargetCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationTargetUpsertWithWhereUniqueWithoutTenantInput | NotificationTargetUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationTargetCreateManyTenantInputEnvelope
    set?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    disconnect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    delete?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    update?: NotificationTargetUpdateWithWhereUniqueWithoutTenantInput | NotificationTargetUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationTargetUpdateManyWithWhereWithoutTenantInput | NotificationTargetUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationTargetScalarWhereInput | NotificationTargetScalarWhereInput[]
  }

  export type UserTenantSettingsUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserTenantSettingsCreateWithoutTenantInput, UserTenantSettingsUncheckedCreateWithoutTenantInput> | UserTenantSettingsCreateWithoutTenantInput[] | UserTenantSettingsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserTenantSettingsCreateOrConnectWithoutTenantInput | UserTenantSettingsCreateOrConnectWithoutTenantInput[]
    upsert?: UserTenantSettingsUpsertWithWhereUniqueWithoutTenantInput | UserTenantSettingsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserTenantSettingsCreateManyTenantInputEnvelope
    set?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    disconnect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    delete?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    connect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    update?: UserTenantSettingsUpdateWithWhereUniqueWithoutTenantInput | UserTenantSettingsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserTenantSettingsUpdateManyWithWhereWithoutTenantInput | UserTenantSettingsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserTenantSettingsScalarWhereInput | UserTenantSettingsScalarWhereInput[]
  }

  export type TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TenantMembershipCreateWithoutTenantInput, TenantMembershipUncheckedCreateWithoutTenantInput> | TenantMembershipCreateWithoutTenantInput[] | TenantMembershipUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TenantMembershipCreateOrConnectWithoutTenantInput | TenantMembershipCreateOrConnectWithoutTenantInput[]
    upsert?: TenantMembershipUpsertWithWhereUniqueWithoutTenantInput | TenantMembershipUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TenantMembershipCreateManyTenantInputEnvelope
    set?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    disconnect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    delete?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    connect?: TenantMembershipWhereUniqueInput | TenantMembershipWhereUniqueInput[]
    update?: TenantMembershipUpdateWithWhereUniqueWithoutTenantInput | TenantMembershipUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TenantMembershipUpdateManyWithWhereWithoutTenantInput | TenantMembershipUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TenantMembershipScalarWhereInput | TenantMembershipScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput> | CustomerCreateWithoutTenantInput[] | CustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutTenantInput | CustomerCreateOrConnectWithoutTenantInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutTenantInput | CustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CustomerCreateManyTenantInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutTenantInput | CustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutTenantInput | CustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput> | ProductCreateWithoutTenantInput[] | ProductUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTenantInput | ProductCreateOrConnectWithoutTenantInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTenantInput | ProductUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProductCreateManyTenantInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTenantInput | ProductUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTenantInput | ProductUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SaleCreateWithoutTenantInput, SaleUncheckedCreateWithoutTenantInput> | SaleCreateWithoutTenantInput[] | SaleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutTenantInput | SaleCreateOrConnectWithoutTenantInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutTenantInput | SaleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SaleCreateManyTenantInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutTenantInput | SaleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutTenantInput | SaleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type StockUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockCreateWithoutTenantInput, StockUncheckedCreateWithoutTenantInput> | StockCreateWithoutTenantInput[] | StockUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockCreateOrConnectWithoutTenantInput | StockCreateOrConnectWithoutTenantInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutTenantInput | StockUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockCreateManyTenantInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutTenantInput | StockUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockUpdateManyWithWhereWithoutTenantInput | StockUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type StockLotUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockLotCreateWithoutTenantInput, StockLotUncheckedCreateWithoutTenantInput> | StockLotCreateWithoutTenantInput[] | StockLotUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockLotCreateOrConnectWithoutTenantInput | StockLotCreateOrConnectWithoutTenantInput[]
    upsert?: StockLotUpsertWithWhereUniqueWithoutTenantInput | StockLotUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockLotCreateManyTenantInputEnvelope
    set?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    disconnect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    delete?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    connect?: StockLotWhereUniqueInput | StockLotWhereUniqueInput[]
    update?: StockLotUpdateWithWhereUniqueWithoutTenantInput | StockLotUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockLotUpdateManyWithWhereWithoutTenantInput | StockLotUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockLotScalarWhereInput | StockLotScalarWhereInput[]
  }

  export type StockEventUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StockEventCreateWithoutTenantInput, StockEventUncheckedCreateWithoutTenantInput> | StockEventCreateWithoutTenantInput[] | StockEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StockEventCreateOrConnectWithoutTenantInput | StockEventCreateOrConnectWithoutTenantInput[]
    upsert?: StockEventUpsertWithWhereUniqueWithoutTenantInput | StockEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StockEventCreateManyTenantInputEnvelope
    set?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    disconnect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    delete?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    connect?: StockEventWhereUniqueInput | StockEventWhereUniqueInput[]
    update?: StockEventUpdateWithWhereUniqueWithoutTenantInput | StockEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StockEventUpdateManyWithWhereWithoutTenantInput | StockEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StockEventScalarWhereInput | StockEventScalarWhereInput[]
  }

  export type NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationTargetCreateWithoutTenantInput, NotificationTargetUncheckedCreateWithoutTenantInput> | NotificationTargetCreateWithoutTenantInput[] | NotificationTargetUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutTenantInput | NotificationTargetCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationTargetUpsertWithWhereUniqueWithoutTenantInput | NotificationTargetUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationTargetCreateManyTenantInputEnvelope
    set?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    disconnect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    delete?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    update?: NotificationTargetUpdateWithWhereUniqueWithoutTenantInput | NotificationTargetUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationTargetUpdateManyWithWhereWithoutTenantInput | NotificationTargetUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationTargetScalarWhereInput | NotificationTargetScalarWhereInput[]
  }

  export type UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserTenantSettingsCreateWithoutTenantInput, UserTenantSettingsUncheckedCreateWithoutTenantInput> | UserTenantSettingsCreateWithoutTenantInput[] | UserTenantSettingsUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserTenantSettingsCreateOrConnectWithoutTenantInput | UserTenantSettingsCreateOrConnectWithoutTenantInput[]
    upsert?: UserTenantSettingsUpsertWithWhereUniqueWithoutTenantInput | UserTenantSettingsUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserTenantSettingsCreateManyTenantInputEnvelope
    set?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    disconnect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    delete?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    connect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    update?: UserTenantSettingsUpdateWithWhereUniqueWithoutTenantInput | UserTenantSettingsUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserTenantSettingsUpdateManyWithWhereWithoutTenantInput | UserTenantSettingsUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserTenantSettingsScalarWhereInput | UserTenantSettingsScalarWhereInput[]
  }

  export type MembershipCreateNestedOneWithoutTenant_membershipsInput = {
    create?: XOR<MembershipCreateWithoutTenant_membershipsInput, MembershipUncheckedCreateWithoutTenant_membershipsInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutTenant_membershipsInput
    connect?: MembershipWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMembershipsInput
    connect?: TenantWhereUniqueInput
  }

  export type MembershipUpdateOneRequiredWithoutTenant_membershipsNestedInput = {
    create?: XOR<MembershipCreateWithoutTenant_membershipsInput, MembershipUncheckedCreateWithoutTenant_membershipsInput>
    connectOrCreate?: MembershipCreateOrConnectWithoutTenant_membershipsInput
    upsert?: MembershipUpsertWithoutTenant_membershipsInput
    connect?: MembershipWhereUniqueInput
    update?: XOR<XOR<MembershipUpdateToOneWithWhereWithoutTenant_membershipsInput, MembershipUpdateWithoutTenant_membershipsInput>, MembershipUncheckedUpdateWithoutTenant_membershipsInput>
  }

  export type TenantUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMembershipsInput
    upsert?: TenantUpsertWithoutMembershipsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMembershipsInput, TenantUpdateWithoutMembershipsInput>, TenantUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserTenantSettingsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTenantSettingsCreateWithoutUserInput, UserTenantSettingsUncheckedCreateWithoutUserInput> | UserTenantSettingsCreateWithoutUserInput[] | UserTenantSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTenantSettingsCreateOrConnectWithoutUserInput | UserTenantSettingsCreateOrConnectWithoutUserInput[]
    createMany?: UserTenantSettingsCreateManyUserInputEnvelope
    connect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
  }

  export type NotificationTargetCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationTargetCreateWithoutUserInput, NotificationTargetUncheckedCreateWithoutUserInput> | NotificationTargetCreateWithoutUserInput[] | NotificationTargetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutUserInput | NotificationTargetCreateOrConnectWithoutUserInput[]
    createMany?: NotificationTargetCreateManyUserInputEnvelope
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
  }

  export type MembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type UserTenantSettingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTenantSettingsCreateWithoutUserInput, UserTenantSettingsUncheckedCreateWithoutUserInput> | UserTenantSettingsCreateWithoutUserInput[] | UserTenantSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTenantSettingsCreateOrConnectWithoutUserInput | UserTenantSettingsCreateOrConnectWithoutUserInput[]
    createMany?: UserTenantSettingsCreateManyUserInputEnvelope
    connect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
  }

  export type NotificationTargetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationTargetCreateWithoutUserInput, NotificationTargetUncheckedCreateWithoutUserInput> | NotificationTargetCreateWithoutUserInput[] | NotificationTargetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutUserInput | NotificationTargetCreateOrConnectWithoutUserInput[]
    createMany?: NotificationTargetCreateManyUserInputEnvelope
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
  }

  export type MembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
  }

  export type UserTenantSettingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTenantSettingsCreateWithoutUserInput, UserTenantSettingsUncheckedCreateWithoutUserInput> | UserTenantSettingsCreateWithoutUserInput[] | UserTenantSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTenantSettingsCreateOrConnectWithoutUserInput | UserTenantSettingsCreateOrConnectWithoutUserInput[]
    upsert?: UserTenantSettingsUpsertWithWhereUniqueWithoutUserInput | UserTenantSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTenantSettingsCreateManyUserInputEnvelope
    set?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    disconnect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    delete?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    connect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    update?: UserTenantSettingsUpdateWithWhereUniqueWithoutUserInput | UserTenantSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTenantSettingsUpdateManyWithWhereWithoutUserInput | UserTenantSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTenantSettingsScalarWhereInput | UserTenantSettingsScalarWhereInput[]
  }

  export type NotificationTargetUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationTargetCreateWithoutUserInput, NotificationTargetUncheckedCreateWithoutUserInput> | NotificationTargetCreateWithoutUserInput[] | NotificationTargetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutUserInput | NotificationTargetCreateOrConnectWithoutUserInput[]
    upsert?: NotificationTargetUpsertWithWhereUniqueWithoutUserInput | NotificationTargetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationTargetCreateManyUserInputEnvelope
    set?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    disconnect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    delete?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    update?: NotificationTargetUpdateWithWhereUniqueWithoutUserInput | NotificationTargetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationTargetUpdateManyWithWhereWithoutUserInput | NotificationTargetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationTargetScalarWhereInput | NotificationTargetScalarWhereInput[]
  }

  export type MembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutUserInput | MembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutUserInput | MembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutUserInput | MembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type UserTenantSettingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTenantSettingsCreateWithoutUserInput, UserTenantSettingsUncheckedCreateWithoutUserInput> | UserTenantSettingsCreateWithoutUserInput[] | UserTenantSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTenantSettingsCreateOrConnectWithoutUserInput | UserTenantSettingsCreateOrConnectWithoutUserInput[]
    upsert?: UserTenantSettingsUpsertWithWhereUniqueWithoutUserInput | UserTenantSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTenantSettingsCreateManyUserInputEnvelope
    set?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    disconnect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    delete?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    connect?: UserTenantSettingsWhereUniqueInput | UserTenantSettingsWhereUniqueInput[]
    update?: UserTenantSettingsUpdateWithWhereUniqueWithoutUserInput | UserTenantSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTenantSettingsUpdateManyWithWhereWithoutUserInput | UserTenantSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTenantSettingsScalarWhereInput | UserTenantSettingsScalarWhereInput[]
  }

  export type NotificationTargetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationTargetCreateWithoutUserInput, NotificationTargetUncheckedCreateWithoutUserInput> | NotificationTargetCreateWithoutUserInput[] | NotificationTargetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationTargetCreateOrConnectWithoutUserInput | NotificationTargetCreateOrConnectWithoutUserInput[]
    upsert?: NotificationTargetUpsertWithWhereUniqueWithoutUserInput | NotificationTargetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationTargetCreateManyUserInputEnvelope
    set?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    disconnect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    delete?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    connect?: NotificationTargetWhereUniqueInput | NotificationTargetWhereUniqueInput[]
    update?: NotificationTargetUpdateWithWhereUniqueWithoutUserInput | NotificationTargetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationTargetUpdateManyWithWhereWithoutUserInput | NotificationTargetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationTargetScalarWhereInput | NotificationTargetScalarWhereInput[]
  }

  export type MembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput> | MembershipCreateWithoutUserInput[] | MembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MembershipCreateOrConnectWithoutUserInput | MembershipCreateOrConnectWithoutUserInput[]
    upsert?: MembershipUpsertWithWhereUniqueWithoutUserInput | MembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MembershipCreateManyUserInputEnvelope
    set?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    disconnect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    delete?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    connect?: MembershipWhereUniqueInput | MembershipWhereUniqueInput[]
    update?: MembershipUpdateWithWhereUniqueWithoutUserInput | MembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MembershipUpdateManyWithWhereWithoutUserInput | MembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTenantSettingsInput = {
    create?: XOR<UserCreateWithoutTenantSettingsInput, UserUncheckedCreateWithoutTenantSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutUserTenantSettingsInput = {
    create?: XOR<TenantCreateWithoutUserTenantSettingsInput, TenantUncheckedCreateWithoutUserTenantSettingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserTenantSettingsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTenantSettingsNestedInput = {
    create?: XOR<UserCreateWithoutTenantSettingsInput, UserUncheckedCreateWithoutTenantSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTenantSettingsInput
    upsert?: UserUpsertWithoutTenantSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTenantSettingsInput, UserUpdateWithoutTenantSettingsInput>, UserUncheckedUpdateWithoutTenantSettingsInput>
  }

  export type TenantUpdateOneRequiredWithoutUserTenantSettingsNestedInput = {
    create?: XOR<TenantCreateWithoutUserTenantSettingsInput, TenantUncheckedCreateWithoutUserTenantSettingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserTenantSettingsInput
    upsert?: TenantUpsertWithoutUserTenantSettingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUserTenantSettingsInput, TenantUpdateWithoutUserTenantSettingsInput>, TenantUncheckedUpdateWithoutUserTenantSettingsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumEMembershipRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.EMembershipRole | EnumEMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EMembershipRole[] | ListEnumEMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EMembershipRole[] | ListEnumEMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEMembershipRoleFilter<$PrismaModel> | $Enums.EMembershipRole
  }

  export type NestedEnumEMembershipRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EMembershipRole | EnumEMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.EMembershipRole[] | ListEnumEMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.EMembershipRole[] | ListEnumEMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumEMembershipRoleWithAggregatesFilter<$PrismaModel> | $Enums.EMembershipRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEMembershipRoleFilter<$PrismaModel>
    _max?: NestedEnumEMembershipRoleFilter<$PrismaModel>
  }

  export type NestedEnumENotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ENotificationType | EnumENotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ENotificationType[] | ListEnumENotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ENotificationType[] | ListEnumENotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumENotificationTypeFilter<$PrismaModel> | $Enums.ENotificationType
  }

  export type NestedEnumENotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ENotificationType | EnumENotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ENotificationType[] | ListEnumENotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ENotificationType[] | ListEnumENotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumENotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ENotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumENotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumENotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumENotificationTargetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ENotificationTargetStatus | EnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ENotificationTargetStatus[] | ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ENotificationTargetStatus[] | ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumENotificationTargetStatusFilter<$PrismaModel> | $Enums.ENotificationTargetStatus
  }

  export type NestedEnumENotificationTargetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ENotificationTargetStatus | EnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ENotificationTargetStatus[] | ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ENotificationTargetStatus[] | ListEnumENotificationTargetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumENotificationTargetStatusWithAggregatesFilter<$PrismaModel> | $Enums.ENotificationTargetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumENotificationTargetStatusFilter<$PrismaModel>
    _max?: NestedEnumENotificationTargetStatusFilter<$PrismaModel>
  }

  export type NestedEnumEPosStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosStatus | EnumEPosStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EPosStatus[] | ListEnumEPosStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosStatus[] | ListEnumEPosStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosStatusFilter<$PrismaModel> | $Enums.EPosStatus
  }

  export type NestedEnumEPosStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosStatus | EnumEPosStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EPosStatus[] | ListEnumEPosStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosStatus[] | ListEnumEPosStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosStatusWithAggregatesFilter<$PrismaModel> | $Enums.EPosStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEPosStatusFilter<$PrismaModel>
    _max?: NestedEnumEPosStatusFilter<$PrismaModel>
  }

  export type NestedEnumEPosEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosEventType | EnumEPosEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EPosEventType[] | ListEnumEPosEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosEventType[] | ListEnumEPosEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosEventTypeFilter<$PrismaModel> | $Enums.EPosEventType
  }

  export type NestedEnumEPosEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosEventStatus | EnumEPosEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EPosEventStatus[] | ListEnumEPosEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosEventStatus[] | ListEnumEPosEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosEventStatusFilter<$PrismaModel> | $Enums.EPosEventStatus
  }

  export type NestedEnumEPosEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosEventType | EnumEPosEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EPosEventType[] | ListEnumEPosEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosEventType[] | ListEnumEPosEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EPosEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEPosEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEPosEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumEPosEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EPosEventStatus | EnumEPosEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EPosEventStatus[] | ListEnumEPosEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPosEventStatus[] | ListEnumEPosEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEPosEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.EPosEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEPosEventStatusFilter<$PrismaModel>
    _max?: NestedEnumEPosEventStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumEDiscountVariantFilter<$PrismaModel = never> = {
    equals?: $Enums.EDiscountVariant | EnumEDiscountVariantFieldRefInput<$PrismaModel>
    in?: $Enums.EDiscountVariant[] | ListEnumEDiscountVariantFieldRefInput<$PrismaModel>
    notIn?: $Enums.EDiscountVariant[] | ListEnumEDiscountVariantFieldRefInput<$PrismaModel>
    not?: NestedEnumEDiscountVariantFilter<$PrismaModel> | $Enums.EDiscountVariant
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumEDiscountVariantWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EDiscountVariant | EnumEDiscountVariantFieldRefInput<$PrismaModel>
    in?: $Enums.EDiscountVariant[] | ListEnumEDiscountVariantFieldRefInput<$PrismaModel>
    notIn?: $Enums.EDiscountVariant[] | ListEnumEDiscountVariantFieldRefInput<$PrismaModel>
    not?: NestedEnumEDiscountVariantWithAggregatesFilter<$PrismaModel> | $Enums.EDiscountVariant
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEDiscountVariantFilter<$PrismaModel>
    _max?: NestedEnumEDiscountVariantFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumESaleMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ESaleMovementType | EnumESaleMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ESaleMovementType[] | ListEnumESaleMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ESaleMovementType[] | ListEnumESaleMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumESaleMovementTypeFilter<$PrismaModel> | $Enums.ESaleMovementType
  }

  export type NestedEnumESaleMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ESaleMovementType | EnumESaleMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ESaleMovementType[] | ListEnumESaleMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ESaleMovementType[] | ListEnumESaleMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumESaleMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ESaleMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumESaleMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumESaleMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumEPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.EPaymentMethod | EnumEPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.EPaymentMethod[] | ListEnumEPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPaymentMethod[] | ListEnumEPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumEPaymentMethodFilter<$PrismaModel> | $Enums.EPaymentMethod
  }

  export type NestedEnumEPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EPaymentMethod | EnumEPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.EPaymentMethod[] | ListEnumEPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.EPaymentMethod[] | ListEnumEPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumEPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.EPaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumEPaymentMethodFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumESaleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ESaleStatus | EnumESaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ESaleStatus[] | ListEnumESaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ESaleStatus[] | ListEnumESaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumESaleStatusFilter<$PrismaModel> | $Enums.ESaleStatus
  }

  export type NestedEnumESaleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ESaleStatus | EnumESaleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ESaleStatus[] | ListEnumESaleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ESaleStatus[] | ListEnumESaleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumESaleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ESaleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumESaleStatusFilter<$PrismaModel>
    _max?: NestedEnumESaleStatusFilter<$PrismaModel>
  }

  export type NestedEnumEStockStrategyFilter<$PrismaModel = never> = {
    equals?: $Enums.EStockStrategy | EnumEStockStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.EStockStrategy[] | ListEnumEStockStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.EStockStrategy[] | ListEnumEStockStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumEStockStrategyFilter<$PrismaModel> | $Enums.EStockStrategy
  }

  export type NestedEnumEStockStrategyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EStockStrategy | EnumEStockStrategyFieldRefInput<$PrismaModel>
    in?: $Enums.EStockStrategy[] | ListEnumEStockStrategyFieldRefInput<$PrismaModel>
    notIn?: $Enums.EStockStrategy[] | ListEnumEStockStrategyFieldRefInput<$PrismaModel>
    not?: NestedEnumEStockStrategyWithAggregatesFilter<$PrismaModel> | $Enums.EStockStrategy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEStockStrategyFilter<$PrismaModel>
    _max?: NestedEnumEStockStrategyFilter<$PrismaModel>
  }

  export type NestedEnumEStockEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EStockEventType | EnumEStockEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EStockEventType[] | ListEnumEStockEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EStockEventType[] | ListEnumEStockEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEStockEventTypeFilter<$PrismaModel> | $Enums.EStockEventType
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumEStockEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EStockEventType | EnumEStockEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EStockEventType[] | ListEnumEStockEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EStockEventType[] | ListEnumEStockEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEStockEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EStockEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEStockEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEStockEventTypeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type TenantCreateWithoutCustomersInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCustomersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
  }

  export type SaleCreateWithoutCustomerInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductCreateNestedManyWithoutSaleInput
    movements?: SaleMovementCreateNestedManyWithoutSaleInput
    tenant: TenantCreateNestedOneWithoutSalesInput
    PosEventSale?: PosEventSaleCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutCustomerInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    tenantId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    movements?: SaleMovementUncheckedCreateNestedManyWithoutSaleInput
    PosEventSale?: PosEventSaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleCreateManyCustomerInputEnvelope = {
    data: SaleCreateManyCustomerInput | SaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PosEventSaleCreateWithoutCustomerInput = {
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    sale: SaleCreateNestedOneWithoutPosEventSaleInput
    posEvent: PosEventCreateNestedOneWithoutSaleInput
    products?: PosEventSaleProductCreateNestedManyWithoutPosEventSaleInput
    movements?: PosEventSaleMovementCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleUncheckedCreateWithoutCustomerInput = {
    id: string
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    saleId: string
    products?: PosEventSaleProductUncheckedCreateNestedManyWithoutPosEventSaleInput
    movements?: PosEventSaleMovementUncheckedCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleCreateOrConnectWithoutCustomerInput = {
    where: PosEventSaleWhereUniqueInput
    create: XOR<PosEventSaleCreateWithoutCustomerInput, PosEventSaleUncheckedCreateWithoutCustomerInput>
  }

  export type PosEventSaleCreateManyCustomerInputEnvelope = {
    data: PosEventSaleCreateManyCustomerInput | PosEventSaleCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCustomersInput = {
    update: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
    create: XOR<TenantCreateWithoutCustomersInput, TenantUncheckedCreateWithoutCustomersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCustomersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCustomersInput, TenantUncheckedUpdateWithoutCustomersInput>
  }

  export type TenantUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleCreateWithoutCustomerInput, SaleUncheckedCreateWithoutCustomerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutCustomerInput, SaleUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: UuidFilter<"Sale"> | string
    status?: EnumESaleStatusFilter<"Sale"> | $Enums.ESaleStatus
    internalCode?: StringFilter<"Sale"> | string
    customerId?: UuidFilter<"Sale"> | string
    tenantId?: UuidFilter<"Sale"> | string
    discountVariant?: EnumEDiscountVariantFilter<"Sale"> | $Enums.EDiscountVariant
    discountValue?: FloatFilter<"Sale"> | number
    paidTotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFilter<"Sale"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Sale"> | Date | string | null
  }

  export type PosEventSaleUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PosEventSaleWhereUniqueInput
    update: XOR<PosEventSaleUpdateWithoutCustomerInput, PosEventSaleUncheckedUpdateWithoutCustomerInput>
    create: XOR<PosEventSaleCreateWithoutCustomerInput, PosEventSaleUncheckedCreateWithoutCustomerInput>
  }

  export type PosEventSaleUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PosEventSaleWhereUniqueInput
    data: XOR<PosEventSaleUpdateWithoutCustomerInput, PosEventSaleUncheckedUpdateWithoutCustomerInput>
  }

  export type PosEventSaleUpdateManyWithWhereWithoutCustomerInput = {
    where: PosEventSaleScalarWhereInput
    data: XOR<PosEventSaleUpdateManyMutationInput, PosEventSaleUncheckedUpdateManyWithoutCustomerInput>
  }

  export type PosEventSaleScalarWhereInput = {
    AND?: PosEventSaleScalarWhereInput | PosEventSaleScalarWhereInput[]
    OR?: PosEventSaleScalarWhereInput[]
    NOT?: PosEventSaleScalarWhereInput | PosEventSaleScalarWhereInput[]
    id?: UuidFilter<"PosEventSale"> | string
    description?: StringFilter<"PosEventSale"> | string
    amount?: DecimalFilter<"PosEventSale"> | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFilter<"PosEventSale"> | $Enums.EDiscountVariant
    discountValue?: FloatFilter<"PosEventSale"> | number
    customerId?: UuidFilter<"PosEventSale"> | string
    saleId?: UuidFilter<"PosEventSale"> | string
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantSettings?: UserTenantSettingsCreateNestedManyWithoutUserInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutUserInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type TenantMembershipCreateWithoutMembershipInput = {
    tenant: TenantCreateNestedOneWithoutMembershipsInput
  }

  export type TenantMembershipUncheckedCreateWithoutMembershipInput = {
    tenantId: string
  }

  export type TenantMembershipCreateOrConnectWithoutMembershipInput = {
    where: TenantMembershipWhereUniqueInput
    create: XOR<TenantMembershipCreateWithoutMembershipInput, TenantMembershipUncheckedCreateWithoutMembershipInput>
  }

  export type TenantMembershipCreateManyMembershipInputEnvelope = {
    data: TenantMembershipCreateManyMembershipInput | TenantMembershipCreateManyMembershipInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantSettings?: UserTenantSettingsUpdateManyWithoutUserNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutUserNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantMembershipUpsertWithWhereUniqueWithoutMembershipInput = {
    where: TenantMembershipWhereUniqueInput
    update: XOR<TenantMembershipUpdateWithoutMembershipInput, TenantMembershipUncheckedUpdateWithoutMembershipInput>
    create: XOR<TenantMembershipCreateWithoutMembershipInput, TenantMembershipUncheckedCreateWithoutMembershipInput>
  }

  export type TenantMembershipUpdateWithWhereUniqueWithoutMembershipInput = {
    where: TenantMembershipWhereUniqueInput
    data: XOR<TenantMembershipUpdateWithoutMembershipInput, TenantMembershipUncheckedUpdateWithoutMembershipInput>
  }

  export type TenantMembershipUpdateManyWithWhereWithoutMembershipInput = {
    where: TenantMembershipScalarWhereInput
    data: XOR<TenantMembershipUpdateManyMutationInput, TenantMembershipUncheckedUpdateManyWithoutMembershipInput>
  }

  export type TenantMembershipScalarWhereInput = {
    AND?: TenantMembershipScalarWhereInput | TenantMembershipScalarWhereInput[]
    OR?: TenantMembershipScalarWhereInput[]
    NOT?: TenantMembershipScalarWhereInput | TenantMembershipScalarWhereInput[]
    membershipId?: UuidFilter<"TenantMembership"> | string
    tenantId?: UuidFilter<"TenantMembership"> | string
  }

  export type NotificationTargetCreateWithoutNotificationInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    user: UserCreateNestedOneWithoutNotificationTargetInput
    tenant: TenantCreateNestedOneWithoutNotificationTargetInput
  }

  export type NotificationTargetUncheckedCreateWithoutNotificationInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    userId: string
    tenantId: string
  }

  export type NotificationTargetCreateOrConnectWithoutNotificationInput = {
    where: NotificationTargetWhereUniqueInput
    create: XOR<NotificationTargetCreateWithoutNotificationInput, NotificationTargetUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationTargetCreateManyNotificationInputEnvelope = {
    data: NotificationTargetCreateManyNotificationInput | NotificationTargetCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationTargetUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationTargetWhereUniqueInput
    update: XOR<NotificationTargetUpdateWithoutNotificationInput, NotificationTargetUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationTargetCreateWithoutNotificationInput, NotificationTargetUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationTargetUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationTargetWhereUniqueInput
    data: XOR<NotificationTargetUpdateWithoutNotificationInput, NotificationTargetUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationTargetUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationTargetScalarWhereInput
    data: XOR<NotificationTargetUpdateManyMutationInput, NotificationTargetUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationTargetScalarWhereInput = {
    AND?: NotificationTargetScalarWhereInput | NotificationTargetScalarWhereInput[]
    OR?: NotificationTargetScalarWhereInput[]
    NOT?: NotificationTargetScalarWhereInput | NotificationTargetScalarWhereInput[]
    id?: UuidFilter<"NotificationTarget"> | string
    status?: EnumENotificationTargetStatusFilter<"NotificationTarget"> | $Enums.ENotificationTargetStatus
    notificationId?: UuidFilter<"NotificationTarget"> | string
    userId?: UuidFilter<"NotificationTarget"> | string
    tenantId?: UuidFilter<"NotificationTarget"> | string
  }

  export type NotificationCreateWithoutTargetsInput = {
    id?: string
    type?: $Enums.ENotificationType
    subject: string
    body: string
    href?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutTargetsInput = {
    id?: string
    type?: $Enums.ENotificationType
    subject: string
    body: string
    href?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTargetsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTargetsInput, NotificationUncheckedCreateWithoutTargetsInput>
  }

  export type UserCreateWithoutNotificationTargetInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantSettings?: UserTenantSettingsCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationTargetInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationTargetInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationTargetInput, UserUncheckedCreateWithoutNotificationTargetInput>
  }

  export type TenantCreateWithoutNotificationTargetInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationTargetInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationTargetInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationTargetInput, TenantUncheckedCreateWithoutNotificationTargetInput>
  }

  export type NotificationUpsertWithoutTargetsInput = {
    update: XOR<NotificationUpdateWithoutTargetsInput, NotificationUncheckedUpdateWithoutTargetsInput>
    create: XOR<NotificationCreateWithoutTargetsInput, NotificationUncheckedCreateWithoutTargetsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutTargetsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutTargetsInput, NotificationUncheckedUpdateWithoutTargetsInput>
  }

  export type NotificationUpdateWithoutTargetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumENotificationTypeFieldUpdateOperationsInput | $Enums.ENotificationType
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutTargetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumENotificationTypeFieldUpdateOperationsInput | $Enums.ENotificationType
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    href?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutNotificationTargetInput = {
    update: XOR<UserUpdateWithoutNotificationTargetInput, UserUncheckedUpdateWithoutNotificationTargetInput>
    create: XOR<UserCreateWithoutNotificationTargetInput, UserUncheckedCreateWithoutNotificationTargetInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationTargetInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationTargetInput, UserUncheckedUpdateWithoutNotificationTargetInput>
  }

  export type UserUpdateWithoutNotificationTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantSettings?: UserTenantSettingsUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantUpsertWithoutNotificationTargetInput = {
    update: XOR<TenantUpdateWithoutNotificationTargetInput, TenantUncheckedUpdateWithoutNotificationTargetInput>
    create: XOR<TenantCreateWithoutNotificationTargetInput, TenantUncheckedCreateWithoutNotificationTargetInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationTargetInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationTargetInput, TenantUncheckedUpdateWithoutNotificationTargetInput>
  }

  export type TenantUpdateWithoutNotificationTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PosEventEntryCreateWithoutPosEventInput = {
    amount: Decimal | DecimalJsLike | number | string
    description?: string
  }

  export type PosEventEntryUncheckedCreateWithoutPosEventInput = {
    amount: Decimal | DecimalJsLike | number | string
    description?: string
  }

  export type PosEventEntryCreateOrConnectWithoutPosEventInput = {
    where: PosEventEntryWhereUniqueInput
    create: XOR<PosEventEntryCreateWithoutPosEventInput, PosEventEntryUncheckedCreateWithoutPosEventInput>
  }

  export type PosEventOutputCreateWithoutPosEventInput = {
    amount: Decimal | DecimalJsLike | number | string
    description?: string
  }

  export type PosEventOutputUncheckedCreateWithoutPosEventInput = {
    amount: Decimal | DecimalJsLike | number | string
    description?: string
  }

  export type PosEventOutputCreateOrConnectWithoutPosEventInput = {
    where: PosEventOutputWhereUniqueInput
    create: XOR<PosEventOutputCreateWithoutPosEventInput, PosEventOutputUncheckedCreateWithoutPosEventInput>
  }

  export type PosEventSaleCreateWithoutPosEventInput = {
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    sale: SaleCreateNestedOneWithoutPosEventSaleInput
    customer: CustomerCreateNestedOneWithoutPosEventSalesInput
    products?: PosEventSaleProductCreateNestedManyWithoutPosEventSaleInput
    movements?: PosEventSaleMovementCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleUncheckedCreateWithoutPosEventInput = {
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    customerId: string
    saleId: string
    products?: PosEventSaleProductUncheckedCreateNestedManyWithoutPosEventSaleInput
    movements?: PosEventSaleMovementUncheckedCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleCreateOrConnectWithoutPosEventInput = {
    where: PosEventSaleWhereUniqueInput
    create: XOR<PosEventSaleCreateWithoutPosEventInput, PosEventSaleUncheckedCreateWithoutPosEventInput>
  }

  export type PosEventEntryUpsertWithoutPosEventInput = {
    update: XOR<PosEventEntryUpdateWithoutPosEventInput, PosEventEntryUncheckedUpdateWithoutPosEventInput>
    create: XOR<PosEventEntryCreateWithoutPosEventInput, PosEventEntryUncheckedCreateWithoutPosEventInput>
    where?: PosEventEntryWhereInput
  }

  export type PosEventEntryUpdateToOneWithWhereWithoutPosEventInput = {
    where?: PosEventEntryWhereInput
    data: XOR<PosEventEntryUpdateWithoutPosEventInput, PosEventEntryUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventEntryUpdateWithoutPosEventInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventEntryUncheckedUpdateWithoutPosEventInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventOutputUpsertWithoutPosEventInput = {
    update: XOR<PosEventOutputUpdateWithoutPosEventInput, PosEventOutputUncheckedUpdateWithoutPosEventInput>
    create: XOR<PosEventOutputCreateWithoutPosEventInput, PosEventOutputUncheckedCreateWithoutPosEventInput>
    where?: PosEventOutputWhereInput
  }

  export type PosEventOutputUpdateToOneWithWhereWithoutPosEventInput = {
    where?: PosEventOutputWhereInput
    data: XOR<PosEventOutputUpdateWithoutPosEventInput, PosEventOutputUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventOutputUpdateWithoutPosEventInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventOutputUncheckedUpdateWithoutPosEventInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventSaleUpsertWithoutPosEventInput = {
    update: XOR<PosEventSaleUpdateWithoutPosEventInput, PosEventSaleUncheckedUpdateWithoutPosEventInput>
    create: XOR<PosEventSaleCreateWithoutPosEventInput, PosEventSaleUncheckedCreateWithoutPosEventInput>
    where?: PosEventSaleWhereInput
  }

  export type PosEventSaleUpdateToOneWithWhereWithoutPosEventInput = {
    where?: PosEventSaleWhereInput
    data: XOR<PosEventSaleUpdateWithoutPosEventInput, PosEventSaleUncheckedUpdateWithoutPosEventInput>
  }

  export type PosEventSaleUpdateWithoutPosEventInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    sale?: SaleUpdateOneRequiredWithoutPosEventSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPosEventSalesNestedInput
    products?: PosEventSaleProductUpdateManyWithoutPosEventSaleNestedInput
    movements?: PosEventSaleMovementUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleUncheckedUpdateWithoutPosEventInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    products?: PosEventSaleProductUncheckedUpdateManyWithoutPosEventSaleNestedInput
    movements?: PosEventSaleMovementUncheckedUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventCreateWithoutEntryInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    output?: PosEventOutputCreateNestedOneWithoutPosEventInput
    sale?: PosEventSaleCreateNestedOneWithoutPosEventInput
  }

  export type PosEventUncheckedCreateWithoutEntryInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    output?: PosEventOutputUncheckedCreateNestedOneWithoutPosEventInput
    sale?: PosEventSaleUncheckedCreateNestedOneWithoutPosEventInput
  }

  export type PosEventCreateOrConnectWithoutEntryInput = {
    where: PosEventWhereUniqueInput
    create: XOR<PosEventCreateWithoutEntryInput, PosEventUncheckedCreateWithoutEntryInput>
  }

  export type PosEventUpsertWithoutEntryInput = {
    update: XOR<PosEventUpdateWithoutEntryInput, PosEventUncheckedUpdateWithoutEntryInput>
    create: XOR<PosEventCreateWithoutEntryInput, PosEventUncheckedCreateWithoutEntryInput>
    where?: PosEventWhereInput
  }

  export type PosEventUpdateToOneWithWhereWithoutEntryInput = {
    where?: PosEventWhereInput
    data: XOR<PosEventUpdateWithoutEntryInput, PosEventUncheckedUpdateWithoutEntryInput>
  }

  export type PosEventUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: PosEventOutputUpdateOneWithoutPosEventNestedInput
    sale?: PosEventSaleUpdateOneWithoutPosEventNestedInput
  }

  export type PosEventUncheckedUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    output?: PosEventOutputUncheckedUpdateOneWithoutPosEventNestedInput
    sale?: PosEventSaleUncheckedUpdateOneWithoutPosEventNestedInput
  }

  export type PosEventCreateWithoutOutputInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    entry?: PosEventEntryCreateNestedOneWithoutPosEventInput
    sale?: PosEventSaleCreateNestedOneWithoutPosEventInput
  }

  export type PosEventUncheckedCreateWithoutOutputInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    entry?: PosEventEntryUncheckedCreateNestedOneWithoutPosEventInput
    sale?: PosEventSaleUncheckedCreateNestedOneWithoutPosEventInput
  }

  export type PosEventCreateOrConnectWithoutOutputInput = {
    where: PosEventWhereUniqueInput
    create: XOR<PosEventCreateWithoutOutputInput, PosEventUncheckedCreateWithoutOutputInput>
  }

  export type PosEventUpsertWithoutOutputInput = {
    update: XOR<PosEventUpdateWithoutOutputInput, PosEventUncheckedUpdateWithoutOutputInput>
    create: XOR<PosEventCreateWithoutOutputInput, PosEventUncheckedCreateWithoutOutputInput>
    where?: PosEventWhereInput
  }

  export type PosEventUpdateToOneWithWhereWithoutOutputInput = {
    where?: PosEventWhereInput
    data: XOR<PosEventUpdateWithoutOutputInput, PosEventUncheckedUpdateWithoutOutputInput>
  }

  export type PosEventUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entry?: PosEventEntryUpdateOneWithoutPosEventNestedInput
    sale?: PosEventSaleUpdateOneWithoutPosEventNestedInput
  }

  export type PosEventUncheckedUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entry?: PosEventEntryUncheckedUpdateOneWithoutPosEventNestedInput
    sale?: PosEventSaleUncheckedUpdateOneWithoutPosEventNestedInput
  }

  export type SaleCreateWithoutPosEventSaleInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductCreateNestedManyWithoutSaleInput
    movements?: SaleMovementCreateNestedManyWithoutSaleInput
    customer: CustomerCreateNestedOneWithoutSalesInput
    tenant: TenantCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutPosEventSaleInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    customerId: string
    tenantId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    movements?: SaleMovementUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutPosEventSaleInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutPosEventSaleInput, SaleUncheckedCreateWithoutPosEventSaleInput>
  }

  export type CustomerCreateWithoutPosEventSalesInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCustomersInput
    sales?: SaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPosEventSalesInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPosEventSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPosEventSalesInput, CustomerUncheckedCreateWithoutPosEventSalesInput>
  }

  export type PosEventCreateWithoutSaleInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    entry?: PosEventEntryCreateNestedOneWithoutPosEventInput
    output?: PosEventOutputCreateNestedOneWithoutPosEventInput
  }

  export type PosEventUncheckedCreateWithoutSaleInput = {
    id?: string
    type: $Enums.EPosEventType
    status?: $Enums.EPosEventStatus
    posId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    entry?: PosEventEntryUncheckedCreateNestedOneWithoutPosEventInput
    output?: PosEventOutputUncheckedCreateNestedOneWithoutPosEventInput
  }

  export type PosEventCreateOrConnectWithoutSaleInput = {
    where: PosEventWhereUniqueInput
    create: XOR<PosEventCreateWithoutSaleInput, PosEventUncheckedCreateWithoutSaleInput>
  }

  export type PosEventSaleProductCreateWithoutPosEventSaleInput = {
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutPosEventSaleProductInput
  }

  export type PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput = {
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type PosEventSaleProductCreateOrConnectWithoutPosEventSaleInput = {
    where: PosEventSaleProductWhereUniqueInput
    create: XOR<PosEventSaleProductCreateWithoutPosEventSaleInput, PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput>
  }

  export type PosEventSaleProductCreateManyPosEventSaleInputEnvelope = {
    data: PosEventSaleProductCreateManyPosEventSaleInput | PosEventSaleProductCreateManyPosEventSaleInput[]
    skipDuplicates?: boolean
  }

  export type PosEventSaleMovementCreateWithoutPosEventSaleInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PosEventSaleMovementPaymentCreateNestedManyWithoutPosEventSaleMovementInput
    changes?: PosEventSaleMovementChangeCreateNestedManyWithoutPosEventSaleMovementInput
  }

  export type PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PosEventSaleMovementPaymentUncheckedCreateNestedManyWithoutPosEventSaleMovementInput
    changes?: PosEventSaleMovementChangeUncheckedCreateNestedManyWithoutPosEventSaleMovementInput
  }

  export type PosEventSaleMovementCreateOrConnectWithoutPosEventSaleInput = {
    where: PosEventSaleMovementWhereUniqueInput
    create: XOR<PosEventSaleMovementCreateWithoutPosEventSaleInput, PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput>
  }

  export type PosEventSaleMovementCreateManyPosEventSaleInputEnvelope = {
    data: PosEventSaleMovementCreateManyPosEventSaleInput | PosEventSaleMovementCreateManyPosEventSaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithoutPosEventSaleInput = {
    update: XOR<SaleUpdateWithoutPosEventSaleInput, SaleUncheckedUpdateWithoutPosEventSaleInput>
    create: XOR<SaleCreateWithoutPosEventSaleInput, SaleUncheckedCreateWithoutPosEventSaleInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutPosEventSaleInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutPosEventSaleInput, SaleUncheckedUpdateWithoutPosEventSaleInput>
  }

  export type SaleUpdateWithoutPosEventSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    movements?: SaleMovementUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutPosEventSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    movements?: SaleMovementUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type CustomerUpsertWithoutPosEventSalesInput = {
    update: XOR<CustomerUpdateWithoutPosEventSalesInput, CustomerUncheckedUpdateWithoutPosEventSalesInput>
    create: XOR<CustomerCreateWithoutPosEventSalesInput, CustomerUncheckedCreateWithoutPosEventSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPosEventSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPosEventSalesInput, CustomerUncheckedUpdateWithoutPosEventSalesInput>
  }

  export type CustomerUpdateWithoutPosEventSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    sales?: SaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPosEventSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PosEventUpsertWithoutSaleInput = {
    update: XOR<PosEventUpdateWithoutSaleInput, PosEventUncheckedUpdateWithoutSaleInput>
    create: XOR<PosEventCreateWithoutSaleInput, PosEventUncheckedCreateWithoutSaleInput>
    where?: PosEventWhereInput
  }

  export type PosEventUpdateToOneWithWhereWithoutSaleInput = {
    where?: PosEventWhereInput
    data: XOR<PosEventUpdateWithoutSaleInput, PosEventUncheckedUpdateWithoutSaleInput>
  }

  export type PosEventUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entry?: PosEventEntryUpdateOneWithoutPosEventNestedInput
    output?: PosEventOutputUpdateOneWithoutPosEventNestedInput
  }

  export type PosEventUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEPosEventTypeFieldUpdateOperationsInput | $Enums.EPosEventType
    status?: EnumEPosEventStatusFieldUpdateOperationsInput | $Enums.EPosEventStatus
    posId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    entry?: PosEventEntryUncheckedUpdateOneWithoutPosEventNestedInput
    output?: PosEventOutputUncheckedUpdateOneWithoutPosEventNestedInput
  }

  export type PosEventSaleProductUpsertWithWhereUniqueWithoutPosEventSaleInput = {
    where: PosEventSaleProductWhereUniqueInput
    update: XOR<PosEventSaleProductUpdateWithoutPosEventSaleInput, PosEventSaleProductUncheckedUpdateWithoutPosEventSaleInput>
    create: XOR<PosEventSaleProductCreateWithoutPosEventSaleInput, PosEventSaleProductUncheckedCreateWithoutPosEventSaleInput>
  }

  export type PosEventSaleProductUpdateWithWhereUniqueWithoutPosEventSaleInput = {
    where: PosEventSaleProductWhereUniqueInput
    data: XOR<PosEventSaleProductUpdateWithoutPosEventSaleInput, PosEventSaleProductUncheckedUpdateWithoutPosEventSaleInput>
  }

  export type PosEventSaleProductUpdateManyWithWhereWithoutPosEventSaleInput = {
    where: PosEventSaleProductScalarWhereInput
    data: XOR<PosEventSaleProductUpdateManyMutationInput, PosEventSaleProductUncheckedUpdateManyWithoutPosEventSaleInput>
  }

  export type PosEventSaleProductScalarWhereInput = {
    AND?: PosEventSaleProductScalarWhereInput | PosEventSaleProductScalarWhereInput[]
    OR?: PosEventSaleProductScalarWhereInput[]
    NOT?: PosEventSaleProductScalarWhereInput | PosEventSaleProductScalarWhereInput[]
    id?: UuidFilter<"PosEventSaleProduct"> | string
    name?: StringFilter<"PosEventSaleProduct"> | string
    description?: StringFilter<"PosEventSaleProduct"> | string
    costPrice?: DecimalFilter<"PosEventSaleProduct"> | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFilter<"PosEventSaleProduct"> | Decimal | DecimalJsLike | number | string
    totalQty?: IntFilter<"PosEventSaleProduct"> | number
    createdAt?: DateTimeFilter<"PosEventSaleProduct"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleProduct"> | Date | string
    productId?: UuidFilter<"PosEventSaleProduct"> | string
  }

  export type PosEventSaleMovementUpsertWithWhereUniqueWithoutPosEventSaleInput = {
    where: PosEventSaleMovementWhereUniqueInput
    update: XOR<PosEventSaleMovementUpdateWithoutPosEventSaleInput, PosEventSaleMovementUncheckedUpdateWithoutPosEventSaleInput>
    create: XOR<PosEventSaleMovementCreateWithoutPosEventSaleInput, PosEventSaleMovementUncheckedCreateWithoutPosEventSaleInput>
  }

  export type PosEventSaleMovementUpdateWithWhereUniqueWithoutPosEventSaleInput = {
    where: PosEventSaleMovementWhereUniqueInput
    data: XOR<PosEventSaleMovementUpdateWithoutPosEventSaleInput, PosEventSaleMovementUncheckedUpdateWithoutPosEventSaleInput>
  }

  export type PosEventSaleMovementUpdateManyWithWhereWithoutPosEventSaleInput = {
    where: PosEventSaleMovementScalarWhereInput
    data: XOR<PosEventSaleMovementUpdateManyMutationInput, PosEventSaleMovementUncheckedUpdateManyWithoutPosEventSaleInput>
  }

  export type PosEventSaleMovementScalarWhereInput = {
    AND?: PosEventSaleMovementScalarWhereInput | PosEventSaleMovementScalarWhereInput[]
    OR?: PosEventSaleMovementScalarWhereInput[]
    NOT?: PosEventSaleMovementScalarWhereInput | PosEventSaleMovementScalarWhereInput[]
    id?: UuidFilter<"PosEventSaleMovement"> | string
    type?: EnumESaleMovementTypeFilter<"PosEventSaleMovement"> | $Enums.ESaleMovementType
    createdAt?: DateTimeFilter<"PosEventSaleMovement"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovement"> | Date | string
    posEventSaleId?: UuidFilter<"PosEventSaleMovement"> | string
  }

  export type PosEventSaleCreateWithoutMovementsInput = {
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    sale: SaleCreateNestedOneWithoutPosEventSaleInput
    customer: CustomerCreateNestedOneWithoutPosEventSalesInput
    posEvent: PosEventCreateNestedOneWithoutSaleInput
    products?: PosEventSaleProductCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleUncheckedCreateWithoutMovementsInput = {
    id: string
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    customerId: string
    saleId: string
    products?: PosEventSaleProductUncheckedCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleCreateOrConnectWithoutMovementsInput = {
    where: PosEventSaleWhereUniqueInput
    create: XOR<PosEventSaleCreateWithoutMovementsInput, PosEventSaleUncheckedCreateWithoutMovementsInput>
  }

  export type PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementPaymentCreateOrConnectWithoutPosEventSaleMovementInput = {
    where: PosEventSaleMovementPaymentWhereUniqueInput
    create: XOR<PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput>
  }

  export type PosEventSaleMovementPaymentCreateManyPosEventSaleMovementInputEnvelope = {
    data: PosEventSaleMovementPaymentCreateManyPosEventSaleMovementInput | PosEventSaleMovementPaymentCreateManyPosEventSaleMovementInput[]
    skipDuplicates?: boolean
  }

  export type PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementChangeCreateOrConnectWithoutPosEventSaleMovementInput = {
    where: PosEventSaleMovementChangeWhereUniqueInput
    create: XOR<PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput>
  }

  export type PosEventSaleMovementChangeCreateManyPosEventSaleMovementInputEnvelope = {
    data: PosEventSaleMovementChangeCreateManyPosEventSaleMovementInput | PosEventSaleMovementChangeCreateManyPosEventSaleMovementInput[]
    skipDuplicates?: boolean
  }

  export type PosEventSaleUpsertWithoutMovementsInput = {
    update: XOR<PosEventSaleUpdateWithoutMovementsInput, PosEventSaleUncheckedUpdateWithoutMovementsInput>
    create: XOR<PosEventSaleCreateWithoutMovementsInput, PosEventSaleUncheckedCreateWithoutMovementsInput>
    where?: PosEventSaleWhereInput
  }

  export type PosEventSaleUpdateToOneWithWhereWithoutMovementsInput = {
    where?: PosEventSaleWhereInput
    data: XOR<PosEventSaleUpdateWithoutMovementsInput, PosEventSaleUncheckedUpdateWithoutMovementsInput>
  }

  export type PosEventSaleUpdateWithoutMovementsInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    sale?: SaleUpdateOneRequiredWithoutPosEventSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPosEventSalesNestedInput
    posEvent?: PosEventUpdateOneRequiredWithoutSaleNestedInput
    products?: PosEventSaleProductUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    products?: PosEventSaleProductUncheckedUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleMovementPaymentUpsertWithWhereUniqueWithoutPosEventSaleMovementInput = {
    where: PosEventSaleMovementPaymentWhereUniqueInput
    update: XOR<PosEventSaleMovementPaymentUpdateWithoutPosEventSaleMovementInput, PosEventSaleMovementPaymentUncheckedUpdateWithoutPosEventSaleMovementInput>
    create: XOR<PosEventSaleMovementPaymentCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementPaymentUncheckedCreateWithoutPosEventSaleMovementInput>
  }

  export type PosEventSaleMovementPaymentUpdateWithWhereUniqueWithoutPosEventSaleMovementInput = {
    where: PosEventSaleMovementPaymentWhereUniqueInput
    data: XOR<PosEventSaleMovementPaymentUpdateWithoutPosEventSaleMovementInput, PosEventSaleMovementPaymentUncheckedUpdateWithoutPosEventSaleMovementInput>
  }

  export type PosEventSaleMovementPaymentUpdateManyWithWhereWithoutPosEventSaleMovementInput = {
    where: PosEventSaleMovementPaymentScalarWhereInput
    data: XOR<PosEventSaleMovementPaymentUpdateManyMutationInput, PosEventSaleMovementPaymentUncheckedUpdateManyWithoutPosEventSaleMovementInput>
  }

  export type PosEventSaleMovementPaymentScalarWhereInput = {
    AND?: PosEventSaleMovementPaymentScalarWhereInput | PosEventSaleMovementPaymentScalarWhereInput[]
    OR?: PosEventSaleMovementPaymentScalarWhereInput[]
    NOT?: PosEventSaleMovementPaymentScalarWhereInput | PosEventSaleMovementPaymentScalarWhereInput[]
    id?: UuidFilter<"PosEventSaleMovementPayment"> | string
    method?: EnumEPaymentMethodFilter<"PosEventSaleMovementPayment"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"PosEventSaleMovementPayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PosEventSaleMovementPayment"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovementPayment"> | Date | string
  }

  export type PosEventSaleMovementChangeUpsertWithWhereUniqueWithoutPosEventSaleMovementInput = {
    where: PosEventSaleMovementChangeWhereUniqueInput
    update: XOR<PosEventSaleMovementChangeUpdateWithoutPosEventSaleMovementInput, PosEventSaleMovementChangeUncheckedUpdateWithoutPosEventSaleMovementInput>
    create: XOR<PosEventSaleMovementChangeCreateWithoutPosEventSaleMovementInput, PosEventSaleMovementChangeUncheckedCreateWithoutPosEventSaleMovementInput>
  }

  export type PosEventSaleMovementChangeUpdateWithWhereUniqueWithoutPosEventSaleMovementInput = {
    where: PosEventSaleMovementChangeWhereUniqueInput
    data: XOR<PosEventSaleMovementChangeUpdateWithoutPosEventSaleMovementInput, PosEventSaleMovementChangeUncheckedUpdateWithoutPosEventSaleMovementInput>
  }

  export type PosEventSaleMovementChangeUpdateManyWithWhereWithoutPosEventSaleMovementInput = {
    where: PosEventSaleMovementChangeScalarWhereInput
    data: XOR<PosEventSaleMovementChangeUpdateManyMutationInput, PosEventSaleMovementChangeUncheckedUpdateManyWithoutPosEventSaleMovementInput>
  }

  export type PosEventSaleMovementChangeScalarWhereInput = {
    AND?: PosEventSaleMovementChangeScalarWhereInput | PosEventSaleMovementChangeScalarWhereInput[]
    OR?: PosEventSaleMovementChangeScalarWhereInput[]
    NOT?: PosEventSaleMovementChangeScalarWhereInput | PosEventSaleMovementChangeScalarWhereInput[]
    id?: UuidFilter<"PosEventSaleMovementChange"> | string
    method?: EnumEPaymentMethodFilter<"PosEventSaleMovementChange"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"PosEventSaleMovementChange"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PosEventSaleMovementChange"> | Date | string
    updatedAt?: DateTimeFilter<"PosEventSaleMovementChange"> | Date | string
  }

  export type PosEventSaleMovementCreateWithoutPaymentsInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSale: PosEventSaleCreateNestedOneWithoutMovementsInput
    changes?: PosEventSaleMovementChangeCreateNestedManyWithoutPosEventSaleMovementInput
  }

  export type PosEventSaleMovementUncheckedCreateWithoutPaymentsInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSaleId: string
    changes?: PosEventSaleMovementChangeUncheckedCreateNestedManyWithoutPosEventSaleMovementInput
  }

  export type PosEventSaleMovementCreateOrConnectWithoutPaymentsInput = {
    where: PosEventSaleMovementWhereUniqueInput
    create: XOR<PosEventSaleMovementCreateWithoutPaymentsInput, PosEventSaleMovementUncheckedCreateWithoutPaymentsInput>
  }

  export type PosEventSaleMovementUpsertWithoutPaymentsInput = {
    update: XOR<PosEventSaleMovementUpdateWithoutPaymentsInput, PosEventSaleMovementUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PosEventSaleMovementCreateWithoutPaymentsInput, PosEventSaleMovementUncheckedCreateWithoutPaymentsInput>
    where?: PosEventSaleMovementWhereInput
  }

  export type PosEventSaleMovementUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PosEventSaleMovementWhereInput
    data: XOR<PosEventSaleMovementUpdateWithoutPaymentsInput, PosEventSaleMovementUncheckedUpdateWithoutPaymentsInput>
  }

  export type PosEventSaleMovementUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSale?: PosEventSaleUpdateOneRequiredWithoutMovementsNestedInput
    changes?: PosEventSaleMovementChangeUpdateManyWithoutPosEventSaleMovementNestedInput
  }

  export type PosEventSaleMovementUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSaleId?: StringFieldUpdateOperationsInput | string
    changes?: PosEventSaleMovementChangeUncheckedUpdateManyWithoutPosEventSaleMovementNestedInput
  }

  export type PosEventSaleMovementCreateWithoutChangesInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSale: PosEventSaleCreateNestedOneWithoutMovementsInput
    payments?: PosEventSaleMovementPaymentCreateNestedManyWithoutPosEventSaleMovementInput
  }

  export type PosEventSaleMovementUncheckedCreateWithoutChangesInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSaleId: string
    payments?: PosEventSaleMovementPaymentUncheckedCreateNestedManyWithoutPosEventSaleMovementInput
  }

  export type PosEventSaleMovementCreateOrConnectWithoutChangesInput = {
    where: PosEventSaleMovementWhereUniqueInput
    create: XOR<PosEventSaleMovementCreateWithoutChangesInput, PosEventSaleMovementUncheckedCreateWithoutChangesInput>
  }

  export type PosEventSaleMovementUpsertWithoutChangesInput = {
    update: XOR<PosEventSaleMovementUpdateWithoutChangesInput, PosEventSaleMovementUncheckedUpdateWithoutChangesInput>
    create: XOR<PosEventSaleMovementCreateWithoutChangesInput, PosEventSaleMovementUncheckedCreateWithoutChangesInput>
    where?: PosEventSaleMovementWhereInput
  }

  export type PosEventSaleMovementUpdateToOneWithWhereWithoutChangesInput = {
    where?: PosEventSaleMovementWhereInput
    data: XOR<PosEventSaleMovementUpdateWithoutChangesInput, PosEventSaleMovementUncheckedUpdateWithoutChangesInput>
  }

  export type PosEventSaleMovementUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSale?: PosEventSaleUpdateOneRequiredWithoutMovementsNestedInput
    payments?: PosEventSaleMovementPaymentUpdateManyWithoutPosEventSaleMovementNestedInput
  }

  export type PosEventSaleMovementUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSaleId?: StringFieldUpdateOperationsInput | string
    payments?: PosEventSaleMovementPaymentUncheckedUpdateManyWithoutPosEventSaleMovementNestedInput
  }

  export type PosEventSaleCreateWithoutProductsInput = {
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    sale: SaleCreateNestedOneWithoutPosEventSaleInput
    customer: CustomerCreateNestedOneWithoutPosEventSalesInput
    posEvent: PosEventCreateNestedOneWithoutSaleInput
    movements?: PosEventSaleMovementCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleUncheckedCreateWithoutProductsInput = {
    id: string
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    customerId: string
    saleId: string
    movements?: PosEventSaleMovementUncheckedCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleCreateOrConnectWithoutProductsInput = {
    where: PosEventSaleWhereUniqueInput
    create: XOR<PosEventSaleCreateWithoutProductsInput, PosEventSaleUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutPosEventSaleProductInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockCreateNestedOneWithoutProductInput
    Tenant: TenantCreateNestedOneWithoutProductsInput
    saleProducts?: SaleProductCreateNestedManyWithoutProductInput
    specifications?: ProductSpecificationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPosEventSaleProductInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    tenantId: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    saleProducts?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    specifications?: ProductSpecificationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPosEventSaleProductInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPosEventSaleProductInput, ProductUncheckedCreateWithoutPosEventSaleProductInput>
  }

  export type PosEventSaleUpsertWithoutProductsInput = {
    update: XOR<PosEventSaleUpdateWithoutProductsInput, PosEventSaleUncheckedUpdateWithoutProductsInput>
    create: XOR<PosEventSaleCreateWithoutProductsInput, PosEventSaleUncheckedCreateWithoutProductsInput>
    where?: PosEventSaleWhereInput
  }

  export type PosEventSaleUpdateToOneWithWhereWithoutProductsInput = {
    where?: PosEventSaleWhereInput
    data: XOR<PosEventSaleUpdateWithoutProductsInput, PosEventSaleUncheckedUpdateWithoutProductsInput>
  }

  export type PosEventSaleUpdateWithoutProductsInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    sale?: SaleUpdateOneRequiredWithoutPosEventSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutPosEventSalesNestedInput
    posEvent?: PosEventUpdateOneRequiredWithoutSaleNestedInput
    movements?: PosEventSaleMovementUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    saleId?: StringFieldUpdateOperationsInput | string
    movements?: PosEventSaleMovementUncheckedUpdateManyWithoutPosEventSaleNestedInput
  }

  export type ProductUpsertWithoutPosEventSaleProductInput = {
    update: XOR<ProductUpdateWithoutPosEventSaleProductInput, ProductUncheckedUpdateWithoutPosEventSaleProductInput>
    create: XOR<ProductCreateWithoutPosEventSaleProductInput, ProductUncheckedCreateWithoutPosEventSaleProductInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPosEventSaleProductInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPosEventSaleProductInput, ProductUncheckedUpdateWithoutPosEventSaleProductInput>
  }

  export type ProductUpdateWithoutPosEventSaleProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUpdateOneWithoutProductNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    saleProducts?: SaleProductUpdateManyWithoutProductNestedInput
    specifications?: ProductSpecificationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPosEventSaleProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    saleProducts?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    specifications?: ProductSpecificationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StockCreateWithoutProductInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    totalQty?: number
    availableQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStocksInput
    lots?: StockLotCreateNestedManyWithoutStockInput
    StockEvent?: StockEventCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutProductInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    totalQty?: number
    availableQty?: number
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: StockLotUncheckedCreateNestedManyWithoutStockInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutProductInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
  }

  export type TenantCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutProductsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
  }

  export type SaleProductCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutProductsInput
    stockLot: StockLotCreateNestedOneWithoutSaleProductInput
  }

  export type SaleProductUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    stockLotId: string
  }

  export type SaleProductCreateOrConnectWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    create: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput>
  }

  export type SaleProductCreateManyProductInputEnvelope = {
    data: SaleProductCreateManyProductInput | SaleProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductSpecificationCreateWithoutProductInput = {
    id?: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSpecificationUncheckedCreateWithoutProductInput = {
    id?: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductSpecificationCreateOrConnectWithoutProductInput = {
    where: ProductSpecificationWhereUniqueInput
    create: XOR<ProductSpecificationCreateWithoutProductInput, ProductSpecificationUncheckedCreateWithoutProductInput>
  }

  export type ProductSpecificationCreateManyProductInputEnvelope = {
    data: ProductSpecificationCreateManyProductInput | ProductSpecificationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PosEventSaleProductCreateWithoutProductInput = {
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posEventSale?: PosEventSaleCreateNestedOneWithoutProductsInput
  }

  export type PosEventSaleProductUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleProductCreateOrConnectWithoutProductInput = {
    where: PosEventSaleProductWhereUniqueInput
    create: XOR<PosEventSaleProductCreateWithoutProductInput, PosEventSaleProductUncheckedCreateWithoutProductInput>
  }

  export type PosEventSaleProductCreateManyProductInputEnvelope = {
    data: PosEventSaleProductCreateManyProductInput | PosEventSaleProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StockUpsertWithoutProductInput = {
    update: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
    create: XOR<StockCreateWithoutProductInput, StockUncheckedCreateWithoutProductInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutProductInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutProductInput, StockUncheckedUpdateWithoutProductInput>
  }

  export type StockUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStocksNestedInput
    lots?: StockLotUpdateManyWithoutStockNestedInput
    StockEvent?: StockEventUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: StockLotUncheckedUpdateManyWithoutStockNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutStockNestedInput
  }

  export type TenantUpsertWithoutProductsInput = {
    update: XOR<TenantUpdateWithoutProductsInput, TenantUncheckedUpdateWithoutProductsInput>
    create: XOR<TenantCreateWithoutProductsInput, TenantUncheckedCreateWithoutProductsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutProductsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutProductsInput, TenantUncheckedUpdateWithoutProductsInput>
  }

  export type TenantUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SaleProductUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    update: XOR<SaleProductUpdateWithoutProductInput, SaleProductUncheckedUpdateWithoutProductInput>
    create: XOR<SaleProductCreateWithoutProductInput, SaleProductUncheckedCreateWithoutProductInput>
  }

  export type SaleProductUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleProductWhereUniqueInput
    data: XOR<SaleProductUpdateWithoutProductInput, SaleProductUncheckedUpdateWithoutProductInput>
  }

  export type SaleProductUpdateManyWithWhereWithoutProductInput = {
    where: SaleProductScalarWhereInput
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleProductScalarWhereInput = {
    AND?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
    OR?: SaleProductScalarWhereInput[]
    NOT?: SaleProductScalarWhereInput | SaleProductScalarWhereInput[]
    id?: UuidFilter<"SaleProduct"> | string
    name?: StringFilter<"SaleProduct"> | string
    description?: StringFilter<"SaleProduct"> | string
    costPrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFilter<"SaleProduct"> | Decimal | DecimalJsLike | number | string
    totalQty?: IntFilter<"SaleProduct"> | number
    createdAt?: DateTimeFilter<"SaleProduct"> | Date | string
    updatedAt?: DateTimeFilter<"SaleProduct"> | Date | string
    saleId?: UuidFilter<"SaleProduct"> | string
    productId?: UuidFilter<"SaleProduct"> | string
    stockLotId?: UuidFilter<"SaleProduct"> | string
  }

  export type ProductSpecificationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductSpecificationWhereUniqueInput
    update: XOR<ProductSpecificationUpdateWithoutProductInput, ProductSpecificationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductSpecificationCreateWithoutProductInput, ProductSpecificationUncheckedCreateWithoutProductInput>
  }

  export type ProductSpecificationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductSpecificationWhereUniqueInput
    data: XOR<ProductSpecificationUpdateWithoutProductInput, ProductSpecificationUncheckedUpdateWithoutProductInput>
  }

  export type ProductSpecificationUpdateManyWithWhereWithoutProductInput = {
    where: ProductSpecificationScalarWhereInput
    data: XOR<ProductSpecificationUpdateManyMutationInput, ProductSpecificationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductSpecificationScalarWhereInput = {
    AND?: ProductSpecificationScalarWhereInput | ProductSpecificationScalarWhereInput[]
    OR?: ProductSpecificationScalarWhereInput[]
    NOT?: ProductSpecificationScalarWhereInput | ProductSpecificationScalarWhereInput[]
    id?: UuidFilter<"ProductSpecification"> | string
    label?: StringFilter<"ProductSpecification"> | string
    value?: StringFilter<"ProductSpecification"> | string
    productId?: UuidFilter<"ProductSpecification"> | string
    createdAt?: DateTimeFilter<"ProductSpecification"> | Date | string
    updatedAt?: DateTimeFilter<"ProductSpecification"> | Date | string
  }

  export type PosEventSaleProductUpsertWithWhereUniqueWithoutProductInput = {
    where: PosEventSaleProductWhereUniqueInput
    update: XOR<PosEventSaleProductUpdateWithoutProductInput, PosEventSaleProductUncheckedUpdateWithoutProductInput>
    create: XOR<PosEventSaleProductCreateWithoutProductInput, PosEventSaleProductUncheckedCreateWithoutProductInput>
  }

  export type PosEventSaleProductUpdateWithWhereUniqueWithoutProductInput = {
    where: PosEventSaleProductWhereUniqueInput
    data: XOR<PosEventSaleProductUpdateWithoutProductInput, PosEventSaleProductUncheckedUpdateWithoutProductInput>
  }

  export type PosEventSaleProductUpdateManyWithWhereWithoutProductInput = {
    where: PosEventSaleProductScalarWhereInput
    data: XOR<PosEventSaleProductUpdateManyMutationInput, PosEventSaleProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutSpecificationsInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockCreateNestedOneWithoutProductInput
    Tenant: TenantCreateNestedOneWithoutProductsInput
    saleProducts?: SaleProductCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSpecificationsInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    tenantId: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    saleProducts?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSpecificationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSpecificationsInput, ProductUncheckedCreateWithoutSpecificationsInput>
  }

  export type ProductUpsertWithoutSpecificationsInput = {
    update: XOR<ProductUpdateWithoutSpecificationsInput, ProductUncheckedUpdateWithoutSpecificationsInput>
    create: XOR<ProductCreateWithoutSpecificationsInput, ProductUncheckedCreateWithoutSpecificationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSpecificationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSpecificationsInput, ProductUncheckedUpdateWithoutSpecificationsInput>
  }

  export type ProductUpdateWithoutSpecificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUpdateOneWithoutProductNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    saleProducts?: SaleProductUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSpecificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    saleProducts?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type SaleProductCreateWithoutSaleInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutSaleProductsInput
    stockLot: StockLotCreateNestedOneWithoutSaleProductInput
  }

  export type SaleProductUncheckedCreateWithoutSaleInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
    stockLotId: string
  }

  export type SaleProductCreateOrConnectWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    create: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput>
  }

  export type SaleProductCreateManySaleInputEnvelope = {
    data: SaleProductCreateManySaleInput | SaleProductCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleMovementCreateWithoutSaleInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: SaleMovementPaymentCreateNestedManyWithoutSaleMovementInput
    changes?: SaleMovementChangeCreateNestedManyWithoutSaleMovementInput
  }

  export type SaleMovementUncheckedCreateWithoutSaleInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: SaleMovementPaymentUncheckedCreateNestedManyWithoutSaleMovementInput
    changes?: SaleMovementChangeUncheckedCreateNestedManyWithoutSaleMovementInput
  }

  export type SaleMovementCreateOrConnectWithoutSaleInput = {
    where: SaleMovementWhereUniqueInput
    create: XOR<SaleMovementCreateWithoutSaleInput, SaleMovementUncheckedCreateWithoutSaleInput>
  }

  export type SaleMovementCreateManySaleInputEnvelope = {
    data: SaleMovementCreateManySaleInput | SaleMovementCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutSalesInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tenant: TenantCreateNestedOneWithoutCustomersInput
    posEventSales?: PosEventSaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSalesInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    posEventSales?: PosEventSaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSalesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
  }

  export type TenantCreateWithoutSalesInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSalesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSalesInput, TenantUncheckedCreateWithoutSalesInput>
  }

  export type PosEventSaleCreateWithoutSaleInput = {
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    customer: CustomerCreateNestedOneWithoutPosEventSalesInput
    posEvent: PosEventCreateNestedOneWithoutSaleInput
    products?: PosEventSaleProductCreateNestedManyWithoutPosEventSaleInput
    movements?: PosEventSaleMovementCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleUncheckedCreateWithoutSaleInput = {
    id: string
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    customerId: string
    products?: PosEventSaleProductUncheckedCreateNestedManyWithoutPosEventSaleInput
    movements?: PosEventSaleMovementUncheckedCreateNestedManyWithoutPosEventSaleInput
  }

  export type PosEventSaleCreateOrConnectWithoutSaleInput = {
    where: PosEventSaleWhereUniqueInput
    create: XOR<PosEventSaleCreateWithoutSaleInput, PosEventSaleUncheckedCreateWithoutSaleInput>
  }

  export type PosEventSaleCreateManySaleInputEnvelope = {
    data: PosEventSaleCreateManySaleInput | PosEventSaleCreateManySaleInput[]
    skipDuplicates?: boolean
  }

  export type SaleProductUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    update: XOR<SaleProductUpdateWithoutSaleInput, SaleProductUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleProductCreateWithoutSaleInput, SaleProductUncheckedCreateWithoutSaleInput>
  }

  export type SaleProductUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleProductWhereUniqueInput
    data: XOR<SaleProductUpdateWithoutSaleInput, SaleProductUncheckedUpdateWithoutSaleInput>
  }

  export type SaleProductUpdateManyWithWhereWithoutSaleInput = {
    where: SaleProductScalarWhereInput
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleMovementUpsertWithWhereUniqueWithoutSaleInput = {
    where: SaleMovementWhereUniqueInput
    update: XOR<SaleMovementUpdateWithoutSaleInput, SaleMovementUncheckedUpdateWithoutSaleInput>
    create: XOR<SaleMovementCreateWithoutSaleInput, SaleMovementUncheckedCreateWithoutSaleInput>
  }

  export type SaleMovementUpdateWithWhereUniqueWithoutSaleInput = {
    where: SaleMovementWhereUniqueInput
    data: XOR<SaleMovementUpdateWithoutSaleInput, SaleMovementUncheckedUpdateWithoutSaleInput>
  }

  export type SaleMovementUpdateManyWithWhereWithoutSaleInput = {
    where: SaleMovementScalarWhereInput
    data: XOR<SaleMovementUpdateManyMutationInput, SaleMovementUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleMovementScalarWhereInput = {
    AND?: SaleMovementScalarWhereInput | SaleMovementScalarWhereInput[]
    OR?: SaleMovementScalarWhereInput[]
    NOT?: SaleMovementScalarWhereInput | SaleMovementScalarWhereInput[]
    id?: UuidFilter<"SaleMovement"> | string
    type?: EnumESaleMovementTypeFilter<"SaleMovement"> | $Enums.ESaleMovementType
    createdAt?: DateTimeFilter<"SaleMovement"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovement"> | Date | string
    saleId?: UuidFilter<"SaleMovement"> | string
  }

  export type CustomerUpsertWithoutSalesInput = {
    update: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
    create: XOR<CustomerCreateWithoutSalesInput, CustomerUncheckedCreateWithoutSalesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSalesInput, CustomerUncheckedUpdateWithoutSalesInput>
  }

  export type CustomerUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneRequiredWithoutCustomersNestedInput
    posEventSales?: PosEventSaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posEventSales?: PosEventSaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type TenantUpsertWithoutSalesInput = {
    update: XOR<TenantUpdateWithoutSalesInput, TenantUncheckedUpdateWithoutSalesInput>
    create: XOR<TenantCreateWithoutSalesInput, TenantUncheckedCreateWithoutSalesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSalesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSalesInput, TenantUncheckedUpdateWithoutSalesInput>
  }

  export type TenantUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PosEventSaleUpsertWithWhereUniqueWithoutSaleInput = {
    where: PosEventSaleWhereUniqueInput
    update: XOR<PosEventSaleUpdateWithoutSaleInput, PosEventSaleUncheckedUpdateWithoutSaleInput>
    create: XOR<PosEventSaleCreateWithoutSaleInput, PosEventSaleUncheckedCreateWithoutSaleInput>
  }

  export type PosEventSaleUpdateWithWhereUniqueWithoutSaleInput = {
    where: PosEventSaleWhereUniqueInput
    data: XOR<PosEventSaleUpdateWithoutSaleInput, PosEventSaleUncheckedUpdateWithoutSaleInput>
  }

  export type PosEventSaleUpdateManyWithWhereWithoutSaleInput = {
    where: PosEventSaleScalarWhereInput
    data: XOR<PosEventSaleUpdateManyMutationInput, PosEventSaleUncheckedUpdateManyWithoutSaleInput>
  }

  export type SaleCreateWithoutMovementsInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductCreateNestedManyWithoutSaleInput
    customer: CustomerCreateNestedOneWithoutSalesInput
    tenant: TenantCreateNestedOneWithoutSalesInput
    PosEventSale?: PosEventSaleCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutMovementsInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    customerId: string
    tenantId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    PosEventSale?: PosEventSaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutMovementsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutMovementsInput, SaleUncheckedCreateWithoutMovementsInput>
  }

  export type SaleMovementPaymentCreateWithoutSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementPaymentCreateOrConnectWithoutSaleMovementInput = {
    where: SaleMovementPaymentWhereUniqueInput
    create: XOR<SaleMovementPaymentCreateWithoutSaleMovementInput, SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput>
  }

  export type SaleMovementPaymentCreateManySaleMovementInputEnvelope = {
    data: SaleMovementPaymentCreateManySaleMovementInput | SaleMovementPaymentCreateManySaleMovementInput[]
    skipDuplicates?: boolean
  }

  export type SaleMovementChangeCreateWithoutSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementChangeUncheckedCreateWithoutSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementChangeCreateOrConnectWithoutSaleMovementInput = {
    where: SaleMovementChangeWhereUniqueInput
    create: XOR<SaleMovementChangeCreateWithoutSaleMovementInput, SaleMovementChangeUncheckedCreateWithoutSaleMovementInput>
  }

  export type SaleMovementChangeCreateManySaleMovementInputEnvelope = {
    data: SaleMovementChangeCreateManySaleMovementInput | SaleMovementChangeCreateManySaleMovementInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithoutMovementsInput = {
    update: XOR<SaleUpdateWithoutMovementsInput, SaleUncheckedUpdateWithoutMovementsInput>
    create: XOR<SaleCreateWithoutMovementsInput, SaleUncheckedCreateWithoutMovementsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutMovementsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutMovementsInput, SaleUncheckedUpdateWithoutMovementsInput>
  }

  export type SaleUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSalesNestedInput
    PosEventSale?: PosEventSaleUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutMovementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    PosEventSale?: PosEventSaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleMovementPaymentUpsertWithWhereUniqueWithoutSaleMovementInput = {
    where: SaleMovementPaymentWhereUniqueInput
    update: XOR<SaleMovementPaymentUpdateWithoutSaleMovementInput, SaleMovementPaymentUncheckedUpdateWithoutSaleMovementInput>
    create: XOR<SaleMovementPaymentCreateWithoutSaleMovementInput, SaleMovementPaymentUncheckedCreateWithoutSaleMovementInput>
  }

  export type SaleMovementPaymentUpdateWithWhereUniqueWithoutSaleMovementInput = {
    where: SaleMovementPaymentWhereUniqueInput
    data: XOR<SaleMovementPaymentUpdateWithoutSaleMovementInput, SaleMovementPaymentUncheckedUpdateWithoutSaleMovementInput>
  }

  export type SaleMovementPaymentUpdateManyWithWhereWithoutSaleMovementInput = {
    where: SaleMovementPaymentScalarWhereInput
    data: XOR<SaleMovementPaymentUpdateManyMutationInput, SaleMovementPaymentUncheckedUpdateManyWithoutSaleMovementInput>
  }

  export type SaleMovementPaymentScalarWhereInput = {
    AND?: SaleMovementPaymentScalarWhereInput | SaleMovementPaymentScalarWhereInput[]
    OR?: SaleMovementPaymentScalarWhereInput[]
    NOT?: SaleMovementPaymentScalarWhereInput | SaleMovementPaymentScalarWhereInput[]
    id?: UuidFilter<"SaleMovementPayment"> | string
    method?: EnumEPaymentMethodFilter<"SaleMovementPayment"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"SaleMovementPayment"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleMovementPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovementPayment"> | Date | string
  }

  export type SaleMovementChangeUpsertWithWhereUniqueWithoutSaleMovementInput = {
    where: SaleMovementChangeWhereUniqueInput
    update: XOR<SaleMovementChangeUpdateWithoutSaleMovementInput, SaleMovementChangeUncheckedUpdateWithoutSaleMovementInput>
    create: XOR<SaleMovementChangeCreateWithoutSaleMovementInput, SaleMovementChangeUncheckedCreateWithoutSaleMovementInput>
  }

  export type SaleMovementChangeUpdateWithWhereUniqueWithoutSaleMovementInput = {
    where: SaleMovementChangeWhereUniqueInput
    data: XOR<SaleMovementChangeUpdateWithoutSaleMovementInput, SaleMovementChangeUncheckedUpdateWithoutSaleMovementInput>
  }

  export type SaleMovementChangeUpdateManyWithWhereWithoutSaleMovementInput = {
    where: SaleMovementChangeScalarWhereInput
    data: XOR<SaleMovementChangeUpdateManyMutationInput, SaleMovementChangeUncheckedUpdateManyWithoutSaleMovementInput>
  }

  export type SaleMovementChangeScalarWhereInput = {
    AND?: SaleMovementChangeScalarWhereInput | SaleMovementChangeScalarWhereInput[]
    OR?: SaleMovementChangeScalarWhereInput[]
    NOT?: SaleMovementChangeScalarWhereInput | SaleMovementChangeScalarWhereInput[]
    id?: UuidFilter<"SaleMovementChange"> | string
    method?: EnumEPaymentMethodFilter<"SaleMovementChange"> | $Enums.EPaymentMethod
    amount?: DecimalFilter<"SaleMovementChange"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"SaleMovementChange"> | Date | string
    updatedAt?: DateTimeFilter<"SaleMovementChange"> | Date | string
  }

  export type SaleMovementCreateWithoutPaymentsInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutMovementsInput
    changes?: SaleMovementChangeCreateNestedManyWithoutSaleMovementInput
  }

  export type SaleMovementUncheckedCreateWithoutPaymentsInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    changes?: SaleMovementChangeUncheckedCreateNestedManyWithoutSaleMovementInput
  }

  export type SaleMovementCreateOrConnectWithoutPaymentsInput = {
    where: SaleMovementWhereUniqueInput
    create: XOR<SaleMovementCreateWithoutPaymentsInput, SaleMovementUncheckedCreateWithoutPaymentsInput>
  }

  export type SaleMovementUpsertWithoutPaymentsInput = {
    update: XOR<SaleMovementUpdateWithoutPaymentsInput, SaleMovementUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SaleMovementCreateWithoutPaymentsInput, SaleMovementUncheckedCreateWithoutPaymentsInput>
    where?: SaleMovementWhereInput
  }

  export type SaleMovementUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SaleMovementWhereInput
    data: XOR<SaleMovementUpdateWithoutPaymentsInput, SaleMovementUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleMovementUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutMovementsNestedInput
    changes?: SaleMovementChangeUpdateManyWithoutSaleMovementNestedInput
  }

  export type SaleMovementUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    changes?: SaleMovementChangeUncheckedUpdateManyWithoutSaleMovementNestedInput
  }

  export type SaleMovementCreateWithoutChangesInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutMovementsInput
    payments?: SaleMovementPaymentCreateNestedManyWithoutSaleMovementInput
  }

  export type SaleMovementUncheckedCreateWithoutChangesInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    payments?: SaleMovementPaymentUncheckedCreateNestedManyWithoutSaleMovementInput
  }

  export type SaleMovementCreateOrConnectWithoutChangesInput = {
    where: SaleMovementWhereUniqueInput
    create: XOR<SaleMovementCreateWithoutChangesInput, SaleMovementUncheckedCreateWithoutChangesInput>
  }

  export type SaleMovementUpsertWithoutChangesInput = {
    update: XOR<SaleMovementUpdateWithoutChangesInput, SaleMovementUncheckedUpdateWithoutChangesInput>
    create: XOR<SaleMovementCreateWithoutChangesInput, SaleMovementUncheckedCreateWithoutChangesInput>
    where?: SaleMovementWhereInput
  }

  export type SaleMovementUpdateToOneWithWhereWithoutChangesInput = {
    where?: SaleMovementWhereInput
    data: XOR<SaleMovementUpdateWithoutChangesInput, SaleMovementUncheckedUpdateWithoutChangesInput>
  }

  export type SaleMovementUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutMovementsNestedInput
    payments?: SaleMovementPaymentUpdateManyWithoutSaleMovementNestedInput
  }

  export type SaleMovementUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    payments?: SaleMovementPaymentUncheckedUpdateManyWithoutSaleMovementNestedInput
  }

  export type SaleCreateWithoutProductsInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    movements?: SaleMovementCreateNestedManyWithoutSaleInput
    customer: CustomerCreateNestedOneWithoutSalesInput
    tenant: TenantCreateNestedOneWithoutSalesInput
    PosEventSale?: PosEventSaleCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutProductsInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    customerId: string
    tenantId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    movements?: SaleMovementUncheckedCreateNestedManyWithoutSaleInput
    PosEventSale?: PosEventSaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutProductsInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutSaleProductsInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockCreateNestedOneWithoutProductInput
    Tenant: TenantCreateNestedOneWithoutProductsInput
    specifications?: ProductSpecificationCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSaleProductsInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    tenantId: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    specifications?: ProductSpecificationUncheckedCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSaleProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSaleProductsInput, ProductUncheckedCreateWithoutSaleProductsInput>
  }

  export type StockLotCreateWithoutSaleProductInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutLotsInput
    tenant: TenantCreateNestedOneWithoutStockLotsInput
    stockEvents?: StockEventCreateNestedManyWithoutStockLotInput
  }

  export type StockLotUncheckedCreateWithoutSaleProductInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    stockId: string
    tenantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockEvents?: StockEventUncheckedCreateNestedManyWithoutStockLotInput
  }

  export type StockLotCreateOrConnectWithoutSaleProductInput = {
    where: StockLotWhereUniqueInput
    create: XOR<StockLotCreateWithoutSaleProductInput, StockLotUncheckedCreateWithoutSaleProductInput>
  }

  export type SaleUpsertWithoutProductsInput = {
    update: XOR<SaleUpdateWithoutProductsInput, SaleUncheckedUpdateWithoutProductsInput>
    create: XOR<SaleCreateWithoutProductsInput, SaleUncheckedCreateWithoutProductsInput>
    where?: SaleWhereInput
  }

  export type SaleUpdateToOneWithWhereWithoutProductsInput = {
    where?: SaleWhereInput
    data: XOR<SaleUpdateWithoutProductsInput, SaleUncheckedUpdateWithoutProductsInput>
  }

  export type SaleUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    movements?: SaleMovementUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSalesNestedInput
    PosEventSale?: PosEventSaleUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    movements?: SaleMovementUncheckedUpdateManyWithoutSaleNestedInput
    PosEventSale?: PosEventSaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type ProductUpsertWithoutSaleProductsInput = {
    update: XOR<ProductUpdateWithoutSaleProductsInput, ProductUncheckedUpdateWithoutSaleProductsInput>
    create: XOR<ProductCreateWithoutSaleProductsInput, ProductUncheckedCreateWithoutSaleProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSaleProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSaleProductsInput, ProductUncheckedUpdateWithoutSaleProductsInput>
  }

  export type ProductUpdateWithoutSaleProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUpdateOneWithoutProductNestedInput
    Tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    specifications?: ProductSpecificationUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSaleProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    specifications?: ProductSpecificationUncheckedUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StockLotUpsertWithoutSaleProductInput = {
    update: XOR<StockLotUpdateWithoutSaleProductInput, StockLotUncheckedUpdateWithoutSaleProductInput>
    create: XOR<StockLotCreateWithoutSaleProductInput, StockLotUncheckedCreateWithoutSaleProductInput>
    where?: StockLotWhereInput
  }

  export type StockLotUpdateToOneWithWhereWithoutSaleProductInput = {
    where?: StockLotWhereInput
    data: XOR<StockLotUpdateWithoutSaleProductInput, StockLotUncheckedUpdateWithoutSaleProductInput>
  }

  export type StockLotUpdateWithoutSaleProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutLotsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStockLotsNestedInput
    stockEvents?: StockEventUpdateManyWithoutStockLotNestedInput
  }

  export type StockLotUncheckedUpdateWithoutSaleProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockEvents?: StockEventUncheckedUpdateManyWithoutStockLotNestedInput
  }

  export type TenantCreateWithoutStocksInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStocksInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStocksInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStocksInput, TenantUncheckedCreateWithoutStocksInput>
  }

  export type ProductCreateWithoutStockInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    Tenant: TenantCreateNestedOneWithoutProductsInput
    saleProducts?: SaleProductCreateNestedManyWithoutProductInput
    specifications?: ProductSpecificationCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStockInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    tenantId: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    saleProducts?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    specifications?: ProductSpecificationUncheckedCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStockInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
  }

  export type StockLotCreateWithoutStockInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockLotsInput
    stockEvents?: StockEventCreateNestedManyWithoutStockLotInput
    saleProduct?: SaleProductCreateNestedManyWithoutStockLotInput
  }

  export type StockLotUncheckedCreateWithoutStockInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    tenantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockEvents?: StockEventUncheckedCreateNestedManyWithoutStockLotInput
    saleProduct?: SaleProductUncheckedCreateNestedManyWithoutStockLotInput
  }

  export type StockLotCreateOrConnectWithoutStockInput = {
    where: StockLotWhereUniqueInput
    create: XOR<StockLotCreateWithoutStockInput, StockLotUncheckedCreateWithoutStockInput>
  }

  export type StockLotCreateManyStockInputEnvelope = {
    data: StockLotCreateManyStockInput | StockLotCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type StockEventCreateWithoutStockInput = {
    id?: string
    type: $Enums.EStockEventType
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStockEventInput
    entry?: StockEventEntryCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputCreateNestedOneWithoutStockEventInput
    StockLot?: StockLotCreateNestedOneWithoutStockEventsInput
  }

  export type StockEventUncheckedCreateWithoutStockInput = {
    id?: string
    type: $Enums.EStockEventType
    tenantId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLotId?: string | null
    entry?: StockEventEntryUncheckedCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputUncheckedCreateNestedOneWithoutStockEventInput
  }

  export type StockEventCreateOrConnectWithoutStockInput = {
    where: StockEventWhereUniqueInput
    create: XOR<StockEventCreateWithoutStockInput, StockEventUncheckedCreateWithoutStockInput>
  }

  export type StockEventCreateManyStockInputEnvelope = {
    data: StockEventCreateManyStockInput | StockEventCreateManyStockInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutStocksInput = {
    update: XOR<TenantUpdateWithoutStocksInput, TenantUncheckedUpdateWithoutStocksInput>
    create: XOR<TenantCreateWithoutStocksInput, TenantUncheckedCreateWithoutStocksInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStocksInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStocksInput, TenantUncheckedUpdateWithoutStocksInput>
  }

  export type TenantUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ProductUpsertWithoutStockInput = {
    update: XOR<ProductUpdateWithoutStockInput, ProductUncheckedUpdateWithoutStockInput>
    create: XOR<ProductCreateWithoutStockInput, ProductUncheckedCreateWithoutStockInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStockInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStockInput, ProductUncheckedUpdateWithoutStockInput>
  }

  export type ProductUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Tenant?: TenantUpdateOneRequiredWithoutProductsNestedInput
    saleProducts?: SaleProductUpdateManyWithoutProductNestedInput
    specifications?: ProductSpecificationUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    saleProducts?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    specifications?: ProductSpecificationUncheckedUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StockLotUpsertWithWhereUniqueWithoutStockInput = {
    where: StockLotWhereUniqueInput
    update: XOR<StockLotUpdateWithoutStockInput, StockLotUncheckedUpdateWithoutStockInput>
    create: XOR<StockLotCreateWithoutStockInput, StockLotUncheckedCreateWithoutStockInput>
  }

  export type StockLotUpdateWithWhereUniqueWithoutStockInput = {
    where: StockLotWhereUniqueInput
    data: XOR<StockLotUpdateWithoutStockInput, StockLotUncheckedUpdateWithoutStockInput>
  }

  export type StockLotUpdateManyWithWhereWithoutStockInput = {
    where: StockLotScalarWhereInput
    data: XOR<StockLotUpdateManyMutationInput, StockLotUncheckedUpdateManyWithoutStockInput>
  }

  export type StockLotScalarWhereInput = {
    AND?: StockLotScalarWhereInput | StockLotScalarWhereInput[]
    OR?: StockLotScalarWhereInput[]
    NOT?: StockLotScalarWhereInput | StockLotScalarWhereInput[]
    id?: UuidFilter<"StockLot"> | string
    lotNumber?: StringFilter<"StockLot"> | string
    totalQty?: IntFilter<"StockLot"> | number
    costPrice?: DecimalFilter<"StockLot"> | Decimal | DecimalJsLike | number | string
    stockId?: UuidFilter<"StockLot"> | string
    tenantId?: UuidFilter<"StockLot"> | string
    expiresAt?: DateTimeNullableFilter<"StockLot"> | Date | string | null
    createdAt?: DateTimeFilter<"StockLot"> | Date | string
    updatedAt?: DateTimeFilter<"StockLot"> | Date | string
  }

  export type StockEventUpsertWithWhereUniqueWithoutStockInput = {
    where: StockEventWhereUniqueInput
    update: XOR<StockEventUpdateWithoutStockInput, StockEventUncheckedUpdateWithoutStockInput>
    create: XOR<StockEventCreateWithoutStockInput, StockEventUncheckedCreateWithoutStockInput>
  }

  export type StockEventUpdateWithWhereUniqueWithoutStockInput = {
    where: StockEventWhereUniqueInput
    data: XOR<StockEventUpdateWithoutStockInput, StockEventUncheckedUpdateWithoutStockInput>
  }

  export type StockEventUpdateManyWithWhereWithoutStockInput = {
    where: StockEventScalarWhereInput
    data: XOR<StockEventUpdateManyMutationInput, StockEventUncheckedUpdateManyWithoutStockInput>
  }

  export type StockEventScalarWhereInput = {
    AND?: StockEventScalarWhereInput | StockEventScalarWhereInput[]
    OR?: StockEventScalarWhereInput[]
    NOT?: StockEventScalarWhereInput | StockEventScalarWhereInput[]
    id?: UuidFilter<"StockEvent"> | string
    type?: EnumEStockEventTypeFilter<"StockEvent"> | $Enums.EStockEventType
    stockId?: UuidFilter<"StockEvent"> | string
    tenantId?: UuidFilter<"StockEvent"> | string
    description?: StringFilter<"StockEvent"> | string
    createdAt?: DateTimeFilter<"StockEvent"> | Date | string
    updatedAt?: DateTimeFilter<"StockEvent"> | Date | string
    stockLotId?: UuidNullableFilter<"StockEvent"> | string | null
  }

  export type StockCreateWithoutStockEventInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    totalQty?: number
    availableQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStocksInput
    product: ProductCreateNestedOneWithoutStockInput
    lots?: StockLotCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutStockEventInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    productId: string
    totalQty?: number
    availableQty?: number
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: StockLotUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutStockEventInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutStockEventInput, StockUncheckedCreateWithoutStockEventInput>
  }

  export type TenantCreateWithoutStockEventInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStockEventInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStockEventInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStockEventInput, TenantUncheckedCreateWithoutStockEventInput>
  }

  export type StockEventEntryCreateWithoutStockEventInput = {
    quantity: number
    description?: string
  }

  export type StockEventEntryUncheckedCreateWithoutStockEventInput = {
    quantity: number
    description?: string
  }

  export type StockEventEntryCreateOrConnectWithoutStockEventInput = {
    where: StockEventEntryWhereUniqueInput
    create: XOR<StockEventEntryCreateWithoutStockEventInput, StockEventEntryUncheckedCreateWithoutStockEventInput>
  }

  export type StockEventOutputCreateWithoutStockEventInput = {
    quantity: number
    description?: string
  }

  export type StockEventOutputUncheckedCreateWithoutStockEventInput = {
    quantity: number
    description?: string
  }

  export type StockEventOutputCreateOrConnectWithoutStockEventInput = {
    where: StockEventOutputWhereUniqueInput
    create: XOR<StockEventOutputCreateWithoutStockEventInput, StockEventOutputUncheckedCreateWithoutStockEventInput>
  }

  export type StockLotCreateWithoutStockEventsInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutLotsInput
    tenant: TenantCreateNestedOneWithoutStockLotsInput
    saleProduct?: SaleProductCreateNestedManyWithoutStockLotInput
  }

  export type StockLotUncheckedCreateWithoutStockEventsInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    stockId: string
    tenantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleProduct?: SaleProductUncheckedCreateNestedManyWithoutStockLotInput
  }

  export type StockLotCreateOrConnectWithoutStockEventsInput = {
    where: StockLotWhereUniqueInput
    create: XOR<StockLotCreateWithoutStockEventsInput, StockLotUncheckedCreateWithoutStockEventsInput>
  }

  export type StockUpsertWithoutStockEventInput = {
    update: XOR<StockUpdateWithoutStockEventInput, StockUncheckedUpdateWithoutStockEventInput>
    create: XOR<StockCreateWithoutStockEventInput, StockUncheckedCreateWithoutStockEventInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutStockEventInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutStockEventInput, StockUncheckedUpdateWithoutStockEventInput>
  }

  export type StockUpdateWithoutStockEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStocksNestedInput
    product?: ProductUpdateOneRequiredWithoutStockNestedInput
    lots?: StockLotUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutStockEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    productId?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: StockLotUncheckedUpdateManyWithoutStockNestedInput
  }

  export type TenantUpsertWithoutStockEventInput = {
    update: XOR<TenantUpdateWithoutStockEventInput, TenantUncheckedUpdateWithoutStockEventInput>
    create: XOR<TenantCreateWithoutStockEventInput, TenantUncheckedCreateWithoutStockEventInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStockEventInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStockEventInput, TenantUncheckedUpdateWithoutStockEventInput>
  }

  export type TenantUpdateWithoutStockEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStockEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StockEventEntryUpsertWithoutStockEventInput = {
    update: XOR<StockEventEntryUpdateWithoutStockEventInput, StockEventEntryUncheckedUpdateWithoutStockEventInput>
    create: XOR<StockEventEntryCreateWithoutStockEventInput, StockEventEntryUncheckedCreateWithoutStockEventInput>
    where?: StockEventEntryWhereInput
  }

  export type StockEventEntryUpdateToOneWithWhereWithoutStockEventInput = {
    where?: StockEventEntryWhereInput
    data: XOR<StockEventEntryUpdateWithoutStockEventInput, StockEventEntryUncheckedUpdateWithoutStockEventInput>
  }

  export type StockEventEntryUpdateWithoutStockEventInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockEventEntryUncheckedUpdateWithoutStockEventInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockEventOutputUpsertWithoutStockEventInput = {
    update: XOR<StockEventOutputUpdateWithoutStockEventInput, StockEventOutputUncheckedUpdateWithoutStockEventInput>
    create: XOR<StockEventOutputCreateWithoutStockEventInput, StockEventOutputUncheckedCreateWithoutStockEventInput>
    where?: StockEventOutputWhereInput
  }

  export type StockEventOutputUpdateToOneWithWhereWithoutStockEventInput = {
    where?: StockEventOutputWhereInput
    data: XOR<StockEventOutputUpdateWithoutStockEventInput, StockEventOutputUncheckedUpdateWithoutStockEventInput>
  }

  export type StockEventOutputUpdateWithoutStockEventInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockEventOutputUncheckedUpdateWithoutStockEventInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StockLotUpsertWithoutStockEventsInput = {
    update: XOR<StockLotUpdateWithoutStockEventsInput, StockLotUncheckedUpdateWithoutStockEventsInput>
    create: XOR<StockLotCreateWithoutStockEventsInput, StockLotUncheckedCreateWithoutStockEventsInput>
    where?: StockLotWhereInput
  }

  export type StockLotUpdateToOneWithWhereWithoutStockEventsInput = {
    where?: StockLotWhereInput
    data: XOR<StockLotUpdateWithoutStockEventsInput, StockLotUncheckedUpdateWithoutStockEventsInput>
  }

  export type StockLotUpdateWithoutStockEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutLotsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStockLotsNestedInput
    saleProduct?: SaleProductUpdateManyWithoutStockLotNestedInput
  }

  export type StockLotUncheckedUpdateWithoutStockEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleProduct?: SaleProductUncheckedUpdateManyWithoutStockLotNestedInput
  }

  export type StockEventCreateWithoutEntryInput = {
    id?: string
    type: $Enums.EStockEventType
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutStockEventInput
    tenant: TenantCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputCreateNestedOneWithoutStockEventInput
    StockLot?: StockLotCreateNestedOneWithoutStockEventsInput
  }

  export type StockEventUncheckedCreateWithoutEntryInput = {
    id?: string
    type: $Enums.EStockEventType
    stockId: string
    tenantId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLotId?: string | null
    output?: StockEventOutputUncheckedCreateNestedOneWithoutStockEventInput
  }

  export type StockEventCreateOrConnectWithoutEntryInput = {
    where: StockEventWhereUniqueInput
    create: XOR<StockEventCreateWithoutEntryInput, StockEventUncheckedCreateWithoutEntryInput>
  }

  export type StockEventUpsertWithoutEntryInput = {
    update: XOR<StockEventUpdateWithoutEntryInput, StockEventUncheckedUpdateWithoutEntryInput>
    create: XOR<StockEventCreateWithoutEntryInput, StockEventUncheckedCreateWithoutEntryInput>
    where?: StockEventWhereInput
  }

  export type StockEventUpdateToOneWithWhereWithoutEntryInput = {
    where?: StockEventWhereInput
    data: XOR<StockEventUpdateWithoutEntryInput, StockEventUncheckedUpdateWithoutEntryInput>
  }

  export type StockEventUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutStockEventNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStockEventNestedInput
    output?: StockEventOutputUpdateOneWithoutStockEventNestedInput
    StockLot?: StockLotUpdateOneWithoutStockEventsNestedInput
  }

  export type StockEventUncheckedUpdateWithoutEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLotId?: NullableStringFieldUpdateOperationsInput | string | null
    output?: StockEventOutputUncheckedUpdateOneWithoutStockEventNestedInput
  }

  export type StockEventCreateWithoutOutputInput = {
    id?: string
    type: $Enums.EStockEventType
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutStockEventInput
    tenant: TenantCreateNestedOneWithoutStockEventInput
    entry?: StockEventEntryCreateNestedOneWithoutStockEventInput
    StockLot?: StockLotCreateNestedOneWithoutStockEventsInput
  }

  export type StockEventUncheckedCreateWithoutOutputInput = {
    id?: string
    type: $Enums.EStockEventType
    stockId: string
    tenantId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLotId?: string | null
    entry?: StockEventEntryUncheckedCreateNestedOneWithoutStockEventInput
  }

  export type StockEventCreateOrConnectWithoutOutputInput = {
    where: StockEventWhereUniqueInput
    create: XOR<StockEventCreateWithoutOutputInput, StockEventUncheckedCreateWithoutOutputInput>
  }

  export type StockEventUpsertWithoutOutputInput = {
    update: XOR<StockEventUpdateWithoutOutputInput, StockEventUncheckedUpdateWithoutOutputInput>
    create: XOR<StockEventCreateWithoutOutputInput, StockEventUncheckedCreateWithoutOutputInput>
    where?: StockEventWhereInput
  }

  export type StockEventUpdateToOneWithWhereWithoutOutputInput = {
    where?: StockEventWhereInput
    data: XOR<StockEventUpdateWithoutOutputInput, StockEventUncheckedUpdateWithoutOutputInput>
  }

  export type StockEventUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutStockEventNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStockEventNestedInput
    entry?: StockEventEntryUpdateOneWithoutStockEventNestedInput
    StockLot?: StockLotUpdateOneWithoutStockEventsNestedInput
  }

  export type StockEventUncheckedUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLotId?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: StockEventEntryUncheckedUpdateOneWithoutStockEventNestedInput
  }

  export type StockCreateWithoutLotsInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    totalQty?: number
    availableQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStocksInput
    product: ProductCreateNestedOneWithoutStockInput
    StockEvent?: StockEventCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutLotsInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    productId: string
    totalQty?: number
    availableQty?: number
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutLotsInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutLotsInput, StockUncheckedCreateWithoutLotsInput>
  }

  export type TenantCreateWithoutStockLotsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStockLotsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStockLotsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStockLotsInput, TenantUncheckedCreateWithoutStockLotsInput>
  }

  export type StockEventCreateWithoutStockLotInput = {
    id?: string
    type: $Enums.EStockEventType
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutStockEventInput
    tenant: TenantCreateNestedOneWithoutStockEventInput
    entry?: StockEventEntryCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputCreateNestedOneWithoutStockEventInput
  }

  export type StockEventUncheckedCreateWithoutStockLotInput = {
    id?: string
    type: $Enums.EStockEventType
    stockId: string
    tenantId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entry?: StockEventEntryUncheckedCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputUncheckedCreateNestedOneWithoutStockEventInput
  }

  export type StockEventCreateOrConnectWithoutStockLotInput = {
    where: StockEventWhereUniqueInput
    create: XOR<StockEventCreateWithoutStockLotInput, StockEventUncheckedCreateWithoutStockLotInput>
  }

  export type StockEventCreateManyStockLotInputEnvelope = {
    data: StockEventCreateManyStockLotInput | StockEventCreateManyStockLotInput[]
    skipDuplicates?: boolean
  }

  export type SaleProductCreateWithoutStockLotInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sale: SaleCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutSaleProductsInput
  }

  export type SaleProductUncheckedCreateWithoutStockLotInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    productId: string
  }

  export type SaleProductCreateOrConnectWithoutStockLotInput = {
    where: SaleProductWhereUniqueInput
    create: XOR<SaleProductCreateWithoutStockLotInput, SaleProductUncheckedCreateWithoutStockLotInput>
  }

  export type SaleProductCreateManyStockLotInputEnvelope = {
    data: SaleProductCreateManyStockLotInput | SaleProductCreateManyStockLotInput[]
    skipDuplicates?: boolean
  }

  export type StockUpsertWithoutLotsInput = {
    update: XOR<StockUpdateWithoutLotsInput, StockUncheckedUpdateWithoutLotsInput>
    create: XOR<StockCreateWithoutLotsInput, StockUncheckedCreateWithoutLotsInput>
    where?: StockWhereInput
  }

  export type StockUpdateToOneWithWhereWithoutLotsInput = {
    where?: StockWhereInput
    data: XOR<StockUpdateWithoutLotsInput, StockUncheckedUpdateWithoutLotsInput>
  }

  export type StockUpdateWithoutLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStocksNestedInput
    product?: ProductUpdateOneRequiredWithoutStockNestedInput
    StockEvent?: StockEventUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    productId?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    StockEvent?: StockEventUncheckedUpdateManyWithoutStockNestedInput
  }

  export type TenantUpsertWithoutStockLotsInput = {
    update: XOR<TenantUpdateWithoutStockLotsInput, TenantUncheckedUpdateWithoutStockLotsInput>
    create: XOR<TenantCreateWithoutStockLotsInput, TenantUncheckedCreateWithoutStockLotsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStockLotsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStockLotsInput, TenantUncheckedUpdateWithoutStockLotsInput>
  }

  export type TenantUpdateWithoutStockLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStockLotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StockEventUpsertWithWhereUniqueWithoutStockLotInput = {
    where: StockEventWhereUniqueInput
    update: XOR<StockEventUpdateWithoutStockLotInput, StockEventUncheckedUpdateWithoutStockLotInput>
    create: XOR<StockEventCreateWithoutStockLotInput, StockEventUncheckedCreateWithoutStockLotInput>
  }

  export type StockEventUpdateWithWhereUniqueWithoutStockLotInput = {
    where: StockEventWhereUniqueInput
    data: XOR<StockEventUpdateWithoutStockLotInput, StockEventUncheckedUpdateWithoutStockLotInput>
  }

  export type StockEventUpdateManyWithWhereWithoutStockLotInput = {
    where: StockEventScalarWhereInput
    data: XOR<StockEventUpdateManyMutationInput, StockEventUncheckedUpdateManyWithoutStockLotInput>
  }

  export type SaleProductUpsertWithWhereUniqueWithoutStockLotInput = {
    where: SaleProductWhereUniqueInput
    update: XOR<SaleProductUpdateWithoutStockLotInput, SaleProductUncheckedUpdateWithoutStockLotInput>
    create: XOR<SaleProductCreateWithoutStockLotInput, SaleProductUncheckedCreateWithoutStockLotInput>
  }

  export type SaleProductUpdateWithWhereUniqueWithoutStockLotInput = {
    where: SaleProductWhereUniqueInput
    data: XOR<SaleProductUpdateWithoutStockLotInput, SaleProductUncheckedUpdateWithoutStockLotInput>
  }

  export type SaleProductUpdateManyWithWhereWithoutStockLotInput = {
    where: SaleProductScalarWhereInput
    data: XOR<SaleProductUpdateManyMutationInput, SaleProductUncheckedUpdateManyWithoutStockLotInput>
  }

  export type TenantMembershipCreateWithoutTenantInput = {
    membership: MembershipCreateNestedOneWithoutTenant_membershipsInput
  }

  export type TenantMembershipUncheckedCreateWithoutTenantInput = {
    membershipId: string
  }

  export type TenantMembershipCreateOrConnectWithoutTenantInput = {
    where: TenantMembershipWhereUniqueInput
    create: XOR<TenantMembershipCreateWithoutTenantInput, TenantMembershipUncheckedCreateWithoutTenantInput>
  }

  export type TenantMembershipCreateManyTenantInputEnvelope = {
    data: TenantMembershipCreateManyTenantInput | TenantMembershipCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutTenantInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sales?: SaleCreateNestedManyWithoutCustomerInput
    posEventSales?: PosEventSaleCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTenantInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sales?: SaleUncheckedCreateNestedManyWithoutCustomerInput
    posEventSales?: PosEventSaleUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerCreateManyTenantInputEnvelope = {
    data: CustomerCreateManyTenantInput | CustomerCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockCreateNestedOneWithoutProductInput
    saleProducts?: SaleProductCreateNestedManyWithoutProductInput
    specifications?: ProductSpecificationCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stock?: StockUncheckedCreateNestedOneWithoutProductInput
    saleProducts?: SaleProductUncheckedCreateNestedManyWithoutProductInput
    specifications?: ProductSpecificationUncheckedCreateNestedManyWithoutProductInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTenantInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput>
  }

  export type ProductCreateManyTenantInputEnvelope = {
    data: ProductCreateManyTenantInput | ProductCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductCreateNestedManyWithoutSaleInput
    movements?: SaleMovementCreateNestedManyWithoutSaleInput
    customer: CustomerCreateNestedOneWithoutSalesInput
    PosEventSale?: PosEventSaleCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    customerId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    products?: SaleProductUncheckedCreateNestedManyWithoutSaleInput
    movements?: SaleMovementUncheckedCreateNestedManyWithoutSaleInput
    PosEventSale?: PosEventSaleUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutTenantInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutTenantInput, SaleUncheckedCreateWithoutTenantInput>
  }

  export type SaleCreateManyTenantInputEnvelope = {
    data: SaleCreateManyTenantInput | SaleCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StockCreateWithoutTenantInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    totalQty?: number
    availableQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutStockInput
    lots?: StockLotCreateNestedManyWithoutStockInput
    StockEvent?: StockEventCreateNestedManyWithoutStockInput
  }

  export type StockUncheckedCreateWithoutTenantInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    productId: string
    totalQty?: number
    availableQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lots?: StockLotUncheckedCreateNestedManyWithoutStockInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutStockInput
  }

  export type StockCreateOrConnectWithoutTenantInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutTenantInput, StockUncheckedCreateWithoutTenantInput>
  }

  export type StockCreateManyTenantInputEnvelope = {
    data: StockCreateManyTenantInput | StockCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StockLotCreateWithoutTenantInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutLotsInput
    stockEvents?: StockEventCreateNestedManyWithoutStockLotInput
    saleProduct?: SaleProductCreateNestedManyWithoutStockLotInput
  }

  export type StockLotUncheckedCreateWithoutTenantInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    stockId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stockEvents?: StockEventUncheckedCreateNestedManyWithoutStockLotInput
    saleProduct?: SaleProductUncheckedCreateNestedManyWithoutStockLotInput
  }

  export type StockLotCreateOrConnectWithoutTenantInput = {
    where: StockLotWhereUniqueInput
    create: XOR<StockLotCreateWithoutTenantInput, StockLotUncheckedCreateWithoutTenantInput>
  }

  export type StockLotCreateManyTenantInputEnvelope = {
    data: StockLotCreateManyTenantInput | StockLotCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StockEventCreateWithoutTenantInput = {
    id?: string
    type: $Enums.EStockEventType
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stock: StockCreateNestedOneWithoutStockEventInput
    entry?: StockEventEntryCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputCreateNestedOneWithoutStockEventInput
    StockLot?: StockLotCreateNestedOneWithoutStockEventsInput
  }

  export type StockEventUncheckedCreateWithoutTenantInput = {
    id?: string
    type: $Enums.EStockEventType
    stockId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLotId?: string | null
    entry?: StockEventEntryUncheckedCreateNestedOneWithoutStockEventInput
    output?: StockEventOutputUncheckedCreateNestedOneWithoutStockEventInput
  }

  export type StockEventCreateOrConnectWithoutTenantInput = {
    where: StockEventWhereUniqueInput
    create: XOR<StockEventCreateWithoutTenantInput, StockEventUncheckedCreateWithoutTenantInput>
  }

  export type StockEventCreateManyTenantInputEnvelope = {
    data: StockEventCreateManyTenantInput | StockEventCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NotificationTargetCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notification: NotificationCreateNestedOneWithoutTargetsInput
    user: UserCreateNestedOneWithoutNotificationTargetInput
  }

  export type NotificationTargetUncheckedCreateWithoutTenantInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notificationId: string
    userId: string
  }

  export type NotificationTargetCreateOrConnectWithoutTenantInput = {
    where: NotificationTargetWhereUniqueInput
    create: XOR<NotificationTargetCreateWithoutTenantInput, NotificationTargetUncheckedCreateWithoutTenantInput>
  }

  export type NotificationTargetCreateManyTenantInputEnvelope = {
    data: NotificationTargetCreateManyTenantInput | NotificationTargetCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserTenantSettingsCreateWithoutTenantInput = {
    doNotDisturb?: boolean
    user: UserCreateNestedOneWithoutTenantSettingsInput
  }

  export type UserTenantSettingsUncheckedCreateWithoutTenantInput = {
    doNotDisturb?: boolean
    userId: string
  }

  export type UserTenantSettingsCreateOrConnectWithoutTenantInput = {
    where: UserTenantSettingsWhereUniqueInput
    create: XOR<UserTenantSettingsCreateWithoutTenantInput, UserTenantSettingsUncheckedCreateWithoutTenantInput>
  }

  export type UserTenantSettingsCreateManyTenantInputEnvelope = {
    data: UserTenantSettingsCreateManyTenantInput | UserTenantSettingsCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TenantMembershipUpsertWithWhereUniqueWithoutTenantInput = {
    where: TenantMembershipWhereUniqueInput
    update: XOR<TenantMembershipUpdateWithoutTenantInput, TenantMembershipUncheckedUpdateWithoutTenantInput>
    create: XOR<TenantMembershipCreateWithoutTenantInput, TenantMembershipUncheckedCreateWithoutTenantInput>
  }

  export type TenantMembershipUpdateWithWhereUniqueWithoutTenantInput = {
    where: TenantMembershipWhereUniqueInput
    data: XOR<TenantMembershipUpdateWithoutTenantInput, TenantMembershipUncheckedUpdateWithoutTenantInput>
  }

  export type TenantMembershipUpdateManyWithWhereWithoutTenantInput = {
    where: TenantMembershipScalarWhereInput
    data: XOR<TenantMembershipUpdateManyMutationInput, TenantMembershipUncheckedUpdateManyWithoutTenantInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
    create: XOR<CustomerCreateWithoutTenantInput, CustomerUncheckedCreateWithoutTenantInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutTenantInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutTenantInput, CustomerUncheckedUpdateWithoutTenantInput>
  }

  export type CustomerUpdateManyWithWhereWithoutTenantInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutTenantInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: UuidFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    phoneNumber?: StringNullableFilter<"Customer"> | string | null
    active?: BoolNullableFilter<"Customer"> | boolean | null
    tenantId?: UuidFilter<"Customer"> | string
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutTenantInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTenantInput, ProductUncheckedUpdateWithoutTenantInput>
    create: XOR<ProductCreateWithoutTenantInput, ProductUncheckedCreateWithoutTenantInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTenantInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTenantInput, ProductUncheckedUpdateWithoutTenantInput>
  }

  export type ProductUpdateManyWithWhereWithoutTenantInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutTenantInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: UuidFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    barCode?: StringFilter<"Product"> | string
    internalCode?: StringFilter<"Product"> | string
    active?: BoolFilter<"Product"> | boolean
    skuCode?: StringFilter<"Product"> | string
    tenantId?: UuidFilter<"Product"> | string
    salePrice?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
  }

  export type SaleUpsertWithWhereUniqueWithoutTenantInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutTenantInput, SaleUncheckedUpdateWithoutTenantInput>
    create: XOR<SaleCreateWithoutTenantInput, SaleUncheckedCreateWithoutTenantInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutTenantInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutTenantInput, SaleUncheckedUpdateWithoutTenantInput>
  }

  export type SaleUpdateManyWithWhereWithoutTenantInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutTenantInput>
  }

  export type StockUpsertWithWhereUniqueWithoutTenantInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutTenantInput, StockUncheckedUpdateWithoutTenantInput>
    create: XOR<StockCreateWithoutTenantInput, StockUncheckedCreateWithoutTenantInput>
  }

  export type StockUpdateWithWhereUniqueWithoutTenantInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutTenantInput, StockUncheckedUpdateWithoutTenantInput>
  }

  export type StockUpdateManyWithWhereWithoutTenantInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutTenantInput>
  }

  export type StockScalarWhereInput = {
    AND?: StockScalarWhereInput | StockScalarWhereInput[]
    OR?: StockScalarWhereInput[]
    NOT?: StockScalarWhereInput | StockScalarWhereInput[]
    id?: UuidFilter<"Stock"> | string
    strategy?: EnumEStockStrategyFilter<"Stock"> | $Enums.EStockStrategy
    productId?: UuidFilter<"Stock"> | string
    totalQty?: IntFilter<"Stock"> | number
    availableQty?: IntFilter<"Stock"> | number
    tenantId?: UuidFilter<"Stock"> | string
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
  }

  export type StockLotUpsertWithWhereUniqueWithoutTenantInput = {
    where: StockLotWhereUniqueInput
    update: XOR<StockLotUpdateWithoutTenantInput, StockLotUncheckedUpdateWithoutTenantInput>
    create: XOR<StockLotCreateWithoutTenantInput, StockLotUncheckedCreateWithoutTenantInput>
  }

  export type StockLotUpdateWithWhereUniqueWithoutTenantInput = {
    where: StockLotWhereUniqueInput
    data: XOR<StockLotUpdateWithoutTenantInput, StockLotUncheckedUpdateWithoutTenantInput>
  }

  export type StockLotUpdateManyWithWhereWithoutTenantInput = {
    where: StockLotScalarWhereInput
    data: XOR<StockLotUpdateManyMutationInput, StockLotUncheckedUpdateManyWithoutTenantInput>
  }

  export type StockEventUpsertWithWhereUniqueWithoutTenantInput = {
    where: StockEventWhereUniqueInput
    update: XOR<StockEventUpdateWithoutTenantInput, StockEventUncheckedUpdateWithoutTenantInput>
    create: XOR<StockEventCreateWithoutTenantInput, StockEventUncheckedCreateWithoutTenantInput>
  }

  export type StockEventUpdateWithWhereUniqueWithoutTenantInput = {
    where: StockEventWhereUniqueInput
    data: XOR<StockEventUpdateWithoutTenantInput, StockEventUncheckedUpdateWithoutTenantInput>
  }

  export type StockEventUpdateManyWithWhereWithoutTenantInput = {
    where: StockEventScalarWhereInput
    data: XOR<StockEventUpdateManyMutationInput, StockEventUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationTargetUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationTargetWhereUniqueInput
    update: XOR<NotificationTargetUpdateWithoutTenantInput, NotificationTargetUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationTargetCreateWithoutTenantInput, NotificationTargetUncheckedCreateWithoutTenantInput>
  }

  export type NotificationTargetUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationTargetWhereUniqueInput
    data: XOR<NotificationTargetUpdateWithoutTenantInput, NotificationTargetUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationTargetUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationTargetScalarWhereInput
    data: XOR<NotificationTargetUpdateManyMutationInput, NotificationTargetUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserTenantSettingsUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserTenantSettingsWhereUniqueInput
    update: XOR<UserTenantSettingsUpdateWithoutTenantInput, UserTenantSettingsUncheckedUpdateWithoutTenantInput>
    create: XOR<UserTenantSettingsCreateWithoutTenantInput, UserTenantSettingsUncheckedCreateWithoutTenantInput>
  }

  export type UserTenantSettingsUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserTenantSettingsWhereUniqueInput
    data: XOR<UserTenantSettingsUpdateWithoutTenantInput, UserTenantSettingsUncheckedUpdateWithoutTenantInput>
  }

  export type UserTenantSettingsUpdateManyWithWhereWithoutTenantInput = {
    where: UserTenantSettingsScalarWhereInput
    data: XOR<UserTenantSettingsUpdateManyMutationInput, UserTenantSettingsUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserTenantSettingsScalarWhereInput = {
    AND?: UserTenantSettingsScalarWhereInput | UserTenantSettingsScalarWhereInput[]
    OR?: UserTenantSettingsScalarWhereInput[]
    NOT?: UserTenantSettingsScalarWhereInput | UserTenantSettingsScalarWhereInput[]
    doNotDisturb?: BoolFilter<"UserTenantSettings"> | boolean
    userId?: UuidFilter<"UserTenantSettings"> | string
    tenantId?: UuidFilter<"UserTenantSettings"> | string
  }

  export type MembershipCreateWithoutTenant_membershipsInput = {
    id?: string
    role: $Enums.EMembershipRole
    permissions?: MembershipCreatepermissionsInput | string[]
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type MembershipUncheckedCreateWithoutTenant_membershipsInput = {
    id?: string
    role: $Enums.EMembershipRole
    permissions?: MembershipCreatepermissionsInput | string[]
    active?: boolean | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MembershipCreateOrConnectWithoutTenant_membershipsInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutTenant_membershipsInput, MembershipUncheckedCreateWithoutTenant_membershipsInput>
  }

  export type TenantCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
    UserTenantSettings?: UserTenantSettingsUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMembershipsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
  }

  export type MembershipUpsertWithoutTenant_membershipsInput = {
    update: XOR<MembershipUpdateWithoutTenant_membershipsInput, MembershipUncheckedUpdateWithoutTenant_membershipsInput>
    create: XOR<MembershipCreateWithoutTenant_membershipsInput, MembershipUncheckedCreateWithoutTenant_membershipsInput>
    where?: MembershipWhereInput
  }

  export type MembershipUpdateToOneWithWhereWithoutTenant_membershipsInput = {
    where?: MembershipWhereInput
    data: XOR<MembershipUpdateWithoutTenant_membershipsInput, MembershipUncheckedUpdateWithoutTenant_membershipsInput>
  }

  export type MembershipUpdateWithoutTenant_membershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type MembershipUncheckedUpdateWithoutTenant_membershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUpsertWithoutMembershipsInput = {
    update: XOR<TenantUpdateWithoutMembershipsInput, TenantUncheckedUpdateWithoutMembershipsInput>
    create: XOR<TenantCreateWithoutMembershipsInput, TenantUncheckedCreateWithoutMembershipsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMembershipsInput, TenantUncheckedUpdateWithoutMembershipsInput>
  }

  export type TenantUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
    UserTenantSettings?: UserTenantSettingsUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserTenantSettingsCreateWithoutUserInput = {
    doNotDisturb?: boolean
    tenant: TenantCreateNestedOneWithoutUserTenantSettingsInput
  }

  export type UserTenantSettingsUncheckedCreateWithoutUserInput = {
    doNotDisturb?: boolean
    tenantId: string
  }

  export type UserTenantSettingsCreateOrConnectWithoutUserInput = {
    where: UserTenantSettingsWhereUniqueInput
    create: XOR<UserTenantSettingsCreateWithoutUserInput, UserTenantSettingsUncheckedCreateWithoutUserInput>
  }

  export type UserTenantSettingsCreateManyUserInputEnvelope = {
    data: UserTenantSettingsCreateManyUserInput | UserTenantSettingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationTargetCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notification: NotificationCreateNestedOneWithoutTargetsInput
    tenant: TenantCreateNestedOneWithoutNotificationTargetInput
  }

  export type NotificationTargetUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notificationId: string
    tenantId: string
  }

  export type NotificationTargetCreateOrConnectWithoutUserInput = {
    where: NotificationTargetWhereUniqueInput
    create: XOR<NotificationTargetCreateWithoutUserInput, NotificationTargetUncheckedCreateWithoutUserInput>
  }

  export type NotificationTargetCreateManyUserInputEnvelope = {
    data: NotificationTargetCreateManyUserInput | NotificationTargetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MembershipCreateWithoutUserInput = {
    id?: string
    role: $Enums.EMembershipRole
    permissions?: MembershipCreatepermissionsInput | string[]
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant_memberships?: TenantMembershipCreateNestedManyWithoutMembershipInput
  }

  export type MembershipUncheckedCreateWithoutUserInput = {
    id?: string
    role: $Enums.EMembershipRole
    permissions?: MembershipCreatepermissionsInput | string[]
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant_memberships?: TenantMembershipUncheckedCreateNestedManyWithoutMembershipInput
  }

  export type MembershipCreateOrConnectWithoutUserInput = {
    where: MembershipWhereUniqueInput
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MembershipCreateManyUserInputEnvelope = {
    data: MembershipCreateManyUserInput | MembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTenantSettingsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTenantSettingsWhereUniqueInput
    update: XOR<UserTenantSettingsUpdateWithoutUserInput, UserTenantSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserTenantSettingsCreateWithoutUserInput, UserTenantSettingsUncheckedCreateWithoutUserInput>
  }

  export type UserTenantSettingsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTenantSettingsWhereUniqueInput
    data: XOR<UserTenantSettingsUpdateWithoutUserInput, UserTenantSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserTenantSettingsUpdateManyWithWhereWithoutUserInput = {
    where: UserTenantSettingsScalarWhereInput
    data: XOR<UserTenantSettingsUpdateManyMutationInput, UserTenantSettingsUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationTargetUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationTargetWhereUniqueInput
    update: XOR<NotificationTargetUpdateWithoutUserInput, NotificationTargetUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationTargetCreateWithoutUserInput, NotificationTargetUncheckedCreateWithoutUserInput>
  }

  export type NotificationTargetUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationTargetWhereUniqueInput
    data: XOR<NotificationTargetUpdateWithoutUserInput, NotificationTargetUncheckedUpdateWithoutUserInput>
  }

  export type NotificationTargetUpdateManyWithWhereWithoutUserInput = {
    where: NotificationTargetScalarWhereInput
    data: XOR<NotificationTargetUpdateManyMutationInput, NotificationTargetUncheckedUpdateManyWithoutUserInput>
  }

  export type MembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput
    update: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
    create: XOR<MembershipCreateWithoutUserInput, MembershipUncheckedCreateWithoutUserInput>
  }

  export type MembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: MembershipWhereUniqueInput
    data: XOR<MembershipUpdateWithoutUserInput, MembershipUncheckedUpdateWithoutUserInput>
  }

  export type MembershipUpdateManyWithWhereWithoutUserInput = {
    where: MembershipScalarWhereInput
    data: XOR<MembershipUpdateManyMutationInput, MembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type MembershipScalarWhereInput = {
    AND?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
    OR?: MembershipScalarWhereInput[]
    NOT?: MembershipScalarWhereInput | MembershipScalarWhereInput[]
    id?: UuidFilter<"Membership"> | string
    role?: EnumEMembershipRoleFilter<"Membership"> | $Enums.EMembershipRole
    permissions?: StringNullableListFilter<"Membership">
    active?: BoolNullableFilter<"Membership"> | boolean | null
    userId?: UuidFilter<"Membership"> | string
    createdAt?: DateTimeFilter<"Membership"> | Date | string
    updatedAt?: DateTimeFilter<"Membership"> | Date | string
  }

  export type UserCreateWithoutTenantSettingsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutUserInput
    memberships?: MembershipCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantSettingsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: string
    active?: boolean
    firstAccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutUserInput
    memberships?: MembershipUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantSettingsInput, UserUncheckedCreateWithoutTenantSettingsInput>
  }

  export type TenantCreateWithoutUserTenantSettingsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipCreateNestedManyWithoutTenantInput
    customers?: CustomerCreateNestedManyWithoutTenantInput
    products?: ProductCreateNestedManyWithoutTenantInput
    sales?: SaleCreateNestedManyWithoutTenantInput
    stocks?: StockCreateNestedManyWithoutTenantInput
    stockLots?: StockLotCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUserTenantSettingsInput = {
    id?: string
    name: string
    description?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: TenantMembershipUncheckedCreateNestedManyWithoutTenantInput
    customers?: CustomerUncheckedCreateNestedManyWithoutTenantInput
    products?: ProductUncheckedCreateNestedManyWithoutTenantInput
    sales?: SaleUncheckedCreateNestedManyWithoutTenantInput
    stocks?: StockUncheckedCreateNestedManyWithoutTenantInput
    stockLots?: StockLotUncheckedCreateNestedManyWithoutTenantInput
    StockEvent?: StockEventUncheckedCreateNestedManyWithoutTenantInput
    NotificationTarget?: NotificationTargetUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUserTenantSettingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUserTenantSettingsInput, TenantUncheckedCreateWithoutUserTenantSettingsInput>
  }

  export type UserUpsertWithoutTenantSettingsInput = {
    update: XOR<UserUpdateWithoutTenantSettingsInput, UserUncheckedUpdateWithoutTenantSettingsInput>
    create: XOR<UserCreateWithoutTenantSettingsInput, UserUncheckedCreateWithoutTenantSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTenantSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTenantSettingsInput, UserUncheckedUpdateWithoutTenantSettingsInput>
  }

  export type UserUpdateWithoutTenantSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationTarget?: NotificationTargetUpdateManyWithoutUserNestedInput
    memberships?: MembershipUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    firstAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutUserNestedInput
    memberships?: MembershipUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantUpsertWithoutUserTenantSettingsInput = {
    update: XOR<TenantUpdateWithoutUserTenantSettingsInput, TenantUncheckedUpdateWithoutUserTenantSettingsInput>
    create: XOR<TenantCreateWithoutUserTenantSettingsInput, TenantUncheckedCreateWithoutUserTenantSettingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUserTenantSettingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUserTenantSettingsInput, TenantUncheckedUpdateWithoutUserTenantSettingsInput>
  }

  export type TenantUpdateWithoutUserTenantSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUpdateManyWithoutTenantNestedInput
    customers?: CustomerUpdateManyWithoutTenantNestedInput
    products?: ProductUpdateManyWithoutTenantNestedInput
    sales?: SaleUpdateManyWithoutTenantNestedInput
    stocks?: StockUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUserTenantSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: TenantMembershipUncheckedUpdateManyWithoutTenantNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutTenantNestedInput
    products?: ProductUncheckedUpdateManyWithoutTenantNestedInput
    sales?: SaleUncheckedUpdateManyWithoutTenantNestedInput
    stocks?: StockUncheckedUpdateManyWithoutTenantNestedInput
    stockLots?: StockLotUncheckedUpdateManyWithoutTenantNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutTenantNestedInput
    NotificationTarget?: NotificationTargetUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SaleCreateManyCustomerInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    tenantId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PosEventSaleCreateManyCustomerInput = {
    id: string
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    saleId: string
  }

  export type SaleUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    movements?: SaleMovementUpdateManyWithoutSaleNestedInput
    tenant?: TenantUpdateOneRequiredWithoutSalesNestedInput
    PosEventSale?: PosEventSaleUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    movements?: SaleMovementUncheckedUpdateManyWithoutSaleNestedInput
    PosEventSale?: PosEventSaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PosEventSaleUpdateWithoutCustomerInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    sale?: SaleUpdateOneRequiredWithoutPosEventSaleNestedInput
    posEvent?: PosEventUpdateOneRequiredWithoutSaleNestedInput
    products?: PosEventSaleProductUpdateManyWithoutPosEventSaleNestedInput
    movements?: PosEventSaleMovementUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    saleId?: StringFieldUpdateOperationsInput | string
    products?: PosEventSaleProductUncheckedUpdateManyWithoutPosEventSaleNestedInput
    movements?: PosEventSaleMovementUncheckedUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    saleId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantMembershipCreateManyMembershipInput = {
    tenantId: string
  }

  export type TenantMembershipUpdateWithoutMembershipInput = {
    tenant?: TenantUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type TenantMembershipUncheckedUpdateWithoutMembershipInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantMembershipUncheckedUpdateManyWithoutMembershipInput = {
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationTargetCreateManyNotificationInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    userId: string
    tenantId: string
  }

  export type NotificationTargetUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    user?: UserUpdateOneRequiredWithoutNotificationTargetNestedInput
    tenant?: TenantUpdateOneRequiredWithoutNotificationTargetNestedInput
  }

  export type NotificationTargetUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationTargetUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventSaleProductCreateManyPosEventSaleInput = {
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
  }

  export type PosEventSaleMovementCreateManyPosEventSaleInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleProductUpdateWithoutPosEventSaleInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPosEventSaleProductNestedInput
  }

  export type PosEventSaleProductUncheckedUpdateWithoutPosEventSaleInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventSaleProductUncheckedUpdateManyWithoutPosEventSaleInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type PosEventSaleMovementUpdateWithoutPosEventSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PosEventSaleMovementPaymentUpdateManyWithoutPosEventSaleMovementNestedInput
    changes?: PosEventSaleMovementChangeUpdateManyWithoutPosEventSaleMovementNestedInput
  }

  export type PosEventSaleMovementUncheckedUpdateWithoutPosEventSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PosEventSaleMovementPaymentUncheckedUpdateManyWithoutPosEventSaleMovementNestedInput
    changes?: PosEventSaleMovementChangeUncheckedUpdateManyWithoutPosEventSaleMovementNestedInput
  }

  export type PosEventSaleMovementUncheckedUpdateManyWithoutPosEventSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementPaymentCreateManyPosEventSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementChangeCreateManyPosEventSaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleMovementPaymentUpdateWithoutPosEventSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementPaymentUncheckedUpdateWithoutPosEventSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementPaymentUncheckedUpdateManyWithoutPosEventSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementChangeUpdateWithoutPosEventSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementChangeUncheckedUpdateWithoutPosEventSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleMovementChangeUncheckedUpdateManyWithoutPosEventSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateManyProductInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    stockLotId: string
  }

  export type ProductSpecificationCreateManyProductInput = {
    id?: string
    label: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleProductCreateManyProductInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutProductsNestedInput
    stockLot?: StockLotUpdateOneRequiredWithoutSaleProductNestedInput
  }

  export type SaleProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    stockLotId?: StringFieldUpdateOperationsInput | string
  }

  export type SaleProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    stockLotId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductSpecificationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSpecificationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductSpecificationUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleProductUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posEventSale?: PosEventSaleUpdateOneRequiredWithoutProductsNestedInput
  }

  export type PosEventSaleProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductCreateManySaleInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    productId: string
    stockLotId: string
  }

  export type SaleMovementCreateManySaleInput = {
    id?: string
    type: $Enums.ESaleMovementType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PosEventSaleCreateManySaleInput = {
    id: string
    description?: string
    amount: Decimal | DecimalJsLike | number | string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    customerId: string
  }

  export type SaleProductUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSaleProductsNestedInput
    stockLot?: StockLotUpdateOneRequiredWithoutSaleProductNestedInput
  }

  export type SaleProductUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    stockLotId?: StringFieldUpdateOperationsInput | string
  }

  export type SaleProductUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: StringFieldUpdateOperationsInput | string
    stockLotId?: StringFieldUpdateOperationsInput | string
  }

  export type SaleMovementUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: SaleMovementPaymentUpdateManyWithoutSaleMovementNestedInput
    changes?: SaleMovementChangeUpdateManyWithoutSaleMovementNestedInput
  }

  export type SaleMovementUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: SaleMovementPaymentUncheckedUpdateManyWithoutSaleMovementNestedInput
    changes?: SaleMovementChangeUncheckedUpdateManyWithoutSaleMovementNestedInput
  }

  export type SaleMovementUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumESaleMovementTypeFieldUpdateOperationsInput | $Enums.ESaleMovementType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PosEventSaleUpdateWithoutSaleInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    customer?: CustomerUpdateOneRequiredWithoutPosEventSalesNestedInput
    posEvent?: PosEventUpdateOneRequiredWithoutSaleNestedInput
    products?: PosEventSaleProductUpdateManyWithoutPosEventSaleNestedInput
    movements?: PosEventSaleMovementUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleUncheckedUpdateWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
    products?: PosEventSaleProductUncheckedUpdateManyWithoutPosEventSaleNestedInput
    movements?: PosEventSaleMovementUncheckedUpdateManyWithoutPosEventSaleNestedInput
  }

  export type PosEventSaleUncheckedUpdateManyWithoutSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    customerId?: StringFieldUpdateOperationsInput | string
  }

  export type SaleMovementPaymentCreateManySaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementChangeCreateManySaleMovementInput = {
    method: $Enums.EPaymentMethod
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleMovementPaymentUpdateWithoutSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementPaymentUncheckedUpdateWithoutSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementPaymentUncheckedUpdateManyWithoutSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementChangeUpdateWithoutSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementChangeUncheckedUpdateWithoutSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleMovementChangeUncheckedUpdateManyWithoutSaleMovementInput = {
    method?: EnumEPaymentMethodFieldUpdateOperationsInput | $Enums.EPaymentMethod
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLotCreateManyStockInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    tenantId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockEventCreateManyStockInput = {
    id?: string
    type: $Enums.EStockEventType
    tenantId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLotId?: string | null
  }

  export type StockLotUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockLotsNestedInput
    stockEvents?: StockEventUpdateManyWithoutStockLotNestedInput
    saleProduct?: SaleProductUpdateManyWithoutStockLotNestedInput
  }

  export type StockLotUncheckedUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockEvents?: StockEventUncheckedUpdateManyWithoutStockLotNestedInput
    saleProduct?: SaleProductUncheckedUpdateManyWithoutStockLotNestedInput
  }

  export type StockLotUncheckedUpdateManyWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockEventUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStockEventNestedInput
    entry?: StockEventEntryUpdateOneWithoutStockEventNestedInput
    output?: StockEventOutputUpdateOneWithoutStockEventNestedInput
    StockLot?: StockLotUpdateOneWithoutStockEventsNestedInput
  }

  export type StockEventUncheckedUpdateWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLotId?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: StockEventEntryUncheckedUpdateOneWithoutStockEventNestedInput
    output?: StockEventOutputUncheckedUpdateOneWithoutStockEventNestedInput
  }

  export type StockEventUncheckedUpdateManyWithoutStockInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLotId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockEventCreateManyStockLotInput = {
    id?: string
    type: $Enums.EStockEventType
    stockId: string
    tenantId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleProductCreateManyStockLotInput = {
    id?: string
    name: string
    description?: string
    costPrice: Decimal | DecimalJsLike | number | string
    salePrice: Decimal | DecimalJsLike | number | string
    totalQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    saleId: string
    productId: string
  }

  export type StockEventUpdateWithoutStockLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutStockEventNestedInput
    tenant?: TenantUpdateOneRequiredWithoutStockEventNestedInput
    entry?: StockEventEntryUpdateOneWithoutStockEventNestedInput
    output?: StockEventOutputUpdateOneWithoutStockEventNestedInput
  }

  export type StockEventUncheckedUpdateWithoutStockLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entry?: StockEventEntryUncheckedUpdateOneWithoutStockEventNestedInput
    output?: StockEventOutputUncheckedUpdateOneWithoutStockEventNestedInput
  }

  export type StockEventUncheckedUpdateManyWithoutStockLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    stockId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleProductUpdateWithoutStockLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sale?: SaleUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutSaleProductsNestedInput
  }

  export type SaleProductUncheckedUpdateWithoutStockLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type SaleProductUncheckedUpdateManyWithoutStockLotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantMembershipCreateManyTenantInput = {
    membershipId: string
  }

  export type CustomerCreateManyTenantInput = {
    id?: string
    name?: string
    phoneNumber?: string | null
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProductCreateManyTenantInput = {
    id?: string
    name: string
    description?: string
    barCode: string
    internalCode: string
    active?: boolean
    skuCode: string
    salePrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SaleCreateManyTenantInput = {
    id?: string
    status?: $Enums.ESaleStatus
    internalCode: string
    customerId: string
    discountVariant?: $Enums.EDiscountVariant
    discountValue?: number
    paidTotal: Decimal | DecimalJsLike | number | string
    estimatedTotal: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type StockCreateManyTenantInput = {
    id?: string
    strategy: $Enums.EStockStrategy
    productId: string
    totalQty?: number
    availableQty?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockLotCreateManyTenantInput = {
    id?: string
    lotNumber: string
    totalQty?: number
    costPrice?: Decimal | DecimalJsLike | number | string
    stockId: string
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockEventCreateManyTenantInput = {
    id?: string
    type: $Enums.EStockEventType
    stockId: string
    description?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    stockLotId?: string | null
  }

  export type NotificationTargetCreateManyTenantInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notificationId: string
    userId: string
  }

  export type UserTenantSettingsCreateManyTenantInput = {
    doNotDisturb?: boolean
    userId: string
  }

  export type TenantMembershipUpdateWithoutTenantInput = {
    membership?: MembershipUpdateOneRequiredWithoutTenant_membershipsNestedInput
  }

  export type TenantMembershipUncheckedUpdateWithoutTenantInput = {
    membershipId?: StringFieldUpdateOperationsInput | string
  }

  export type TenantMembershipUncheckedUpdateManyWithoutTenantInput = {
    membershipId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: SaleUpdateManyWithoutCustomerNestedInput
    posEventSales?: PosEventSaleUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sales?: SaleUncheckedUpdateManyWithoutCustomerNestedInput
    posEventSales?: PosEventSaleUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUpdateOneWithoutProductNestedInput
    saleProducts?: SaleProductUpdateManyWithoutProductNestedInput
    specifications?: ProductSpecificationUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stock?: StockUncheckedUpdateOneWithoutProductNestedInput
    saleProducts?: SaleProductUncheckedUpdateManyWithoutProductNestedInput
    specifications?: ProductSpecificationUncheckedUpdateManyWithoutProductNestedInput
    PosEventSaleProduct?: PosEventSaleProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    barCode?: StringFieldUpdateOperationsInput | string
    internalCode?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    skuCode?: StringFieldUpdateOperationsInput | string
    salePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SaleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUpdateManyWithoutSaleNestedInput
    movements?: SaleMovementUpdateManyWithoutSaleNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSalesNestedInput
    PosEventSale?: PosEventSaleUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: SaleProductUncheckedUpdateManyWithoutSaleNestedInput
    movements?: SaleMovementUncheckedUpdateManyWithoutSaleNestedInput
    PosEventSale?: PosEventSaleUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumESaleStatusFieldUpdateOperationsInput | $Enums.ESaleStatus
    internalCode?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    discountVariant?: EnumEDiscountVariantFieldUpdateOperationsInput | $Enums.EDiscountVariant
    discountValue?: FloatFieldUpdateOperationsInput | number
    paidTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    estimatedTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StockUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutStockNestedInput
    lots?: StockLotUpdateManyWithoutStockNestedInput
    StockEvent?: StockEventUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    productId?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lots?: StockLotUncheckedUpdateManyWithoutStockNestedInput
    StockEvent?: StockEventUncheckedUpdateManyWithoutStockNestedInput
  }

  export type StockUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategy?: EnumEStockStrategyFieldUpdateOperationsInput | $Enums.EStockStrategy
    productId?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    availableQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockLotUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutLotsNestedInput
    stockEvents?: StockEventUpdateManyWithoutStockLotNestedInput
    saleProduct?: SaleProductUpdateManyWithoutStockLotNestedInput
  }

  export type StockLotUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockEvents?: StockEventUncheckedUpdateManyWithoutStockLotNestedInput
    saleProduct?: SaleProductUncheckedUpdateManyWithoutStockLotNestedInput
  }

  export type StockLotUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    lotNumber?: StringFieldUpdateOperationsInput | string
    totalQty?: IntFieldUpdateOperationsInput | number
    costPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockId?: StringFieldUpdateOperationsInput | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockEventUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stock?: StockUpdateOneRequiredWithoutStockEventNestedInput
    entry?: StockEventEntryUpdateOneWithoutStockEventNestedInput
    output?: StockEventOutputUpdateOneWithoutStockEventNestedInput
    StockLot?: StockLotUpdateOneWithoutStockEventsNestedInput
  }

  export type StockEventUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    stockId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLotId?: NullableStringFieldUpdateOperationsInput | string | null
    entry?: StockEventEntryUncheckedUpdateOneWithoutStockEventNestedInput
    output?: StockEventOutputUncheckedUpdateOneWithoutStockEventNestedInput
  }

  export type StockEventUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEStockEventTypeFieldUpdateOperationsInput | $Enums.EStockEventType
    stockId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockLotId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationTargetUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notification?: NotificationUpdateOneRequiredWithoutTargetsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationTargetNestedInput
  }

  export type NotificationTargetUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationTargetUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notificationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserTenantSettingsUpdateWithoutTenantInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutTenantSettingsNestedInput
  }

  export type UserTenantSettingsUncheckedUpdateWithoutTenantInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserTenantSettingsUncheckedUpdateManyWithoutTenantInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserTenantSettingsCreateManyUserInput = {
    doNotDisturb?: boolean
    tenantId: string
  }

  export type NotificationTargetCreateManyUserInput = {
    id?: string
    status?: $Enums.ENotificationTargetStatus
    notificationId: string
    tenantId: string
  }

  export type MembershipCreateManyUserInput = {
    id?: string
    role: $Enums.EMembershipRole
    permissions?: MembershipCreatepermissionsInput | string[]
    active?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTenantSettingsUpdateWithoutUserInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    tenant?: TenantUpdateOneRequiredWithoutUserTenantSettingsNestedInput
  }

  export type UserTenantSettingsUncheckedUpdateWithoutUserInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type UserTenantSettingsUncheckedUpdateManyWithoutUserInput = {
    doNotDisturb?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationTargetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notification?: NotificationUpdateOneRequiredWithoutTargetsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutNotificationTargetNestedInput
  }

  export type NotificationTargetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notificationId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationTargetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumENotificationTargetStatusFieldUpdateOperationsInput | $Enums.ENotificationTargetStatus
    notificationId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
  }

  export type MembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant_memberships?: TenantMembershipUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant_memberships?: TenantMembershipUncheckedUpdateManyWithoutMembershipNestedInput
  }

  export type MembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumEMembershipRoleFieldUpdateOperationsInput | $Enums.EMembershipRole
    permissions?: MembershipUpdatepermissionsInput | string[]
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}